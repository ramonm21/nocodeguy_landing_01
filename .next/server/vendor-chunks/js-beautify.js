"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/js-beautify";
exports.ids = ["vendor-chunks/js-beautify"];
exports.modules = {

/***/ "(rsc)/./node_modules/js-beautify/js/index.js":
/*!**********************************************!*\
  !*** ./node_modules/js-beautify/js/index.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jshint node:true */ /* globals define */ /*\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n*/ \n/**\nThe following batches are equivalent:\n\nvar beautify_js = require('js-beautify');\nvar beautify_js = require('js-beautify').js;\nvar beautify_js = require('js-beautify').js_beautify;\n\nvar beautify_css = require('js-beautify').css;\nvar beautify_css = require('js-beautify').css_beautify;\n\nvar beautify_html = require('js-beautify').html;\nvar beautify_html = require('js-beautify').html_beautify;\n\nAll methods returned accept two arguments, the source string and an options object.\n**/ function get_beautify(js_beautify, css_beautify, html_beautify) {\n    // the default is js\n    var beautify = function(src, config) {\n        return js_beautify.js_beautify(src, config);\n    };\n    // short aliases\n    beautify.js = js_beautify.js_beautify;\n    beautify.css = css_beautify.css_beautify;\n    beautify.html = html_beautify.html_beautify;\n    // legacy aliases\n    beautify.js_beautify = js_beautify.js_beautify;\n    beautify.css_beautify = css_beautify.css_beautify;\n    beautify.html_beautify = html_beautify.html_beautify;\n    return beautify;\n}\nif (true) {\n    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(/*! ./lib/beautify */ \"(rsc)/./node_modules/js-beautify/js/lib/beautify.js\"),\n        __webpack_require__(/*! ./lib/beautify-css */ \"(rsc)/./node_modules/js-beautify/js/lib/beautify-css.js\"),\n        __webpack_require__(/*! ./lib/beautify-html */ \"(rsc)/./node_modules/js-beautify/js/lib/beautify-html.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(js_beautify, css_beautify, html_beautify) {\n        return get_beautify(js_beautify, css_beautify, html_beautify);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsbUZBQW1CLEdBQ25CLGtCQUFrQixHQUNsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQSxHQUVBO0FBRUE7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FFRCxTQUFTQSxhQUFhQyxXQUFXLEVBQUVDLFlBQVksRUFBRUMsYUFBYTtJQUM1RCxvQkFBb0I7SUFDcEIsSUFBSUMsV0FBVyxTQUFTQyxHQUFHLEVBQUVDLE1BQU07UUFDakMsT0FBT0wsWUFBWUEsV0FBVyxDQUFDSSxLQUFLQztJQUN0QztJQUVBLGdCQUFnQjtJQUNoQkYsU0FBU0csRUFBRSxHQUFHTixZQUFZQSxXQUFXO0lBQ3JDRyxTQUFTSSxHQUFHLEdBQUdOLGFBQWFBLFlBQVk7SUFDeENFLFNBQVNLLElBQUksR0FBR04sY0FBY0EsYUFBYTtJQUUzQyxpQkFBaUI7SUFDakJDLFNBQVNILFdBQVcsR0FBR0EsWUFBWUEsV0FBVztJQUM5Q0csU0FBU0YsWUFBWSxHQUFHQSxhQUFhQSxZQUFZO0lBQ2pERSxTQUFTRCxhQUFhLEdBQUdBLGNBQWNBLGFBQWE7SUFFcEQsT0FBT0M7QUFDVDtBQUVBLElBQUksSUFBMEMsRUFBRTtJQUM5QywwRkFBMEY7SUFDMUZNLGlDQUFPO1FBQ0wsZ0dBQWdCO1FBQ2hCLHdHQUFvQjtRQUNwQiwwR0FBcUI7S0FDdEIsbUNBQUUsU0FBU1QsV0FBVyxFQUFFQyxZQUFZLEVBQUVDLGFBQWE7UUFDbEQsT0FBT0gsYUFBYUMsYUFBYUMsY0FBY0M7SUFDakQsQ0FBQztBQUFBLGtHQUFDO0FBQ0osT0FBTyxFQVVOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL2luZGV4LmpzPzFjYTgiXSwic291cmNlc0NvbnRlbnQiOlsiLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKiBnbG9iYWxzIGRlZmluZSAqL1xuLypcbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuVGhlIGZvbGxvd2luZyBiYXRjaGVzIGFyZSBlcXVpdmFsZW50OlxuXG52YXIgYmVhdXRpZnlfanMgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpO1xudmFyIGJlYXV0aWZ5X2pzID0gcmVxdWlyZSgnanMtYmVhdXRpZnknKS5qcztcbnZhciBiZWF1dGlmeV9qcyA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuanNfYmVhdXRpZnk7XG5cbnZhciBiZWF1dGlmeV9jc3MgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmNzcztcbnZhciBiZWF1dGlmeV9jc3MgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmNzc19iZWF1dGlmeTtcblxudmFyIGJlYXV0aWZ5X2h0bWwgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmh0bWw7XG52YXIgYmVhdXRpZnlfaHRtbCA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuaHRtbF9iZWF1dGlmeTtcblxuQWxsIG1ldGhvZHMgcmV0dXJuZWQgYWNjZXB0IHR3byBhcmd1bWVudHMsIHRoZSBzb3VyY2Ugc3RyaW5nIGFuZCBhbiBvcHRpb25zIG9iamVjdC5cbioqL1xuXG5mdW5jdGlvbiBnZXRfYmVhdXRpZnkoanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSwgaHRtbF9iZWF1dGlmeSkge1xuICAvLyB0aGUgZGVmYXVsdCBpcyBqc1xuICB2YXIgYmVhdXRpZnkgPSBmdW5jdGlvbihzcmMsIGNvbmZpZykge1xuICAgIHJldHVybiBqc19iZWF1dGlmeS5qc19iZWF1dGlmeShzcmMsIGNvbmZpZyk7XG4gIH07XG5cbiAgLy8gc2hvcnQgYWxpYXNlc1xuICBiZWF1dGlmeS5qcyA9IGpzX2JlYXV0aWZ5LmpzX2JlYXV0aWZ5O1xuICBiZWF1dGlmeS5jc3MgPSBjc3NfYmVhdXRpZnkuY3NzX2JlYXV0aWZ5O1xuICBiZWF1dGlmeS5odG1sID0gaHRtbF9iZWF1dGlmeS5odG1sX2JlYXV0aWZ5O1xuXG4gIC8vIGxlZ2FjeSBhbGlhc2VzXG4gIGJlYXV0aWZ5LmpzX2JlYXV0aWZ5ID0ganNfYmVhdXRpZnkuanNfYmVhdXRpZnk7XG4gIGJlYXV0aWZ5LmNzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeS5jc3NfYmVhdXRpZnk7XG4gIGJlYXV0aWZ5Lmh0bWxfYmVhdXRpZnkgPSBodG1sX2JlYXV0aWZ5Lmh0bWxfYmVhdXRpZnk7XG5cbiAgcmV0dXJuIGJlYXV0aWZ5O1xufVxuXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgLy8gQWRkIHN1cHBvcnQgZm9yIEFNRCAoIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTUQjZGVmaW5lYW1kLXByb3BlcnR5LSApXG4gIGRlZmluZShbXG4gICAgXCIuL2xpYi9iZWF1dGlmeVwiLFxuICAgIFwiLi9saWIvYmVhdXRpZnktY3NzXCIsXG4gICAgXCIuL2xpYi9iZWF1dGlmeS1odG1sXCJcbiAgXSwgZnVuY3Rpb24oanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSwgaHRtbF9iZWF1dGlmeSkge1xuICAgIHJldHVybiBnZXRfYmVhdXRpZnkoanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSwgaHRtbF9iZWF1dGlmeSk7XG4gIH0pO1xufSBlbHNlIHtcbiAgKGZ1bmN0aW9uKG1vZCkge1xuICAgIHZhciBiZWF1dGlmaWVyID0gcmVxdWlyZSgnLi9zcmMvaW5kZXgnKTtcbiAgICBiZWF1dGlmaWVyLmpzX2JlYXV0aWZ5ID0gYmVhdXRpZmllci5qcztcbiAgICBiZWF1dGlmaWVyLmNzc19iZWF1dGlmeSA9IGJlYXV0aWZpZXIuY3NzO1xuICAgIGJlYXV0aWZpZXIuaHRtbF9iZWF1dGlmeSA9IGJlYXV0aWZpZXIuaHRtbDtcblxuICAgIG1vZC5leHBvcnRzID0gZ2V0X2JlYXV0aWZ5KGJlYXV0aWZpZXIsIGJlYXV0aWZpZXIsIGJlYXV0aWZpZXIpO1xuXG4gIH0pKG1vZHVsZSk7XG59Il0sIm5hbWVzIjpbImdldF9iZWF1dGlmeSIsImpzX2JlYXV0aWZ5IiwiY3NzX2JlYXV0aWZ5IiwiaHRtbF9iZWF1dGlmeSIsImJlYXV0aWZ5Iiwic3JjIiwiY29uZmlnIiwianMiLCJjc3MiLCJodG1sIiwiZGVmaW5lIiwiYW1kIiwibW9kIiwiYmVhdXRpZmllciIsInJlcXVpcmUiLCJleHBvcnRzIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/js-beautify/js/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/js-beautify/js/lib/beautify-css.js":
/*!*********************************************************!*\
  !*** ./node_modules/js-beautify/js/lib/beautify-css.js ***!
  \*********************************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/* AUTO-GENERATED. DO NOT MODIFY. */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n\n CSS Beautifier\n---------------\n\n    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)\n\n    Based on code initially developed by: Einar Lielmanis, <einar@beautifier.io>\n        https://beautifier.io/\n\n    Usage:\n        css_beautify(source_text);\n        css_beautify(source_text, options);\n\n    The options are (default in brackets):\n        indent_size (4)                         — indentation size,\n        indent_char (space)                     — character to indent with,\n        selector_separator_newline (true)       - separate selectors with newline or\n                                                  not (e.g. \"a,\\nbr\" or \"a, br\")\n        end_with_newline (false)                - end with a newline\n        newline_between_rules (true)            - add a new line after every css rule\n        space_around_selector_separator (false) - ensure space around selector separators:\n                                                  '>', '+', '~' (e.g. \"a>b\" -> \"a > b\")\n    e.g\n\n    css_beautify(css_source_text, {\n      'indent_size': 1,\n      'indent_char': '\\t',\n      'selector_separator': ' ',\n      'end_with_newline': false,\n      'newline_between_rules': true,\n      'space_around_selector_separator': true\n    });\n*/ // http://www.w3.org/TR/CSS21/syndata.html#tokenization\n// http://www.w3.org/TR/css3-syntax/\n(function() {\n    /* GENERATED_BUILD_OUTPUT */ var legacy_beautify_css;\n    /******/ (function() {\n        /******/ \"use strict\";\n        /******/ var __webpack_modules__ = [\n            ,\n            ,\n            /* 2 */ /***/ function(module) {\n                /*jshint node:true */ /*\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function OutputLine(parent) {\n                    this.__parent = parent;\n                    this.__character_count = 0;\n                    // use indent_count as a marker for this.__lines that have preserved indentation\n                    this.__indent_count = -1;\n                    this.__alignment_count = 0;\n                    this.__wrap_point_index = 0;\n                    this.__wrap_point_character_count = 0;\n                    this.__wrap_point_indent_count = -1;\n                    this.__wrap_point_alignment_count = 0;\n                    this.__items = [];\n                }\n                OutputLine.prototype.clone_empty = function() {\n                    var line = new OutputLine(this.__parent);\n                    line.set_indent(this.__indent_count, this.__alignment_count);\n                    return line;\n                };\n                OutputLine.prototype.item = function(index) {\n                    if (index < 0) {\n                        return this.__items[this.__items.length + index];\n                    } else {\n                        return this.__items[index];\n                    }\n                };\n                OutputLine.prototype.has_match = function(pattern) {\n                    for(var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--){\n                        if (this.__items[lastCheckedOutput].match(pattern)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n                OutputLine.prototype.set_indent = function(indent, alignment) {\n                    if (this.is_empty()) {\n                        this.__indent_count = indent || 0;\n                        this.__alignment_count = alignment || 0;\n                        this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);\n                    }\n                };\n                OutputLine.prototype._set_wrap_point = function() {\n                    if (this.__parent.wrap_line_length) {\n                        this.__wrap_point_index = this.__items.length;\n                        this.__wrap_point_character_count = this.__character_count;\n                        this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;\n                        this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;\n                    }\n                };\n                OutputLine.prototype._should_wrap = function() {\n                    return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;\n                };\n                OutputLine.prototype._allow_wrap = function() {\n                    if (this._should_wrap()) {\n                        this.__parent.add_new_line();\n                        var next = this.__parent.current_line;\n                        next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);\n                        next.__items = this.__items.slice(this.__wrap_point_index);\n                        this.__items = this.__items.slice(0, this.__wrap_point_index);\n                        next.__character_count += this.__character_count - this.__wrap_point_character_count;\n                        this.__character_count = this.__wrap_point_character_count;\n                        if (next.__items[0] === \" \") {\n                            next.__items.splice(0, 1);\n                            next.__character_count -= 1;\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                OutputLine.prototype.is_empty = function() {\n                    return this.__items.length === 0;\n                };\n                OutputLine.prototype.last = function() {\n                    if (!this.is_empty()) {\n                        return this.__items[this.__items.length - 1];\n                    } else {\n                        return null;\n                    }\n                };\n                OutputLine.prototype.push = function(item) {\n                    this.__items.push(item);\n                    var last_newline_index = item.lastIndexOf(\"\\n\");\n                    if (last_newline_index !== -1) {\n                        this.__character_count = item.length - last_newline_index;\n                    } else {\n                        this.__character_count += item.length;\n                    }\n                };\n                OutputLine.prototype.pop = function() {\n                    var item = null;\n                    if (!this.is_empty()) {\n                        item = this.__items.pop();\n                        this.__character_count -= item.length;\n                    }\n                    return item;\n                };\n                OutputLine.prototype._remove_indent = function() {\n                    if (this.__indent_count > 0) {\n                        this.__indent_count -= 1;\n                        this.__character_count -= this.__parent.indent_size;\n                    }\n                };\n                OutputLine.prototype._remove_wrap_indent = function() {\n                    if (this.__wrap_point_indent_count > 0) {\n                        this.__wrap_point_indent_count -= 1;\n                    }\n                };\n                OutputLine.prototype.trim = function() {\n                    while(this.last() === \" \"){\n                        this.__items.pop();\n                        this.__character_count -= 1;\n                    }\n                };\n                OutputLine.prototype.toString = function() {\n                    var result = \"\";\n                    if (this.is_empty()) {\n                        if (this.__parent.indent_empty_lines) {\n                            result = this.__parent.get_indent_string(this.__indent_count);\n                        }\n                    } else {\n                        result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);\n                        result += this.__items.join(\"\");\n                    }\n                    return result;\n                };\n                function IndentStringCache(options, baseIndentString) {\n                    this.__cache = [\n                        \"\"\n                    ];\n                    this.__indent_size = options.indent_size;\n                    this.__indent_string = options.indent_char;\n                    if (!options.indent_with_tabs) {\n                        this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);\n                    }\n                    // Set to null to continue support for auto detection of base indent\n                    baseIndentString = baseIndentString || \"\";\n                    if (options.indent_level > 0) {\n                        baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);\n                    }\n                    this.__base_string = baseIndentString;\n                    this.__base_string_length = baseIndentString.length;\n                }\n                IndentStringCache.prototype.get_indent_size = function(indent, column) {\n                    var result = this.__base_string_length;\n                    column = column || 0;\n                    if (indent < 0) {\n                        result = 0;\n                    }\n                    result += indent * this.__indent_size;\n                    result += column;\n                    return result;\n                };\n                IndentStringCache.prototype.get_indent_string = function(indent_level, column) {\n                    var result = this.__base_string;\n                    column = column || 0;\n                    if (indent_level < 0) {\n                        indent_level = 0;\n                        result = \"\";\n                    }\n                    column += indent_level * this.__indent_size;\n                    this.__ensure_cache(column);\n                    result += this.__cache[column];\n                    return result;\n                };\n                IndentStringCache.prototype.__ensure_cache = function(column) {\n                    while(column >= this.__cache.length){\n                        this.__add_column();\n                    }\n                };\n                IndentStringCache.prototype.__add_column = function() {\n                    var column = this.__cache.length;\n                    var indent = 0;\n                    var result = \"\";\n                    if (this.__indent_size && column >= this.__indent_size) {\n                        indent = Math.floor(column / this.__indent_size);\n                        column -= indent * this.__indent_size;\n                        result = new Array(indent + 1).join(this.__indent_string);\n                    }\n                    if (column) {\n                        result += new Array(column + 1).join(\" \");\n                    }\n                    this.__cache.push(result);\n                };\n                function Output(options, baseIndentString) {\n                    this.__indent_cache = new IndentStringCache(options, baseIndentString);\n                    this.raw = false;\n                    this._end_with_newline = options.end_with_newline;\n                    this.indent_size = options.indent_size;\n                    this.wrap_line_length = options.wrap_line_length;\n                    this.indent_empty_lines = options.indent_empty_lines;\n                    this.__lines = [];\n                    this.previous_line = null;\n                    this.current_line = null;\n                    this.next_line = new OutputLine(this);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = false;\n                    // initialize\n                    this.__add_outputline();\n                }\n                Output.prototype.__add_outputline = function() {\n                    this.previous_line = this.current_line;\n                    this.current_line = this.next_line.clone_empty();\n                    this.__lines.push(this.current_line);\n                };\n                Output.prototype.get_line_number = function() {\n                    return this.__lines.length;\n                };\n                Output.prototype.get_indent_string = function(indent, column) {\n                    return this.__indent_cache.get_indent_string(indent, column);\n                };\n                Output.prototype.get_indent_size = function(indent, column) {\n                    return this.__indent_cache.get_indent_size(indent, column);\n                };\n                Output.prototype.is_empty = function() {\n                    return !this.previous_line && this.current_line.is_empty();\n                };\n                Output.prototype.add_new_line = function(force_newline) {\n                    // never newline at the start of file\n                    // otherwise, newline only if we didn't just add one or we're forced\n                    if (this.is_empty() || !force_newline && this.just_added_newline()) {\n                        return false;\n                    }\n                    // if raw output is enabled, don't print additional newlines,\n                    // but still return True as though you had\n                    if (!this.raw) {\n                        this.__add_outputline();\n                    }\n                    return true;\n                };\n                Output.prototype.get_code = function(eol) {\n                    this.trim(true);\n                    // handle some edge cases where the last tokens\n                    // has text that ends with newline(s)\n                    var last_item = this.current_line.pop();\n                    if (last_item) {\n                        if (last_item[last_item.length - 1] === \"\\n\") {\n                            last_item = last_item.replace(/\\n+$/g, \"\");\n                        }\n                        this.current_line.push(last_item);\n                    }\n                    if (this._end_with_newline) {\n                        this.__add_outputline();\n                    }\n                    var sweet_code = this.__lines.join(\"\\n\");\n                    if (eol !== \"\\n\") {\n                        sweet_code = sweet_code.replace(/[\\n]/g, eol);\n                    }\n                    return sweet_code;\n                };\n                Output.prototype.set_wrap_point = function() {\n                    this.current_line._set_wrap_point();\n                };\n                Output.prototype.set_indent = function(indent, alignment) {\n                    indent = indent || 0;\n                    alignment = alignment || 0;\n                    // Next line stores alignment values\n                    this.next_line.set_indent(indent, alignment);\n                    // Never indent your first output indent at the start of the file\n                    if (this.__lines.length > 1) {\n                        this.current_line.set_indent(indent, alignment);\n                        return true;\n                    }\n                    this.current_line.set_indent();\n                    return false;\n                };\n                Output.prototype.add_raw_token = function(token) {\n                    for(var x = 0; x < token.newlines; x++){\n                        this.__add_outputline();\n                    }\n                    this.current_line.set_indent(-1);\n                    this.current_line.push(token.whitespace_before);\n                    this.current_line.push(token.text);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = false;\n                };\n                Output.prototype.add_token = function(printable_token) {\n                    this.__add_space_before_token();\n                    this.current_line.push(printable_token);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = this.current_line._allow_wrap();\n                };\n                Output.prototype.__add_space_before_token = function() {\n                    if (this.space_before_token && !this.just_added_newline()) {\n                        if (!this.non_breaking_space) {\n                            this.set_wrap_point();\n                        }\n                        this.current_line.push(\" \");\n                    }\n                };\n                Output.prototype.remove_indent = function(index) {\n                    var output_length = this.__lines.length;\n                    while(index < output_length){\n                        this.__lines[index]._remove_indent();\n                        index++;\n                    }\n                    this.current_line._remove_wrap_indent();\n                };\n                Output.prototype.trim = function(eat_newlines) {\n                    eat_newlines = eat_newlines === undefined ? false : eat_newlines;\n                    this.current_line.trim();\n                    while(eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()){\n                        this.__lines.pop();\n                        this.current_line = this.__lines[this.__lines.length - 1];\n                        this.current_line.trim();\n                    }\n                    this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;\n                };\n                Output.prototype.just_added_newline = function() {\n                    return this.current_line.is_empty();\n                };\n                Output.prototype.just_added_blankline = function() {\n                    return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();\n                };\n                Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {\n                    var index = this.__lines.length - 2;\n                    while(index >= 0){\n                        var potentialEmptyLine = this.__lines[index];\n                        if (potentialEmptyLine.is_empty()) {\n                            break;\n                        } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {\n                            this.__lines.splice(index + 1, 0, new OutputLine(this));\n                            this.previous_line = this.__lines[this.__lines.length - 2];\n                            break;\n                        }\n                        index--;\n                    }\n                };\n                module.exports.Output = Output;\n            /***/ },\n            ,\n            ,\n            ,\n            /* 6 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Options(options, merge_child_field) {\n                    this.raw_options = _mergeOpts(options, merge_child_field);\n                    // Support passing the source text back with no change\n                    this.disabled = this._get_boolean(\"disabled\");\n                    this.eol = this._get_characters(\"eol\", \"auto\");\n                    this.end_with_newline = this._get_boolean(\"end_with_newline\");\n                    this.indent_size = this._get_number(\"indent_size\", 4);\n                    this.indent_char = this._get_characters(\"indent_char\", \" \");\n                    this.indent_level = this._get_number(\"indent_level\");\n                    this.preserve_newlines = this._get_boolean(\"preserve_newlines\", true);\n                    this.max_preserve_newlines = this._get_number(\"max_preserve_newlines\", 32786);\n                    if (!this.preserve_newlines) {\n                        this.max_preserve_newlines = 0;\n                    }\n                    this.indent_with_tabs = this._get_boolean(\"indent_with_tabs\", this.indent_char === \"\t\");\n                    if (this.indent_with_tabs) {\n                        this.indent_char = \"\t\";\n                        // indent_size behavior changed after 1.8.6\n                        // It used to be that indent_size would be\n                        // set to 1 for indent_with_tabs. That is no longer needed and\n                        // actually doesn't make sense - why not use spaces? Further,\n                        // that might produce unexpected behavior - tabs being used\n                        // for single-column alignment. So, when indent_with_tabs is true\n                        // and indent_size is 1, reset indent_size to 4.\n                        if (this.indent_size === 1) {\n                            this.indent_size = 4;\n                        }\n                    }\n                    // Backwards compat with 1.3.x\n                    this.wrap_line_length = this._get_number(\"wrap_line_length\", this._get_number(\"max_char\"));\n                    this.indent_empty_lines = this._get_boolean(\"indent_empty_lines\");\n                    // valid templating languages ['django', 'erb', 'handlebars', 'php', 'smarty', 'angular']\n                    // For now, 'auto' = all off for javascript, all except angular on for html (and inline javascript/css).\n                    // other values ignored\n                    this.templating = this._get_selection_list(\"templating\", [\n                        \"auto\",\n                        \"none\",\n                        \"angular\",\n                        \"django\",\n                        \"erb\",\n                        \"handlebars\",\n                        \"php\",\n                        \"smarty\"\n                    ], [\n                        \"auto\"\n                    ]);\n                }\n                Options.prototype._get_array = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = default_value || [];\n                    if (typeof option_value === \"object\") {\n                        if (option_value !== null && typeof option_value.concat === \"function\") {\n                            result = option_value.concat();\n                        }\n                    } else if (typeof option_value === \"string\") {\n                        result = option_value.split(/[^a-zA-Z0-9_\\/\\-]+/);\n                    }\n                    return result;\n                };\n                Options.prototype._get_boolean = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = option_value === undefined ? !!default_value : !!option_value;\n                    return result;\n                };\n                Options.prototype._get_characters = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = default_value || \"\";\n                    if (typeof option_value === \"string\") {\n                        result = option_value.replace(/\\\\r/, \"\\r\").replace(/\\\\n/, \"\\n\").replace(/\\\\t/, \"\t\");\n                    }\n                    return result;\n                };\n                Options.prototype._get_number = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    default_value = parseInt(default_value, 10);\n                    if (isNaN(default_value)) {\n                        default_value = 0;\n                    }\n                    var result = parseInt(option_value, 10);\n                    if (isNaN(result)) {\n                        result = default_value;\n                    }\n                    return result;\n                };\n                Options.prototype._get_selection = function(name, selection_list, default_value) {\n                    var result = this._get_selection_list(name, selection_list, default_value);\n                    if (result.length !== 1) {\n                        throw new Error(\"Invalid Option Value: The option '\" + name + \"' can only be one of the following values:\\n\" + selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n                    }\n                    return result[0];\n                };\n                Options.prototype._get_selection_list = function(name, selection_list, default_value) {\n                    if (!selection_list || selection_list.length === 0) {\n                        throw new Error(\"Selection list cannot be empty.\");\n                    }\n                    default_value = default_value || [\n                        selection_list[0]\n                    ];\n                    if (!this._is_valid_selection(default_value, selection_list)) {\n                        throw new Error(\"Invalid Default Value!\");\n                    }\n                    var result = this._get_array(name, default_value);\n                    if (!this._is_valid_selection(result, selection_list)) {\n                        throw new Error(\"Invalid Option Value: The option '\" + name + \"' can contain only the following values:\\n\" + selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n                    }\n                    return result;\n                };\n                Options.prototype._is_valid_selection = function(result, selection_list) {\n                    return result.length && selection_list.length && !result.some(function(item) {\n                        return selection_list.indexOf(item) === -1;\n                    });\n                };\n                // merges child options up with the parent options object\n                // Example: obj = {a: 1, b: {a: 2}}\n                //          mergeOpts(obj, 'b')\n                //\n                //          Returns: {a: 2}\n                function _mergeOpts(allOptions, childFieldName) {\n                    var finalOpts = {};\n                    allOptions = _normalizeOpts(allOptions);\n                    var name;\n                    for(name in allOptions){\n                        if (name !== childFieldName) {\n                            finalOpts[name] = allOptions[name];\n                        }\n                    }\n                    //merge in the per type settings for the childFieldName\n                    if (childFieldName && allOptions[childFieldName]) {\n                        for(name in allOptions[childFieldName]){\n                            finalOpts[name] = allOptions[childFieldName][name];\n                        }\n                    }\n                    return finalOpts;\n                }\n                function _normalizeOpts(options) {\n                    var convertedOpts = {};\n                    var key;\n                    for(key in options){\n                        var newKey = key.replace(/-/g, \"_\");\n                        convertedOpts[newKey] = options[key];\n                    }\n                    return convertedOpts;\n                }\n                module.exports.Options = Options;\n                module.exports.normalizeOpts = _normalizeOpts;\n                module.exports.mergeOpts = _mergeOpts;\n            /***/ },\n            ,\n            /* 8 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var regexp_has_sticky = RegExp.prototype.hasOwnProperty(\"sticky\");\n                function InputScanner(input_string) {\n                    this.__input = input_string || \"\";\n                    this.__input_length = this.__input.length;\n                    this.__position = 0;\n                }\n                InputScanner.prototype.restart = function() {\n                    this.__position = 0;\n                };\n                InputScanner.prototype.back = function() {\n                    if (this.__position > 0) {\n                        this.__position -= 1;\n                    }\n                };\n                InputScanner.prototype.hasNext = function() {\n                    return this.__position < this.__input_length;\n                };\n                InputScanner.prototype.next = function() {\n                    var val = null;\n                    if (this.hasNext()) {\n                        val = this.__input.charAt(this.__position);\n                        this.__position += 1;\n                    }\n                    return val;\n                };\n                InputScanner.prototype.peek = function(index) {\n                    var val = null;\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__input_length) {\n                        val = this.__input.charAt(index);\n                    }\n                    return val;\n                };\n                // This is a JavaScript only helper function (not in python)\n                // Javascript doesn't have a match method\n                // and not all implementation support \"sticky\" flag.\n                // If they do not support sticky then both this.match() and this.test() method\n                // must get the match and check the index of the match.\n                // If sticky is supported and set, this method will use it.\n                // Otherwise it will check that global is set, and fall back to the slower method.\n                InputScanner.prototype.__match = function(pattern, index) {\n                    pattern.lastIndex = index;\n                    var pattern_match = pattern.exec(this.__input);\n                    if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {\n                        if (pattern_match.index !== index) {\n                            pattern_match = null;\n                        }\n                    }\n                    return pattern_match;\n                };\n                InputScanner.prototype.test = function(pattern, index) {\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__input_length) {\n                        return !!this.__match(pattern, index);\n                    } else {\n                        return false;\n                    }\n                };\n                InputScanner.prototype.testChar = function(pattern, index) {\n                    // test one character regex match\n                    var val = this.peek(index);\n                    pattern.lastIndex = 0;\n                    return val !== null && pattern.test(val);\n                };\n                InputScanner.prototype.match = function(pattern) {\n                    var pattern_match = this.__match(pattern, this.__position);\n                    if (pattern_match) {\n                        this.__position += pattern_match[0].length;\n                    } else {\n                        pattern_match = null;\n                    }\n                    return pattern_match;\n                };\n                InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {\n                    var val = \"\";\n                    var match;\n                    if (starting_pattern) {\n                        match = this.match(starting_pattern);\n                        if (match) {\n                            val += match[0];\n                        }\n                    }\n                    if (until_pattern && (match || !starting_pattern)) {\n                        val += this.readUntil(until_pattern, until_after);\n                    }\n                    return val;\n                };\n                InputScanner.prototype.readUntil = function(pattern, until_after) {\n                    var val = \"\";\n                    var match_index = this.__position;\n                    pattern.lastIndex = this.__position;\n                    var pattern_match = pattern.exec(this.__input);\n                    if (pattern_match) {\n                        match_index = pattern_match.index;\n                        if (until_after) {\n                            match_index += pattern_match[0].length;\n                        }\n                    } else {\n                        match_index = this.__input_length;\n                    }\n                    val = this.__input.substring(this.__position, match_index);\n                    this.__position = match_index;\n                    return val;\n                };\n                InputScanner.prototype.readUntilAfter = function(pattern) {\n                    return this.readUntil(pattern, true);\n                };\n                InputScanner.prototype.get_regexp = function(pattern, match_from) {\n                    var result = null;\n                    var flags = \"g\";\n                    if (match_from && regexp_has_sticky) {\n                        flags = \"y\";\n                    }\n                    // strings are converted to regexp\n                    if (typeof pattern === \"string\" && pattern !== \"\") {\n                        // result = new RegExp(pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'), flags);\n                        result = new RegExp(pattern, flags);\n                    } else if (pattern) {\n                        result = new RegExp(pattern.source, flags);\n                    }\n                    return result;\n                };\n                InputScanner.prototype.get_literal_regexp = function(literal_string) {\n                    return RegExp(literal_string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"));\n                };\n                /* css beautifier legacy helpers */ InputScanner.prototype.peekUntilAfter = function(pattern) {\n                    var start = this.__position;\n                    var val = this.readUntilAfter(pattern);\n                    this.__position = start;\n                    return val;\n                };\n                InputScanner.prototype.lookBack = function(testVal) {\n                    var start = this.__position - 1;\n                    return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;\n                };\n                module.exports.InputScanner = InputScanner;\n            /***/ },\n            ,\n            ,\n            ,\n            ,\n            /* 13 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Directives(start_block_pattern, end_block_pattern) {\n                    start_block_pattern = typeof start_block_pattern === \"string\" ? start_block_pattern : start_block_pattern.source;\n                    end_block_pattern = typeof end_block_pattern === \"string\" ? end_block_pattern : end_block_pattern.source;\n                    this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \\w+[:]\\w+)+ /.source + end_block_pattern, \"g\");\n                    this.__directive_pattern = / (\\w+)[:](\\w+)/g;\n                    this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\\sbeautify\\signore:end\\s/.source + end_block_pattern, \"g\");\n                }\n                Directives.prototype.get_directives = function(text) {\n                    if (!text.match(this.__directives_block_pattern)) {\n                        return null;\n                    }\n                    var directives = {};\n                    this.__directive_pattern.lastIndex = 0;\n                    var directive_match = this.__directive_pattern.exec(text);\n                    while(directive_match){\n                        directives[directive_match[1]] = directive_match[2];\n                        directive_match = this.__directive_pattern.exec(text);\n                    }\n                    return directives;\n                };\n                Directives.prototype.readIgnored = function(input) {\n                    return input.readUntilAfter(this.__directives_end_ignore_pattern);\n                };\n                module.exports.Directives = Directives;\n            /***/ },\n            ,\n            /* 15 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_41648__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Beautifier = __nested_webpack_require_41648__(16).Beautifier, Options = __nested_webpack_require_41648__(17).Options;\n                function css_beautify(source_text, options) {\n                    var beautifier = new Beautifier(source_text, options);\n                    return beautifier.beautify();\n                }\n                module.exports = css_beautify;\n                module.exports.defaultOptions = function() {\n                    return new Options();\n                };\n            /***/ },\n            /* 16 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_43434__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Options = __nested_webpack_require_43434__(17).Options;\n                var Output = __nested_webpack_require_43434__(2).Output;\n                var InputScanner = __nested_webpack_require_43434__(8).InputScanner;\n                var Directives = __nested_webpack_require_43434__(13).Directives;\n                var directives_core = new Directives(/\\/\\*/, /\\*\\//);\n                var lineBreak = /\\r\\n|[\\r\\n]/;\n                var allLineBreaks = /\\r\\n|[\\r\\n]/g;\n                // tokenizer\n                var whitespaceChar = /\\s/;\n                var whitespacePattern = /(?:\\s|\\n)+/g;\n                var block_comment_pattern = /\\/\\*(?:[\\s\\S]*?)((?:\\*\\/)|$)/g;\n                var comment_pattern = /\\/\\/(?:[^\\n\\r\\u2028\\u2029]*)/g;\n                function Beautifier(source_text, options) {\n                    this._source_text = source_text || \"\";\n                    // Allow the setting of language/file-type specific options\n                    // with inheritance of overall settings\n                    this._options = new Options(options);\n                    this._ch = null;\n                    this._input = null;\n                    // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule\n                    this.NESTED_AT_RULE = {\n                        \"page\": true,\n                        \"font-face\": true,\n                        \"keyframes\": true,\n                        // also in CONDITIONAL_GROUP_RULE below\n                        \"media\": true,\n                        \"supports\": true,\n                        \"document\": true\n                    };\n                    this.CONDITIONAL_GROUP_RULE = {\n                        \"media\": true,\n                        \"supports\": true,\n                        \"document\": true\n                    };\n                    this.NON_SEMICOLON_NEWLINE_PROPERTY = [\n                        \"grid-template-areas\",\n                        \"grid-template\"\n                    ];\n                }\n                Beautifier.prototype.eatString = function(endChars) {\n                    var result = \"\";\n                    this._ch = this._input.next();\n                    while(this._ch){\n                        result += this._ch;\n                        if (this._ch === \"\\\\\") {\n                            result += this._input.next();\n                        } else if (endChars.indexOf(this._ch) !== -1 || this._ch === \"\\n\") {\n                            break;\n                        }\n                        this._ch = this._input.next();\n                    }\n                    return result;\n                };\n                // Skips any white space in the source text from the current position.\n                // When allowAtLeastOneNewLine is true, will output new lines for each\n                // newline character found; if the user has preserve_newlines off, only\n                // the first newline will be output\n                Beautifier.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {\n                    var result = whitespaceChar.test(this._input.peek());\n                    var newline_count = 0;\n                    while(whitespaceChar.test(this._input.peek())){\n                        this._ch = this._input.next();\n                        if (allowAtLeastOneNewLine && this._ch === \"\\n\") {\n                            if (newline_count === 0 || newline_count < this._options.max_preserve_newlines) {\n                                newline_count++;\n                                this._output.add_new_line(true);\n                            }\n                        }\n                    }\n                    return result;\n                };\n                // Nested pseudo-class if we are insideRule\n                // and the next special character found opens\n                // a new block\n                Beautifier.prototype.foundNestedPseudoClass = function() {\n                    var openParen = 0;\n                    var i = 1;\n                    var ch = this._input.peek(i);\n                    while(ch){\n                        if (ch === \"{\") {\n                            return true;\n                        } else if (ch === \"(\") {\n                            // pseudoclasses can contain ()\n                            openParen += 1;\n                        } else if (ch === \")\") {\n                            if (openParen === 0) {\n                                return false;\n                            }\n                            openParen -= 1;\n                        } else if (ch === \";\" || ch === \"}\") {\n                            return false;\n                        }\n                        i++;\n                        ch = this._input.peek(i);\n                    }\n                    return false;\n                };\n                Beautifier.prototype.print_string = function(output_string) {\n                    this._output.set_indent(this._indentLevel);\n                    this._output.non_breaking_space = true;\n                    this._output.add_token(output_string);\n                };\n                Beautifier.prototype.preserveSingleSpace = function(isAfterSpace) {\n                    if (isAfterSpace) {\n                        this._output.space_before_token = true;\n                    }\n                };\n                Beautifier.prototype.indent = function() {\n                    this._indentLevel++;\n                };\n                Beautifier.prototype.outdent = function() {\n                    if (this._indentLevel > 0) {\n                        this._indentLevel--;\n                    }\n                };\n                /*_____________________--------------------_____________________*/ Beautifier.prototype.beautify = function() {\n                    if (this._options.disabled) {\n                        return this._source_text;\n                    }\n                    var source_text = this._source_text;\n                    var eol = this._options.eol;\n                    if (eol === \"auto\") {\n                        eol = \"\\n\";\n                        if (source_text && lineBreak.test(source_text || \"\")) {\n                            eol = source_text.match(lineBreak)[0];\n                        }\n                    }\n                    // HACK: newline parsing inconsistent. This brute force normalizes the this._input.\n                    source_text = source_text.replace(allLineBreaks, \"\\n\");\n                    // reset\n                    var baseIndentString = source_text.match(/^[\\t ]*/)[0];\n                    this._output = new Output(this._options, baseIndentString);\n                    this._input = new InputScanner(source_text);\n                    this._indentLevel = 0;\n                    this._nestedLevel = 0;\n                    this._ch = null;\n                    var parenLevel = 0;\n                    var insideRule = false;\n                    // This is the value side of a property value pair (blue in the following ex)\n                    // label { content: blue }\n                    var insidePropertyValue = false;\n                    var enteringConditionalGroup = false;\n                    var insideNonNestedAtRule = false;\n                    var insideScssMap = false;\n                    var topCharacter = this._ch;\n                    var insideNonSemiColonValues = false;\n                    var whitespace;\n                    var isAfterSpace;\n                    var previous_ch;\n                    while(true){\n                        whitespace = this._input.read(whitespacePattern);\n                        isAfterSpace = whitespace !== \"\";\n                        previous_ch = topCharacter;\n                        this._ch = this._input.next();\n                        if (this._ch === \"\\\\\" && this._input.hasNext()) {\n                            this._ch += this._input.next();\n                        }\n                        topCharacter = this._ch;\n                        if (!this._ch) {\n                            break;\n                        } else if (this._ch === \"/\" && this._input.peek() === \"*\") {\n                            // /* css comment */\n                            // Always start block comments on a new line.\n                            // This handles scenarios where a block comment immediately\n                            // follows a property definition on the same line or where\n                            // minified code is being beautified.\n                            this._output.add_new_line();\n                            this._input.back();\n                            var comment = this._input.read(block_comment_pattern);\n                            // Handle ignore directive\n                            var directives = directives_core.get_directives(comment);\n                            if (directives && directives.ignore === \"start\") {\n                                comment += directives_core.readIgnored(this._input);\n                            }\n                            this.print_string(comment);\n                            // Ensures any new lines following the comment are preserved\n                            this.eatWhitespace(true);\n                            // Block comments are followed by a new line so they don't\n                            // share a line with other properties\n                            this._output.add_new_line();\n                        } else if (this._ch === \"/\" && this._input.peek() === \"/\") {\n                            // // single line comment\n                            // Preserves the space before a comment\n                            // on the same line as a rule\n                            this._output.space_before_token = true;\n                            this._input.back();\n                            this.print_string(this._input.read(comment_pattern));\n                            // Ensures any new lines following the comment are preserved\n                            this.eatWhitespace(true);\n                        } else if (this._ch === \"$\") {\n                            this.preserveSingleSpace(isAfterSpace);\n                            this.print_string(this._ch);\n                            // strip trailing space, if present, for hash property checks\n                            var variable = this._input.peekUntilAfter(/[: ,;{}()[\\]\\/='\"]/g);\n                            if (variable.match(/[ :]$/)) {\n                                // we have a variable or pseudo-class, add it and insert one space before continuing\n                                variable = this.eatString(\": \").replace(/\\s+$/, \"\");\n                                this.print_string(variable);\n                                this._output.space_before_token = true;\n                            }\n                            // might be sass variable\n                            if (parenLevel === 0 && variable.indexOf(\":\") !== -1) {\n                                insidePropertyValue = true;\n                                this.indent();\n                            }\n                        } else if (this._ch === \"@\") {\n                            this.preserveSingleSpace(isAfterSpace);\n                            // deal with less property mixins @{...}\n                            if (this._input.peek() === \"{\") {\n                                this.print_string(this._ch + this.eatString(\"}\"));\n                            } else {\n                                this.print_string(this._ch);\n                                // strip trailing space, if present, for hash property checks\n                                var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\\]\\/='\"]/g);\n                                if (variableOrRule.match(/[ :]$/)) {\n                                    // we have a variable or pseudo-class, add it and insert one space before continuing\n                                    variableOrRule = this.eatString(\": \").replace(/\\s+$/, \"\");\n                                    this.print_string(variableOrRule);\n                                    this._output.space_before_token = true;\n                                }\n                                // might be less variable\n                                if (parenLevel === 0 && variableOrRule.indexOf(\":\") !== -1) {\n                                    insidePropertyValue = true;\n                                    this.indent();\n                                // might be a nesting at-rule\n                                } else if (variableOrRule in this.NESTED_AT_RULE) {\n                                    this._nestedLevel += 1;\n                                    if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {\n                                        enteringConditionalGroup = true;\n                                    }\n                                // might be a non-nested at-rule\n                                } else if (parenLevel === 0 && !insidePropertyValue) {\n                                    insideNonNestedAtRule = true;\n                                }\n                            }\n                        } else if (this._ch === \"#\" && this._input.peek() === \"{\") {\n                            this.preserveSingleSpace(isAfterSpace);\n                            this.print_string(this._ch + this.eatString(\"}\"));\n                        } else if (this._ch === \"{\") {\n                            if (insidePropertyValue) {\n                                insidePropertyValue = false;\n                                this.outdent();\n                            }\n                            // non nested at rule becomes nested\n                            insideNonNestedAtRule = false;\n                            // when entering conditional groups, only rulesets are allowed\n                            if (enteringConditionalGroup) {\n                                enteringConditionalGroup = false;\n                                insideRule = this._indentLevel >= this._nestedLevel;\n                            } else {\n                                // otherwise, declarations are also allowed\n                                insideRule = this._indentLevel >= this._nestedLevel - 1;\n                            }\n                            if (this._options.newline_between_rules && insideRule) {\n                                if (this._output.previous_line && this._output.previous_line.item(-1) !== \"{\") {\n                                    this._output.ensure_empty_line_above(\"/\", \",\");\n                                }\n                            }\n                            this._output.space_before_token = true;\n                            // The difference in print_string and indent order is necessary to indent the '{' correctly\n                            if (this._options.brace_style === \"expand\") {\n                                this._output.add_new_line();\n                                this.print_string(this._ch);\n                                this.indent();\n                                this._output.set_indent(this._indentLevel);\n                            } else {\n                                // inside mixin and first param is object\n                                if (previous_ch === \"(\") {\n                                    this._output.space_before_token = false;\n                                } else if (previous_ch !== \",\") {\n                                    this.indent();\n                                }\n                                this.print_string(this._ch);\n                            }\n                            this.eatWhitespace(true);\n                            this._output.add_new_line();\n                        } else if (this._ch === \"}\") {\n                            this.outdent();\n                            this._output.add_new_line();\n                            if (previous_ch === \"{\") {\n                                this._output.trim(true);\n                            }\n                            if (insidePropertyValue) {\n                                this.outdent();\n                                insidePropertyValue = false;\n                            }\n                            this.print_string(this._ch);\n                            insideRule = false;\n                            if (this._nestedLevel) {\n                                this._nestedLevel--;\n                            }\n                            this.eatWhitespace(true);\n                            this._output.add_new_line();\n                            if (this._options.newline_between_rules && !this._output.just_added_blankline()) {\n                                if (this._input.peek() !== \"}\") {\n                                    this._output.add_new_line(true);\n                                }\n                            }\n                            if (this._input.peek() === \")\") {\n                                this._output.trim(true);\n                                if (this._options.brace_style === \"expand\") {\n                                    this._output.add_new_line(true);\n                                }\n                            }\n                        } else if (this._ch === \":\") {\n                            for(var i = 0; i < this.NON_SEMICOLON_NEWLINE_PROPERTY.length; i++){\n                                if (this._input.lookBack(this.NON_SEMICOLON_NEWLINE_PROPERTY[i])) {\n                                    insideNonSemiColonValues = true;\n                                    break;\n                                }\n                            }\n                            if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack(\"&\") || this.foundNestedPseudoClass()) && !this._input.lookBack(\"(\") && !insideNonNestedAtRule && parenLevel === 0) {\n                                // 'property: value' delimiter\n                                // which could be in a conditional group query\n                                this.print_string(\":\");\n                                if (!insidePropertyValue) {\n                                    insidePropertyValue = true;\n                                    this._output.space_before_token = true;\n                                    this.eatWhitespace(true);\n                                    this.indent();\n                                }\n                            } else {\n                                // sass/less parent reference don't use a space\n                                // sass nested pseudo-class don't use a space\n                                // preserve space before pseudoclasses/pseudoelements, as it means \"in any child\"\n                                if (this._input.lookBack(\" \")) {\n                                    this._output.space_before_token = true;\n                                }\n                                if (this._input.peek() === \":\") {\n                                    // pseudo-element\n                                    this._ch = this._input.next();\n                                    this.print_string(\"::\");\n                                } else {\n                                    // pseudo-class\n                                    this.print_string(\":\");\n                                }\n                            }\n                        } else if (this._ch === '\"' || this._ch === \"'\") {\n                            var preserveQuoteSpace = previous_ch === '\"' || previous_ch === \"'\";\n                            this.preserveSingleSpace(preserveQuoteSpace || isAfterSpace);\n                            this.print_string(this._ch + this.eatString(this._ch));\n                            this.eatWhitespace(true);\n                        } else if (this._ch === \";\") {\n                            insideNonSemiColonValues = false;\n                            if (parenLevel === 0) {\n                                if (insidePropertyValue) {\n                                    this.outdent();\n                                    insidePropertyValue = false;\n                                }\n                                insideNonNestedAtRule = false;\n                                this.print_string(this._ch);\n                                this.eatWhitespace(true);\n                                // This maintains single line comments on the same\n                                // line. Block comments are also affected, but\n                                // a new line is always output before one inside\n                                // that section\n                                if (this._input.peek() !== \"/\") {\n                                    this._output.add_new_line();\n                                }\n                            } else {\n                                this.print_string(this._ch);\n                                this.eatWhitespace(true);\n                                this._output.space_before_token = true;\n                            }\n                        } else if (this._ch === \"(\") {\n                            if (this._input.lookBack(\"url\")) {\n                                this.print_string(this._ch);\n                                this.eatWhitespace();\n                                parenLevel++;\n                                this.indent();\n                                this._ch = this._input.next();\n                                if (this._ch === \")\" || this._ch === '\"' || this._ch === \"'\") {\n                                    this._input.back();\n                                } else if (this._ch) {\n                                    this.print_string(this._ch + this.eatString(\")\"));\n                                    if (parenLevel) {\n                                        parenLevel--;\n                                        this.outdent();\n                                    }\n                                }\n                            } else {\n                                var space_needed = false;\n                                if (this._input.lookBack(\"with\")) {\n                                    // look back is not an accurate solution, we need tokens to confirm without whitespaces\n                                    space_needed = true;\n                                }\n                                this.preserveSingleSpace(isAfterSpace || space_needed);\n                                this.print_string(this._ch);\n                                // handle scss/sass map\n                                if (insidePropertyValue && previous_ch === \"$\" && this._options.selector_separator_newline) {\n                                    this._output.add_new_line();\n                                    insideScssMap = true;\n                                } else {\n                                    this.eatWhitespace();\n                                    parenLevel++;\n                                    this.indent();\n                                }\n                            }\n                        } else if (this._ch === \")\") {\n                            if (parenLevel) {\n                                parenLevel--;\n                                this.outdent();\n                            }\n                            if (insideScssMap && this._input.peek() === \";\" && this._options.selector_separator_newline) {\n                                insideScssMap = false;\n                                this.outdent();\n                                this._output.add_new_line();\n                            }\n                            this.print_string(this._ch);\n                        } else if (this._ch === \",\") {\n                            this.print_string(this._ch);\n                            this.eatWhitespace(true);\n                            if (this._options.selector_separator_newline && (!insidePropertyValue || insideScssMap) && parenLevel === 0 && !insideNonNestedAtRule) {\n                                this._output.add_new_line();\n                            } else {\n                                this._output.space_before_token = true;\n                            }\n                        } else if ((this._ch === \">\" || this._ch === \"+\" || this._ch === \"~\") && !insidePropertyValue && parenLevel === 0) {\n                            //handle combinator spacing\n                            if (this._options.space_around_combinator) {\n                                this._output.space_before_token = true;\n                                this.print_string(this._ch);\n                                this._output.space_before_token = true;\n                            } else {\n                                this.print_string(this._ch);\n                                this.eatWhitespace();\n                                // squash extra whitespace\n                                if (this._ch && whitespaceChar.test(this._ch)) {\n                                    this._ch = \"\";\n                                }\n                            }\n                        } else if (this._ch === \"]\") {\n                            this.print_string(this._ch);\n                        } else if (this._ch === \"[\") {\n                            this.preserveSingleSpace(isAfterSpace);\n                            this.print_string(this._ch);\n                        } else if (this._ch === \"=\") {\n                            this.eatWhitespace();\n                            this.print_string(\"=\");\n                            if (whitespaceChar.test(this._ch)) {\n                                this._ch = \"\";\n                            }\n                        } else if (this._ch === \"!\" && !this._input.lookBack(\"\\\\\")) {\n                            this._output.space_before_token = true;\n                            this.print_string(this._ch);\n                        } else {\n                            var preserveAfterSpace = previous_ch === '\"' || previous_ch === \"'\";\n                            this.preserveSingleSpace(preserveAfterSpace || isAfterSpace);\n                            this.print_string(this._ch);\n                            if (!this._output.just_added_newline() && this._input.peek() === \"\\n\" && insideNonSemiColonValues) {\n                                this._output.add_new_line();\n                            }\n                        }\n                    }\n                    var sweetCode = this._output.get_code(eol);\n                    return sweetCode;\n                };\n                module.exports.Beautifier = Beautifier;\n            /***/ },\n            /* 17 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_71269__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var BaseOptions = __nested_webpack_require_71269__(6).Options;\n                function Options(options) {\n                    BaseOptions.call(this, options, \"css\");\n                    this.selector_separator_newline = this._get_boolean(\"selector_separator_newline\", true);\n                    this.newline_between_rules = this._get_boolean(\"newline_between_rules\", true);\n                    var space_around_selector_separator = this._get_boolean(\"space_around_selector_separator\");\n                    this.space_around_combinator = this._get_boolean(\"space_around_combinator\") || space_around_selector_separator;\n                    var brace_style_split = this._get_selection_list(\"brace_style\", [\n                        \"collapse\",\n                        \"expand\",\n                        \"end-expand\",\n                        \"none\",\n                        \"preserve-inline\"\n                    ]);\n                    this.brace_style = \"collapse\";\n                    for(var bs = 0; bs < brace_style_split.length; bs++){\n                        if (brace_style_split[bs] !== \"expand\") {\n                            // default to collapse, as only collapse|expand is implemented for now\n                            this.brace_style = \"collapse\";\n                        } else {\n                            this.brace_style = brace_style_split[bs];\n                        }\n                    }\n                }\n                Options.prototype = new BaseOptions();\n                module.exports.Options = Options;\n            /***/ }\n        ];\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_74277__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_74277__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /******/ // startup\n        /******/ // Load entry module and return exports\n        /******/ // This entry module is referenced by other modules so it can't be inlined\n        /******/ var __nested_webpack_exports__ = __nested_webpack_require_74277__(15);\n        /******/ legacy_beautify_css = __nested_webpack_exports__;\n    /******/ /******/ })();\n    var css_beautify = legacy_beautify_css;\n    /* Footer */ if (true) {\n        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return {\n                css_beautify: css_beautify\n            };\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvbGliL2JlYXV0aWZ5LWNzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsa0NBQWtDLEdBQ2xDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMERBLEdBRUEsdURBQXVEO0FBQ3ZELG9DQUFvQztBQUVuQztJQUVELDBCQUEwQixHQUMxQixJQUFJQTtJQUNKLE1BQU0sR0FBSTtRQUNWLE1BQU0sR0FBSTtRQUNWLE1BQU0sR0FBSSxJQUFJQyxzQkFBdUI7OztZQUdyQyxLQUFLLEdBQ0wsR0FBRyxHQUFJLFNBQVNDLE1BQU07Z0JBRXRCLG1CQUFtQixHQUNuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBLEdBSUEsU0FBU0MsV0FBV0MsTUFBTTtvQkFDeEIsSUFBSSxDQUFDQyxRQUFRLEdBQUdEO29CQUNoQixJQUFJLENBQUNFLGlCQUFpQixHQUFHO29CQUN6QixnRkFBZ0Y7b0JBQ2hGLElBQUksQ0FBQ0MsY0FBYyxHQUFHLENBQUM7b0JBQ3ZCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7b0JBQ3pCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUc7b0JBQzFCLElBQUksQ0FBQ0MsNEJBQTRCLEdBQUc7b0JBQ3BDLElBQUksQ0FBQ0MseUJBQXlCLEdBQUcsQ0FBQztvQkFDbEMsSUFBSSxDQUFDQyw0QkFBNEIsR0FBRztvQkFFcEMsSUFBSSxDQUFDQyxPQUFPLEdBQUcsRUFBRTtnQkFDbkI7Z0JBRUFWLFdBQVdXLFNBQVMsQ0FBQ0MsV0FBVyxHQUFHO29CQUNqQyxJQUFJQyxPQUFPLElBQUliLFdBQVcsSUFBSSxDQUFDRSxRQUFRO29CQUN2Q1csS0FBS0MsVUFBVSxDQUFDLElBQUksQ0FBQ1YsY0FBYyxFQUFFLElBQUksQ0FBQ0MsaUJBQWlCO29CQUMzRCxPQUFPUTtnQkFDVDtnQkFFQWIsV0FBV1csU0FBUyxDQUFDSSxJQUFJLEdBQUcsU0FBU0MsS0FB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LE1BQU0sR0FBSTtRQUNWLE1BQU0sR0FDTix3RUFBd0UsR0FDeEUsTUFBTSxHQUNOLE1BQU0sR0FBSSxVQUFVO1FBQ3BCLE1BQU0sR0FBSSx1Q0FBdUM7UUFDakQsTUFBTSxHQUFJLDBFQUEwRTtRQUNwRixNQUFNLEdBQUksSUFBSTJKLDBCQUFtQkEsR0FBR3BFLGdDQUFtQkEsQ0FBQztRQUN4RCxNQUFNLEdBQUlwTSxzQkFBc0J3USwwQkFBbUJBO0lBQ25ELE1BQU0sR0FDTixNQUFNLEdBQUc7SUFFVCxJQUFJbEUsZUFBZXRNO0lBQ25CLFVBQVUsR0FDVixJQUFJLElBQTBDLEVBQUU7UUFDNUMsMEZBQTBGO1FBQzFGeVEsaUNBQU8sRUFBRSxtQ0FBRTtZQUNQLE9BQU87Z0JBQ0huRSxjQUFjQTtZQUNsQjtRQUNKLENBQUM7QUFBQSxrR0FBQztJQUNOLE9BQU8sRUFVTjtBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL2xpYi9iZWF1dGlmeS1jc3MuanM/YzQzZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBBVVRPLUdFTkVSQVRFRC4gRE8gTk9UIE1PRElGWS4gKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuXG5cbiBDU1MgQmVhdXRpZmllclxuLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBXcml0dGVuIGJ5IEhhcnV0eXVuIEFtaXJqYW55YW4sIChhbWlyamFueWFuQGdtYWlsLmNvbSlcblxuICAgIEJhc2VkIG9uIGNvZGUgaW5pdGlhbGx5IGRldmVsb3BlZCBieTogRWluYXIgTGllbG1hbmlzLCA8ZWluYXJAYmVhdXRpZmllci5pbz5cbiAgICAgICAgaHR0cHM6Ly9iZWF1dGlmaWVyLmlvL1xuXG4gICAgVXNhZ2U6XG4gICAgICAgIGNzc19iZWF1dGlmeShzb3VyY2VfdGV4dCk7XG4gICAgICAgIGNzc19iZWF1dGlmeShzb3VyY2VfdGV4dCwgb3B0aW9ucyk7XG5cbiAgICBUaGUgb3B0aW9ucyBhcmUgKGRlZmF1bHQgaW4gYnJhY2tldHMpOlxuICAgICAgICBpbmRlbnRfc2l6ZSAoNCkgICAgICAgICAgICAgICAgICAgICAgICAg4oCUIGluZGVudGF0aW9uIHNpemUsXG4gICAgICAgIGluZGVudF9jaGFyIChzcGFjZSkgICAgICAgICAgICAgICAgICAgICDigJQgY2hhcmFjdGVyIHRvIGluZGVudCB3aXRoLFxuICAgICAgICBzZWxlY3Rvcl9zZXBhcmF0b3JfbmV3bGluZSAodHJ1ZSkgICAgICAgLSBzZXBhcmF0ZSBzZWxlY3RvcnMgd2l0aCBuZXdsaW5lIG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCAoZS5nLiBcImEsXFxuYnJcIiBvciBcImEsIGJyXCIpXG4gICAgICAgIGVuZF93aXRoX25ld2xpbmUgKGZhbHNlKSAgICAgICAgICAgICAgICAtIGVuZCB3aXRoIGEgbmV3bGluZVxuICAgICAgICBuZXdsaW5lX2JldHdlZW5fcnVsZXMgKHRydWUpICAgICAgICAgICAgLSBhZGQgYSBuZXcgbGluZSBhZnRlciBldmVyeSBjc3MgcnVsZVxuICAgICAgICBzcGFjZV9hcm91bmRfc2VsZWN0b3Jfc2VwYXJhdG9yIChmYWxzZSkgLSBlbnN1cmUgc3BhY2UgYXJvdW5kIHNlbGVjdG9yIHNlcGFyYXRvcnM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc+JywgJysnLCAnficgKGUuZy4gXCJhPmJcIiAtPiBcImEgPiBiXCIpXG4gICAgZS5nXG5cbiAgICBjc3NfYmVhdXRpZnkoY3NzX3NvdXJjZV90ZXh0LCB7XG4gICAgICAnaW5kZW50X3NpemUnOiAxLFxuICAgICAgJ2luZGVudF9jaGFyJzogJ1xcdCcsXG4gICAgICAnc2VsZWN0b3Jfc2VwYXJhdG9yJzogJyAnLFxuICAgICAgJ2VuZF93aXRoX25ld2xpbmUnOiBmYWxzZSxcbiAgICAgICduZXdsaW5lX2JldHdlZW5fcnVsZXMnOiB0cnVlLFxuICAgICAgJ3NwYWNlX2Fyb3VuZF9zZWxlY3Rvcl9zZXBhcmF0b3InOiB0cnVlXG4gICAgfSk7XG4qL1xuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdG9rZW5pemF0aW9uXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXN5bnRheC9cblxuKGZ1bmN0aW9uKCkge1xuXG4vKiBHRU5FUkFURURfQlVJTERfT1VUUFVUICovXG52YXIgbGVnYWN5X2JlYXV0aWZ5X2Nzcztcbi8qKioqKiovIChmdW5jdGlvbigpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoW1xuLyogMCAqLyxcbi8qIDEgKi8sXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIE91dHB1dExpbmUocGFyZW50KSB7XG4gIHRoaXMuX19wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPSAwO1xuICAvLyB1c2UgaW5kZW50X2NvdW50IGFzIGEgbWFya2VyIGZvciB0aGlzLl9fbGluZXMgdGhhdCBoYXZlIHByZXNlcnZlZCBpbmRlbnRhdGlvblxuICB0aGlzLl9faW5kZW50X2NvdW50ID0gLTE7XG4gIHRoaXMuX19hbGlnbm1lbnRfY291bnQgPSAwO1xuICB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCA9IDA7XG4gIHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudCA9IDA7XG4gIHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCA9IC0xO1xuICB0aGlzLl9fd3JhcF9wb2ludF9hbGlnbm1lbnRfY291bnQgPSAwO1xuXG4gIHRoaXMuX19pdGVtcyA9IFtdO1xufVxuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5jbG9uZV9lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGluZSA9IG5ldyBPdXRwdXRMaW5lKHRoaXMuX19wYXJlbnQpO1xuICBsaW5lLnNldF9pbmRlbnQodGhpcy5fX2luZGVudF9jb3VudCwgdGhpcy5fX2FsaWdubWVudF9jb3VudCk7XG4gIHJldHVybiBsaW5lO1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuaXRlbSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZW1zW3RoaXMuX19pdGVtcy5sZW5ndGggKyBpbmRleF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuX19pdGVtc1tpbmRleF07XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmhhc19tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgZm9yICh2YXIgbGFzdENoZWNrZWRPdXRwdXQgPSB0aGlzLl9faXRlbXMubGVuZ3RoIC0gMTsgbGFzdENoZWNrZWRPdXRwdXQgPj0gMDsgbGFzdENoZWNrZWRPdXRwdXQtLSkge1xuICAgIGlmICh0aGlzLl9faXRlbXNbbGFzdENoZWNrZWRPdXRwdXRdLm1hdGNoKHBhdHRlcm4pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuc2V0X2luZGVudCA9IGZ1bmN0aW9uKGluZGVudCwgYWxpZ25tZW50KSB7XG4gIGlmICh0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICB0aGlzLl9faW5kZW50X2NvdW50ID0gaW5kZW50IHx8IDA7XG4gICAgdGhpcy5fX2FsaWdubWVudF9jb3VudCA9IGFsaWdubWVudCB8fCAwO1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPSB0aGlzLl9fcGFyZW50LmdldF9pbmRlbnRfc2l6ZSh0aGlzLl9faW5kZW50X2NvdW50LCB0aGlzLl9fYWxpZ25tZW50X2NvdW50KTtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX3NldF93cmFwX3BvaW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9fcGFyZW50LndyYXBfbGluZV9sZW5ndGgpIHtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCA9IHRoaXMuX19pdGVtcy5sZW5ndGg7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50ID0gdGhpcy5fX2NoYXJhY3Rlcl9jb3VudDtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQgPSB0aGlzLl9fcGFyZW50Lm5leHRfbGluZS5fX2luZGVudF9jb3VudDtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9hbGlnbm1lbnRfY291bnQgPSB0aGlzLl9fcGFyZW50Lm5leHRfbGluZS5fX2FsaWdubWVudF9jb3VudDtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX3Nob3VsZF93cmFwID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCAmJlxuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPiB0aGlzLl9fcGFyZW50LndyYXBfbGluZV9sZW5ndGggJiZcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQgPiB0aGlzLl9fcGFyZW50Lm5leHRfbGluZS5fX2NoYXJhY3Rlcl9jb3VudDtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9hbGxvd193cmFwID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9zaG91bGRfd3JhcCgpKSB7XG4gICAgdGhpcy5fX3BhcmVudC5hZGRfbmV3X2xpbmUoKTtcbiAgICB2YXIgbmV4dCA9IHRoaXMuX19wYXJlbnQuY3VycmVudF9saW5lO1xuICAgIG5leHQuc2V0X2luZGVudCh0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQsIHRoaXMuX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCk7XG4gICAgbmV4dC5fX2l0ZW1zID0gdGhpcy5fX2l0ZW1zLnNsaWNlKHRoaXMuX193cmFwX3BvaW50X2luZGV4KTtcbiAgICB0aGlzLl9faXRlbXMgPSB0aGlzLl9faXRlbXMuc2xpY2UoMCwgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZXgpO1xuXG4gICAgbmV4dC5fX2NoYXJhY3Rlcl9jb3VudCArPSB0aGlzLl9fY2hhcmFjdGVyX2NvdW50IC0gdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50O1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPSB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQ7XG5cbiAgICBpZiAobmV4dC5fX2l0ZW1zWzBdID09PSBcIiBcIikge1xuICAgICAgbmV4dC5fX2l0ZW1zLnNwbGljZSgwLCAxKTtcbiAgICAgIG5leHQuX19jaGFyYWN0ZXJfY291bnQgLT0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuaXNfZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19pdGVtcy5sZW5ndGggPT09IDA7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5pc19lbXB0eSgpKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pdGVtc1t0aGlzLl9faXRlbXMubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihpdGVtKSB7XG4gIHRoaXMuX19pdGVtcy5wdXNoKGl0ZW0pO1xuICB2YXIgbGFzdF9uZXdsaW5lX2luZGV4ID0gaXRlbS5sYXN0SW5kZXhPZignXFxuJyk7XG4gIGlmIChsYXN0X25ld2xpbmVfaW5kZXggIT09IC0xKSB7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IGl0ZW0ubGVuZ3RoIC0gbGFzdF9uZXdsaW5lX2luZGV4O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgKz0gaXRlbS5sZW5ndGg7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbSA9IG51bGw7XG4gIGlmICghdGhpcy5pc19lbXB0eSgpKSB7XG4gICAgaXRlbSA9IHRoaXMuX19pdGVtcy5wb3AoKTtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50IC09IGl0ZW0ubGVuZ3RoO1xuICB9XG4gIHJldHVybiBpdGVtO1xufTtcblxuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fcmVtb3ZlX2luZGVudCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fX2luZGVudF9jb3VudCA+IDApIHtcbiAgICB0aGlzLl9faW5kZW50X2NvdW50IC09IDE7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCAtPSB0aGlzLl9fcGFyZW50LmluZGVudF9zaXplO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fcmVtb3ZlX3dyYXBfaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQgPiAwKSB7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50IC09IDE7XG4gIH1cbn07XG5PdXRwdXRMaW5lLnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24oKSB7XG4gIHdoaWxlICh0aGlzLmxhc3QoKSA9PT0gJyAnKSB7XG4gICAgdGhpcy5fX2l0ZW1zLnBvcCgpO1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLT0gMTtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhpcy5pc19lbXB0eSgpKSB7XG4gICAgaWYgKHRoaXMuX19wYXJlbnQuaW5kZW50X2VtcHR5X2xpbmVzKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLl9fcGFyZW50LmdldF9pbmRlbnRfc3RyaW5nKHRoaXMuX19pbmRlbnRfY291bnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB0aGlzLl9fcGFyZW50LmdldF9pbmRlbnRfc3RyaW5nKHRoaXMuX19pbmRlbnRfY291bnQsIHRoaXMuX19hbGlnbm1lbnRfY291bnQpO1xuICAgIHJlc3VsdCArPSB0aGlzLl9faXRlbXMuam9pbignJyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIEluZGVudFN0cmluZ0NhY2hlKG9wdGlvbnMsIGJhc2VJbmRlbnRTdHJpbmcpIHtcbiAgdGhpcy5fX2NhY2hlID0gWycnXTtcbiAgdGhpcy5fX2luZGVudF9zaXplID0gb3B0aW9ucy5pbmRlbnRfc2l6ZTtcbiAgdGhpcy5fX2luZGVudF9zdHJpbmcgPSBvcHRpb25zLmluZGVudF9jaGFyO1xuICBpZiAoIW9wdGlvbnMuaW5kZW50X3dpdGhfdGFicykge1xuICAgIHRoaXMuX19pbmRlbnRfc3RyaW5nID0gbmV3IEFycmF5KG9wdGlvbnMuaW5kZW50X3NpemUgKyAxKS5qb2luKG9wdGlvbnMuaW5kZW50X2NoYXIpO1xuICB9XG5cbiAgLy8gU2V0IHRvIG51bGwgdG8gY29udGludWUgc3VwcG9ydCBmb3IgYXV0byBkZXRlY3Rpb24gb2YgYmFzZSBpbmRlbnRcbiAgYmFzZUluZGVudFN0cmluZyA9IGJhc2VJbmRlbnRTdHJpbmcgfHwgJyc7XG4gIGlmIChvcHRpb25zLmluZGVudF9sZXZlbCA+IDApIHtcbiAgICBiYXNlSW5kZW50U3RyaW5nID0gbmV3IEFycmF5KG9wdGlvbnMuaW5kZW50X2xldmVsICsgMSkuam9pbih0aGlzLl9faW5kZW50X3N0cmluZyk7XG4gIH1cblxuICB0aGlzLl9fYmFzZV9zdHJpbmcgPSBiYXNlSW5kZW50U3RyaW5nO1xuICB0aGlzLl9fYmFzZV9zdHJpbmdfbGVuZ3RoID0gYmFzZUluZGVudFN0cmluZy5sZW5ndGg7XG59XG5cbkluZGVudFN0cmluZ0NhY2hlLnByb3RvdHlwZS5nZXRfaW5kZW50X3NpemUgPSBmdW5jdGlvbihpbmRlbnQsIGNvbHVtbikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fX2Jhc2Vfc3RyaW5nX2xlbmd0aDtcbiAgY29sdW1uID0gY29sdW1uIHx8IDA7XG4gIGlmIChpbmRlbnQgPCAwKSB7XG4gICAgcmVzdWx0ID0gMDtcbiAgfVxuICByZXN1bHQgKz0gaW5kZW50ICogdGhpcy5fX2luZGVudF9zaXplO1xuICByZXN1bHQgKz0gY29sdW1uO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLmdldF9pbmRlbnRfc3RyaW5nID0gZnVuY3Rpb24oaW5kZW50X2xldmVsLCBjb2x1bW4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX19iYXNlX3N0cmluZztcbiAgY29sdW1uID0gY29sdW1uIHx8IDA7XG4gIGlmIChpbmRlbnRfbGV2ZWwgPCAwKSB7XG4gICAgaW5kZW50X2xldmVsID0gMDtcbiAgICByZXN1bHQgPSAnJztcbiAgfVxuICBjb2x1bW4gKz0gaW5kZW50X2xldmVsICogdGhpcy5fX2luZGVudF9zaXplO1xuICB0aGlzLl9fZW5zdXJlX2NhY2hlKGNvbHVtbik7XG4gIHJlc3VsdCArPSB0aGlzLl9fY2FjaGVbY29sdW1uXTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkluZGVudFN0cmluZ0NhY2hlLnByb3RvdHlwZS5fX2Vuc3VyZV9jYWNoZSA9IGZ1bmN0aW9uKGNvbHVtbikge1xuICB3aGlsZSAoY29sdW1uID49IHRoaXMuX19jYWNoZS5sZW5ndGgpIHtcbiAgICB0aGlzLl9fYWRkX2NvbHVtbigpO1xuICB9XG59O1xuXG5JbmRlbnRTdHJpbmdDYWNoZS5wcm90b3R5cGUuX19hZGRfY29sdW1uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb2x1bW4gPSB0aGlzLl9fY2FjaGUubGVuZ3RoO1xuICB2YXIgaW5kZW50ID0gMDtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhpcy5fX2luZGVudF9zaXplICYmIGNvbHVtbiA+PSB0aGlzLl9faW5kZW50X3NpemUpIHtcbiAgICBpbmRlbnQgPSBNYXRoLmZsb29yKGNvbHVtbiAvIHRoaXMuX19pbmRlbnRfc2l6ZSk7XG4gICAgY29sdW1uIC09IGluZGVudCAqIHRoaXMuX19pbmRlbnRfc2l6ZTtcbiAgICByZXN1bHQgPSBuZXcgQXJyYXkoaW5kZW50ICsgMSkuam9pbih0aGlzLl9faW5kZW50X3N0cmluZyk7XG4gIH1cbiAgaWYgKGNvbHVtbikge1xuICAgIHJlc3VsdCArPSBuZXcgQXJyYXkoY29sdW1uICsgMSkuam9pbignICcpO1xuICB9XG5cbiAgdGhpcy5fX2NhY2hlLnB1c2gocmVzdWx0KTtcbn07XG5cbmZ1bmN0aW9uIE91dHB1dChvcHRpb25zLCBiYXNlSW5kZW50U3RyaW5nKSB7XG4gIHRoaXMuX19pbmRlbnRfY2FjaGUgPSBuZXcgSW5kZW50U3RyaW5nQ2FjaGUob3B0aW9ucywgYmFzZUluZGVudFN0cmluZyk7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuX2VuZF93aXRoX25ld2xpbmUgPSBvcHRpb25zLmVuZF93aXRoX25ld2xpbmU7XG4gIHRoaXMuaW5kZW50X3NpemUgPSBvcHRpb25zLmluZGVudF9zaXplO1xuICB0aGlzLndyYXBfbGluZV9sZW5ndGggPSBvcHRpb25zLndyYXBfbGluZV9sZW5ndGg7XG4gIHRoaXMuaW5kZW50X2VtcHR5X2xpbmVzID0gb3B0aW9ucy5pbmRlbnRfZW1wdHlfbGluZXM7XG4gIHRoaXMuX19saW5lcyA9IFtdO1xuICB0aGlzLnByZXZpb3VzX2xpbmUgPSBudWxsO1xuICB0aGlzLmN1cnJlbnRfbGluZSA9IG51bGw7XG4gIHRoaXMubmV4dF9saW5lID0gbmV3IE91dHB1dExpbmUodGhpcyk7XG4gIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gIHRoaXMubm9uX2JyZWFraW5nX3NwYWNlID0gZmFsc2U7XG4gIHRoaXMucHJldmlvdXNfdG9rZW5fd3JhcHBlZCA9IGZhbHNlO1xuICAvLyBpbml0aWFsaXplXG4gIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xufVxuXG5PdXRwdXQucHJvdG90eXBlLl9fYWRkX291dHB1dGxpbmUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wcmV2aW91c19saW5lID0gdGhpcy5jdXJyZW50X2xpbmU7XG4gIHRoaXMuY3VycmVudF9saW5lID0gdGhpcy5uZXh0X2xpbmUuY2xvbmVfZW1wdHkoKTtcbiAgdGhpcy5fX2xpbmVzLnB1c2godGhpcy5jdXJyZW50X2xpbmUpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5nZXRfbGluZV9udW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19saW5lcy5sZW5ndGg7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9pbmRlbnRfc3RyaW5nID0gZnVuY3Rpb24oaW5kZW50LCBjb2x1bW4pIHtcbiAgcmV0dXJuIHRoaXMuX19pbmRlbnRfY2FjaGUuZ2V0X2luZGVudF9zdHJpbmcoaW5kZW50LCBjb2x1bW4pO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5nZXRfaW5kZW50X3NpemUgPSBmdW5jdGlvbihpbmRlbnQsIGNvbHVtbikge1xuICByZXR1cm4gdGhpcy5fX2luZGVudF9jYWNoZS5nZXRfaW5kZW50X3NpemUoaW5kZW50LCBjb2x1bW4pO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5pc19lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMucHJldmlvdXNfbGluZSAmJiB0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5hZGRfbmV3X2xpbmUgPSBmdW5jdGlvbihmb3JjZV9uZXdsaW5lKSB7XG4gIC8vIG5ldmVyIG5ld2xpbmUgYXQgdGhlIHN0YXJ0IG9mIGZpbGVcbiAgLy8gb3RoZXJ3aXNlLCBuZXdsaW5lIG9ubHkgaWYgd2UgZGlkbid0IGp1c3QgYWRkIG9uZSBvciB3ZSdyZSBmb3JjZWRcbiAgaWYgKHRoaXMuaXNfZW1wdHkoKSB8fFxuICAgICghZm9yY2VfbmV3bGluZSAmJiB0aGlzLmp1c3RfYWRkZWRfbmV3bGluZSgpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGlmIHJhdyBvdXRwdXQgaXMgZW5hYmxlZCwgZG9uJ3QgcHJpbnQgYWRkaXRpb25hbCBuZXdsaW5lcyxcbiAgLy8gYnV0IHN0aWxsIHJldHVybiBUcnVlIGFzIHRob3VnaCB5b3UgaGFkXG4gIGlmICghdGhpcy5yYXcpIHtcbiAgICB0aGlzLl9fYWRkX291dHB1dGxpbmUoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0X2NvZGUgPSBmdW5jdGlvbihlb2wpIHtcbiAgdGhpcy50cmltKHRydWUpO1xuXG4gIC8vIGhhbmRsZSBzb21lIGVkZ2UgY2FzZXMgd2hlcmUgdGhlIGxhc3QgdG9rZW5zXG4gIC8vIGhhcyB0ZXh0IHRoYXQgZW5kcyB3aXRoIG5ld2xpbmUocylcbiAgdmFyIGxhc3RfaXRlbSA9IHRoaXMuY3VycmVudF9saW5lLnBvcCgpO1xuICBpZiAobGFzdF9pdGVtKSB7XG4gICAgaWYgKGxhc3RfaXRlbVtsYXN0X2l0ZW0ubGVuZ3RoIC0gMV0gPT09ICdcXG4nKSB7XG4gICAgICBsYXN0X2l0ZW0gPSBsYXN0X2l0ZW0ucmVwbGFjZSgvXFxuKyQvZywgJycpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKGxhc3RfaXRlbSk7XG4gIH1cblxuICBpZiAodGhpcy5fZW5kX3dpdGhfbmV3bGluZSkge1xuICAgIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xuICB9XG5cbiAgdmFyIHN3ZWV0X2NvZGUgPSB0aGlzLl9fbGluZXMuam9pbignXFxuJyk7XG5cbiAgaWYgKGVvbCAhPT0gJ1xcbicpIHtcbiAgICBzd2VldF9jb2RlID0gc3dlZXRfY29kZS5yZXBsYWNlKC9bXFxuXS9nLCBlb2wpO1xuICB9XG4gIHJldHVybiBzd2VldF9jb2RlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5zZXRfd3JhcF9wb2ludCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmN1cnJlbnRfbGluZS5fc2V0X3dyYXBfcG9pbnQoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuc2V0X2luZGVudCA9IGZ1bmN0aW9uKGluZGVudCwgYWxpZ25tZW50KSB7XG4gIGluZGVudCA9IGluZGVudCB8fCAwO1xuICBhbGlnbm1lbnQgPSBhbGlnbm1lbnQgfHwgMDtcblxuICAvLyBOZXh0IGxpbmUgc3RvcmVzIGFsaWdubWVudCB2YWx1ZXNcbiAgdGhpcy5uZXh0X2xpbmUuc2V0X2luZGVudChpbmRlbnQsIGFsaWdubWVudCk7XG5cbiAgLy8gTmV2ZXIgaW5kZW50IHlvdXIgZmlyc3Qgb3V0cHV0IGluZGVudCBhdCB0aGUgc3RhcnQgb2YgdGhlIGZpbGVcbiAgaWYgKHRoaXMuX19saW5lcy5sZW5ndGggPiAxKSB7XG4gICAgdGhpcy5jdXJyZW50X2xpbmUuc2V0X2luZGVudChpbmRlbnQsIGFsaWdubWVudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KCk7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuYWRkX3Jhd190b2tlbiA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gIGZvciAodmFyIHggPSAwOyB4IDwgdG9rZW4ubmV3bGluZXM7IHgrKykge1xuICAgIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xuICB9XG4gIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQoLTEpO1xuICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHRva2VuLndoaXRlc3BhY2VfYmVmb3JlKTtcbiAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCh0b2tlbi50ZXh0KTtcbiAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UgPSBmYWxzZTtcbiAgdGhpcy5wcmV2aW91c190b2tlbl93cmFwcGVkID0gZmFsc2U7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmFkZF90b2tlbiA9IGZ1bmN0aW9uKHByaW50YWJsZV90b2tlbikge1xuICB0aGlzLl9fYWRkX3NwYWNlX2JlZm9yZV90b2tlbigpO1xuICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHByaW50YWJsZV90b2tlbik7XG4gIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gIHRoaXMubm9uX2JyZWFraW5nX3NwYWNlID0gZmFsc2U7XG4gIHRoaXMucHJldmlvdXNfdG9rZW5fd3JhcHBlZCA9IHRoaXMuY3VycmVudF9saW5lLl9hbGxvd193cmFwKCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLl9fYWRkX3NwYWNlX2JlZm9yZV90b2tlbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gJiYgIXRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICBpZiAoIXRoaXMubm9uX2JyZWFraW5nX3NwYWNlKSB7XG4gICAgICB0aGlzLnNldF93cmFwX3BvaW50KCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2goJyAnKTtcbiAgfVxufTtcblxuT3V0cHV0LnByb3RvdHlwZS5yZW1vdmVfaW5kZW50ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgdmFyIG91dHB1dF9sZW5ndGggPSB0aGlzLl9fbGluZXMubGVuZ3RoO1xuICB3aGlsZSAoaW5kZXggPCBvdXRwdXRfbGVuZ3RoKSB7XG4gICAgdGhpcy5fX2xpbmVzW2luZGV4XS5fcmVtb3ZlX2luZGVudCgpO1xuICAgIGluZGV4Kys7XG4gIH1cbiAgdGhpcy5jdXJyZW50X2xpbmUuX3JlbW92ZV93cmFwX2luZGVudCgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24oZWF0X25ld2xpbmVzKSB7XG4gIGVhdF9uZXdsaW5lcyA9IChlYXRfbmV3bGluZXMgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IGVhdF9uZXdsaW5lcztcblxuICB0aGlzLmN1cnJlbnRfbGluZS50cmltKCk7XG5cbiAgd2hpbGUgKGVhdF9uZXdsaW5lcyAmJiB0aGlzLl9fbGluZXMubGVuZ3RoID4gMSAmJlxuICAgIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCkpIHtcbiAgICB0aGlzLl9fbGluZXMucG9wKCk7XG4gICAgdGhpcy5jdXJyZW50X2xpbmUgPSB0aGlzLl9fbGluZXNbdGhpcy5fX2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMuY3VycmVudF9saW5lLnRyaW0oKTtcbiAgfVxuXG4gIHRoaXMucHJldmlvdXNfbGluZSA9IHRoaXMuX19saW5lcy5sZW5ndGggPiAxID9cbiAgICB0aGlzLl9fbGluZXNbdGhpcy5fX2xpbmVzLmxlbmd0aCAtIDJdIDogbnVsbDtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuanVzdF9hZGRlZF9uZXdsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5qdXN0X2FkZGVkX2JsYW5rbGluZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pc19lbXB0eSgpIHx8XG4gICAgKHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCkgJiYgdGhpcy5wcmV2aW91c19saW5lLmlzX2VtcHR5KCkpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5lbnN1cmVfZW1wdHlfbGluZV9hYm92ZSA9IGZ1bmN0aW9uKHN0YXJ0c193aXRoLCBlbmRzX3dpdGgpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fX2xpbmVzLmxlbmd0aCAtIDI7XG4gIHdoaWxlIChpbmRleCA+PSAwKSB7XG4gICAgdmFyIHBvdGVudGlhbEVtcHR5TGluZSA9IHRoaXMuX19saW5lc1tpbmRleF07XG4gICAgaWYgKHBvdGVudGlhbEVtcHR5TGluZS5pc19lbXB0eSgpKSB7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKHBvdGVudGlhbEVtcHR5TGluZS5pdGVtKDApLmluZGV4T2Yoc3RhcnRzX3dpdGgpICE9PSAwICYmXG4gICAgICBwb3RlbnRpYWxFbXB0eUxpbmUuaXRlbSgtMSkgIT09IGVuZHNfd2l0aCkge1xuICAgICAgdGhpcy5fX2xpbmVzLnNwbGljZShpbmRleCArIDEsIDAsIG5ldyBPdXRwdXRMaW5lKHRoaXMpKTtcbiAgICAgIHRoaXMucHJldmlvdXNfbGluZSA9IHRoaXMuX19saW5lc1t0aGlzLl9fbGluZXMubGVuZ3RoIC0gMl07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaW5kZXgtLTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuT3V0cHV0ID0gT3V0cHV0O1xuXG5cbi8qKiovIH0pLFxuLyogMyAqLyxcbi8qIDQgKi8sXG4vKiA1ICovLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIE9wdGlvbnMob3B0aW9ucywgbWVyZ2VfY2hpbGRfZmllbGQpIHtcbiAgdGhpcy5yYXdfb3B0aW9ucyA9IF9tZXJnZU9wdHMob3B0aW9ucywgbWVyZ2VfY2hpbGRfZmllbGQpO1xuXG4gIC8vIFN1cHBvcnQgcGFzc2luZyB0aGUgc291cmNlIHRleHQgYmFjayB3aXRoIG5vIGNoYW5nZVxuICB0aGlzLmRpc2FibGVkID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2Rpc2FibGVkJyk7XG5cbiAgdGhpcy5lb2wgPSB0aGlzLl9nZXRfY2hhcmFjdGVycygnZW9sJywgJ2F1dG8nKTtcbiAgdGhpcy5lbmRfd2l0aF9uZXdsaW5lID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2VuZF93aXRoX25ld2xpbmUnKTtcbiAgdGhpcy5pbmRlbnRfc2l6ZSA9IHRoaXMuX2dldF9udW1iZXIoJ2luZGVudF9zaXplJywgNCk7XG4gIHRoaXMuaW5kZW50X2NoYXIgPSB0aGlzLl9nZXRfY2hhcmFjdGVycygnaW5kZW50X2NoYXInLCAnICcpO1xuICB0aGlzLmluZGVudF9sZXZlbCA9IHRoaXMuX2dldF9udW1iZXIoJ2luZGVudF9sZXZlbCcpO1xuXG4gIHRoaXMucHJlc2VydmVfbmV3bGluZXMgPSB0aGlzLl9nZXRfYm9vbGVhbigncHJlc2VydmVfbmV3bGluZXMnLCB0cnVlKTtcbiAgdGhpcy5tYXhfcHJlc2VydmVfbmV3bGluZXMgPSB0aGlzLl9nZXRfbnVtYmVyKCdtYXhfcHJlc2VydmVfbmV3bGluZXMnLCAzMjc4Nik7XG4gIGlmICghdGhpcy5wcmVzZXJ2ZV9uZXdsaW5lcykge1xuICAgIHRoaXMubWF4X3ByZXNlcnZlX25ld2xpbmVzID0gMDtcbiAgfVxuXG4gIHRoaXMuaW5kZW50X3dpdGhfdGFicyA9IHRoaXMuX2dldF9ib29sZWFuKCdpbmRlbnRfd2l0aF90YWJzJywgdGhpcy5pbmRlbnRfY2hhciA9PT0gJ1xcdCcpO1xuICBpZiAodGhpcy5pbmRlbnRfd2l0aF90YWJzKSB7XG4gICAgdGhpcy5pbmRlbnRfY2hhciA9ICdcXHQnO1xuXG4gICAgLy8gaW5kZW50X3NpemUgYmVoYXZpb3IgY2hhbmdlZCBhZnRlciAxLjguNlxuICAgIC8vIEl0IHVzZWQgdG8gYmUgdGhhdCBpbmRlbnRfc2l6ZSB3b3VsZCBiZVxuICAgIC8vIHNldCB0byAxIGZvciBpbmRlbnRfd2l0aF90YWJzLiBUaGF0IGlzIG5vIGxvbmdlciBuZWVkZWQgYW5kXG4gICAgLy8gYWN0dWFsbHkgZG9lc24ndCBtYWtlIHNlbnNlIC0gd2h5IG5vdCB1c2Ugc3BhY2VzPyBGdXJ0aGVyLFxuICAgIC8vIHRoYXQgbWlnaHQgcHJvZHVjZSB1bmV4cGVjdGVkIGJlaGF2aW9yIC0gdGFicyBiZWluZyB1c2VkXG4gICAgLy8gZm9yIHNpbmdsZS1jb2x1bW4gYWxpZ25tZW50LiBTbywgd2hlbiBpbmRlbnRfd2l0aF90YWJzIGlzIHRydWVcbiAgICAvLyBhbmQgaW5kZW50X3NpemUgaXMgMSwgcmVzZXQgaW5kZW50X3NpemUgdG8gNC5cbiAgICBpZiAodGhpcy5pbmRlbnRfc2l6ZSA9PT0gMSkge1xuICAgICAgdGhpcy5pbmRlbnRfc2l6ZSA9IDQ7XG4gICAgfVxuICB9XG5cbiAgLy8gQmFja3dhcmRzIGNvbXBhdCB3aXRoIDEuMy54XG4gIHRoaXMud3JhcF9saW5lX2xlbmd0aCA9IHRoaXMuX2dldF9udW1iZXIoJ3dyYXBfbGluZV9sZW5ndGgnLCB0aGlzLl9nZXRfbnVtYmVyKCdtYXhfY2hhcicpKTtcblxuICB0aGlzLmluZGVudF9lbXB0eV9saW5lcyA9IHRoaXMuX2dldF9ib29sZWFuKCdpbmRlbnRfZW1wdHlfbGluZXMnKTtcblxuICAvLyB2YWxpZCB0ZW1wbGF0aW5nIGxhbmd1YWdlcyBbJ2RqYW5nbycsICdlcmInLCAnaGFuZGxlYmFycycsICdwaHAnLCAnc21hcnR5JywgJ2FuZ3VsYXInXVxuICAvLyBGb3Igbm93LCAnYXV0bycgPSBhbGwgb2ZmIGZvciBqYXZhc2NyaXB0LCBhbGwgZXhjZXB0IGFuZ3VsYXIgb24gZm9yIGh0bWwgKGFuZCBpbmxpbmUgamF2YXNjcmlwdC9jc3MpLlxuICAvLyBvdGhlciB2YWx1ZXMgaWdub3JlZFxuICB0aGlzLnRlbXBsYXRpbmcgPSB0aGlzLl9nZXRfc2VsZWN0aW9uX2xpc3QoJ3RlbXBsYXRpbmcnLCBbJ2F1dG8nLCAnbm9uZScsICdhbmd1bGFyJywgJ2RqYW5nbycsICdlcmInLCAnaGFuZGxlYmFycycsICdwaHAnLCAnc21hcnR5J10sIFsnYXV0byddKTtcbn1cblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9hcnJheSA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIHZhciByZXN1bHQgPSBkZWZhdWx0X3ZhbHVlIHx8IFtdO1xuICBpZiAodHlwZW9mIG9wdGlvbl92YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAob3B0aW9uX3ZhbHVlICE9PSBudWxsICYmIHR5cGVvZiBvcHRpb25fdmFsdWUuY29uY2F0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXN1bHQgPSBvcHRpb25fdmFsdWUuY29uY2F0KCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25fdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlLnNwbGl0KC9bXmEtekEtWjAtOV9cXC9cXC1dKy8pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X2Jvb2xlYW4gPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICB2YXIgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlID09PSB1bmRlZmluZWQgPyAhIWRlZmF1bHRfdmFsdWUgOiAhIW9wdGlvbl92YWx1ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfY2hhcmFjdGVycyA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIHZhciByZXN1bHQgPSBkZWZhdWx0X3ZhbHVlIHx8ICcnO1xuICBpZiAodHlwZW9mIG9wdGlvbl92YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXN1bHQgPSBvcHRpb25fdmFsdWUucmVwbGFjZSgvXFxcXHIvLCAnXFxyJykucmVwbGFjZSgvXFxcXG4vLCAnXFxuJykucmVwbGFjZSgvXFxcXHQvLCAnXFx0Jyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfbnVtYmVyID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgb3B0aW9uX3ZhbHVlID0gdGhpcy5yYXdfb3B0aW9uc1tuYW1lXTtcbiAgZGVmYXVsdF92YWx1ZSA9IHBhcnNlSW50KGRlZmF1bHRfdmFsdWUsIDEwKTtcbiAgaWYgKGlzTmFOKGRlZmF1bHRfdmFsdWUpKSB7XG4gICAgZGVmYXVsdF92YWx1ZSA9IDA7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KG9wdGlvbl92YWx1ZSwgMTApO1xuICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IGRlZmF1bHRfdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfc2VsZWN0aW9uID0gZnVuY3Rpb24obmFtZSwgc2VsZWN0aW9uX2xpc3QsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2dldF9zZWxlY3Rpb25fbGlzdChuYW1lLCBzZWxlY3Rpb25fbGlzdCwgZGVmYXVsdF92YWx1ZSk7XG4gIGlmIChyZXN1bHQubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJbnZhbGlkIE9wdGlvbiBWYWx1ZTogVGhlIG9wdGlvbiAnXCIgKyBuYW1lICsgXCInIGNhbiBvbmx5IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlczpcXG5cIiArXG4gICAgICBzZWxlY3Rpb25fbGlzdCArIFwiXFxuWW91IHBhc3NlZCBpbjogJ1wiICsgdGhpcy5yYXdfb3B0aW9uc1tuYW1lXSArIFwiJ1wiKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRbMF07XG59O1xuXG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfc2VsZWN0aW9uX2xpc3QgPSBmdW5jdGlvbihuYW1lLCBzZWxlY3Rpb25fbGlzdCwgZGVmYXVsdF92YWx1ZSkge1xuICBpZiAoIXNlbGVjdGlvbl9saXN0IHx8IHNlbGVjdGlvbl9saXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNlbGVjdGlvbiBsaXN0IGNhbm5vdCBiZSBlbXB0eS5cIik7XG4gIH1cblxuICBkZWZhdWx0X3ZhbHVlID0gZGVmYXVsdF92YWx1ZSB8fCBbc2VsZWN0aW9uX2xpc3RbMF1dO1xuICBpZiAoIXRoaXMuX2lzX3ZhbGlkX3NlbGVjdGlvbihkZWZhdWx0X3ZhbHVlLCBzZWxlY3Rpb25fbGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIERlZmF1bHQgVmFsdWUhXCIpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2dldF9hcnJheShuYW1lLCBkZWZhdWx0X3ZhbHVlKTtcbiAgaWYgKCF0aGlzLl9pc192YWxpZF9zZWxlY3Rpb24ocmVzdWx0LCBzZWxlY3Rpb25fbGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludmFsaWQgT3B0aW9uIFZhbHVlOiBUaGUgb3B0aW9uICdcIiArIG5hbWUgKyBcIicgY2FuIGNvbnRhaW4gb25seSB0aGUgZm9sbG93aW5nIHZhbHVlczpcXG5cIiArXG4gICAgICBzZWxlY3Rpb25fbGlzdCArIFwiXFxuWW91IHBhc3NlZCBpbjogJ1wiICsgdGhpcy5yYXdfb3B0aW9uc1tuYW1lXSArIFwiJ1wiKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5faXNfdmFsaWRfc2VsZWN0aW9uID0gZnVuY3Rpb24ocmVzdWx0LCBzZWxlY3Rpb25fbGlzdCkge1xuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCAmJiBzZWxlY3Rpb25fbGlzdC5sZW5ndGggJiZcbiAgICAhcmVzdWx0LnNvbWUoZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gc2VsZWN0aW9uX2xpc3QuaW5kZXhPZihpdGVtKSA9PT0gLTE7IH0pO1xufTtcblxuXG4vLyBtZXJnZXMgY2hpbGQgb3B0aW9ucyB1cCB3aXRoIHRoZSBwYXJlbnQgb3B0aW9ucyBvYmplY3Rcbi8vIEV4YW1wbGU6IG9iaiA9IHthOiAxLCBiOiB7YTogMn19XG4vLyAgICAgICAgICBtZXJnZU9wdHMob2JqLCAnYicpXG4vL1xuLy8gICAgICAgICAgUmV0dXJuczoge2E6IDJ9XG5mdW5jdGlvbiBfbWVyZ2VPcHRzKGFsbE9wdGlvbnMsIGNoaWxkRmllbGROYW1lKSB7XG4gIHZhciBmaW5hbE9wdHMgPSB7fTtcbiAgYWxsT3B0aW9ucyA9IF9ub3JtYWxpemVPcHRzKGFsbE9wdGlvbnMpO1xuICB2YXIgbmFtZTtcblxuICBmb3IgKG5hbWUgaW4gYWxsT3B0aW9ucykge1xuICAgIGlmIChuYW1lICE9PSBjaGlsZEZpZWxkTmFtZSkge1xuICAgICAgZmluYWxPcHRzW25hbWVdID0gYWxsT3B0aW9uc1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICAvL21lcmdlIGluIHRoZSBwZXIgdHlwZSBzZXR0aW5ncyBmb3IgdGhlIGNoaWxkRmllbGROYW1lXG4gIGlmIChjaGlsZEZpZWxkTmFtZSAmJiBhbGxPcHRpb25zW2NoaWxkRmllbGROYW1lXSkge1xuICAgIGZvciAobmFtZSBpbiBhbGxPcHRpb25zW2NoaWxkRmllbGROYW1lXSkge1xuICAgICAgZmluYWxPcHRzW25hbWVdID0gYWxsT3B0aW9uc1tjaGlsZEZpZWxkTmFtZV1bbmFtZV07XG4gICAgfVxuICB9XG4gIHJldHVybiBmaW5hbE9wdHM7XG59XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVPcHRzKG9wdGlvbnMpIHtcbiAgdmFyIGNvbnZlcnRlZE9wdHMgPSB7fTtcbiAgdmFyIGtleTtcblxuICBmb3IgKGtleSBpbiBvcHRpb25zKSB7XG4gICAgdmFyIG5ld0tleSA9IGtleS5yZXBsYWNlKC8tL2csIFwiX1wiKTtcbiAgICBjb252ZXJ0ZWRPcHRzW25ld0tleV0gPSBvcHRpb25zW2tleV07XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRlZE9wdHM7XG59XG5cbm1vZHVsZS5leHBvcnRzLk9wdGlvbnMgPSBPcHRpb25zO1xubW9kdWxlLmV4cG9ydHMubm9ybWFsaXplT3B0cyA9IF9ub3JtYWxpemVPcHRzO1xubW9kdWxlLmV4cG9ydHMubWVyZ2VPcHRzID0gX21lcmdlT3B0cztcblxuXG4vKioqLyB9KSxcbi8qIDcgKi8sXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIHJlZ2V4cF9oYXNfc3RpY2t5ID0gUmVnRXhwLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnc3RpY2t5Jyk7XG5cbmZ1bmN0aW9uIElucHV0U2Nhbm5lcihpbnB1dF9zdHJpbmcpIHtcbiAgdGhpcy5fX2lucHV0ID0gaW5wdXRfc3RyaW5nIHx8ICcnO1xuICB0aGlzLl9faW5wdXRfbGVuZ3RoID0gdGhpcy5fX2lucHV0Lmxlbmd0aDtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gMDtcbn1cblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZXN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX19wb3NpdGlvbiA9IDA7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX19wb3NpdGlvbiA+IDApIHtcbiAgICB0aGlzLl9fcG9zaXRpb24gLT0gMTtcbiAgfVxufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fcG9zaXRpb24gPCB0aGlzLl9faW5wdXRfbGVuZ3RoO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB2YWwgPSBudWxsO1xuICBpZiAodGhpcy5oYXNOZXh0KCkpIHtcbiAgICB2YWwgPSB0aGlzLl9faW5wdXQuY2hhckF0KHRoaXMuX19wb3NpdGlvbik7XG4gICAgdGhpcy5fX3Bvc2l0aW9uICs9IDE7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciB2YWwgPSBudWxsO1xuICBpbmRleCA9IGluZGV4IHx8IDA7XG4gIGluZGV4ICs9IHRoaXMuX19wb3NpdGlvbjtcbiAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9faW5wdXRfbGVuZ3RoKSB7XG4gICAgdmFsID0gdGhpcy5fX2lucHV0LmNoYXJBdChpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8vIFRoaXMgaXMgYSBKYXZhU2NyaXB0IG9ubHkgaGVscGVyIGZ1bmN0aW9uIChub3QgaW4gcHl0aG9uKVxuLy8gSmF2YXNjcmlwdCBkb2Vzbid0IGhhdmUgYSBtYXRjaCBtZXRob2Rcbi8vIGFuZCBub3QgYWxsIGltcGxlbWVudGF0aW9uIHN1cHBvcnQgXCJzdGlja3lcIiBmbGFnLlxuLy8gSWYgdGhleSBkbyBub3Qgc3VwcG9ydCBzdGlja3kgdGhlbiBib3RoIHRoaXMubWF0Y2goKSBhbmQgdGhpcy50ZXN0KCkgbWV0aG9kXG4vLyBtdXN0IGdldCB0aGUgbWF0Y2ggYW5kIGNoZWNrIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2guXG4vLyBJZiBzdGlja3kgaXMgc3VwcG9ydGVkIGFuZCBzZXQsIHRoaXMgbWV0aG9kIHdpbGwgdXNlIGl0LlxuLy8gT3RoZXJ3aXNlIGl0IHdpbGwgY2hlY2sgdGhhdCBnbG9iYWwgaXMgc2V0LCBhbmQgZmFsbCBiYWNrIHRvIHRoZSBzbG93ZXIgbWV0aG9kLlxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5fX21hdGNoID0gZnVuY3Rpb24ocGF0dGVybiwgaW5kZXgpIHtcbiAgcGF0dGVybi5sYXN0SW5kZXggPSBpbmRleDtcbiAgdmFyIHBhdHRlcm5fbWF0Y2ggPSBwYXR0ZXJuLmV4ZWModGhpcy5fX2lucHV0KTtcblxuICBpZiAocGF0dGVybl9tYXRjaCAmJiAhKHJlZ2V4cF9oYXNfc3RpY2t5ICYmIHBhdHRlcm4uc3RpY2t5KSkge1xuICAgIGlmIChwYXR0ZXJuX21hdGNoLmluZGV4ICE9PSBpbmRleCkge1xuICAgICAgcGF0dGVybl9tYXRjaCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhdHRlcm5fbWF0Y2g7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbihwYXR0ZXJuLCBpbmRleCkge1xuICBpbmRleCA9IGluZGV4IHx8IDA7XG4gIGluZGV4ICs9IHRoaXMuX19wb3NpdGlvbjtcblxuICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX19pbnB1dF9sZW5ndGgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9fbWF0Y2gocGF0dGVybiwgaW5kZXgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS50ZXN0Q2hhciA9IGZ1bmN0aW9uKHBhdHRlcm4sIGluZGV4KSB7XG4gIC8vIHRlc3Qgb25lIGNoYXJhY3RlciByZWdleCBtYXRjaFxuICB2YXIgdmFsID0gdGhpcy5wZWVrKGluZGV4KTtcbiAgcGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHBhdHRlcm4udGVzdCh2YWwpO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHBhdHRlcm5fbWF0Y2ggPSB0aGlzLl9fbWF0Y2gocGF0dGVybiwgdGhpcy5fX3Bvc2l0aW9uKTtcbiAgaWYgKHBhdHRlcm5fbWF0Y2gpIHtcbiAgICB0aGlzLl9fcG9zaXRpb24gKz0gcGF0dGVybl9tYXRjaFswXS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgcGF0dGVybl9tYXRjaCA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHBhdHRlcm5fbWF0Y2g7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihzdGFydGluZ19wYXR0ZXJuLCB1bnRpbF9wYXR0ZXJuLCB1bnRpbF9hZnRlcikge1xuICB2YXIgdmFsID0gJyc7XG4gIHZhciBtYXRjaDtcbiAgaWYgKHN0YXJ0aW5nX3BhdHRlcm4pIHtcbiAgICBtYXRjaCA9IHRoaXMubWF0Y2goc3RhcnRpbmdfcGF0dGVybik7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YWwgKz0gbWF0Y2hbMF07XG4gICAgfVxuICB9XG4gIGlmICh1bnRpbF9wYXR0ZXJuICYmIChtYXRjaCB8fCAhc3RhcnRpbmdfcGF0dGVybikpIHtcbiAgICB2YWwgKz0gdGhpcy5yZWFkVW50aWwodW50aWxfcGF0dGVybiwgdW50aWxfYWZ0ZXIpO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnJlYWRVbnRpbCA9IGZ1bmN0aW9uKHBhdHRlcm4sIHVudGlsX2FmdGVyKSB7XG4gIHZhciB2YWwgPSAnJztcbiAgdmFyIG1hdGNoX2luZGV4ID0gdGhpcy5fX3Bvc2l0aW9uO1xuICBwYXR0ZXJuLmxhc3RJbmRleCA9IHRoaXMuX19wb3NpdGlvbjtcbiAgdmFyIHBhdHRlcm5fbWF0Y2ggPSBwYXR0ZXJuLmV4ZWModGhpcy5fX2lucHV0KTtcbiAgaWYgKHBhdHRlcm5fbWF0Y2gpIHtcbiAgICBtYXRjaF9pbmRleCA9IHBhdHRlcm5fbWF0Y2guaW5kZXg7XG4gICAgaWYgKHVudGlsX2FmdGVyKSB7XG4gICAgICBtYXRjaF9pbmRleCArPSBwYXR0ZXJuX21hdGNoWzBdLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWF0Y2hfaW5kZXggPSB0aGlzLl9faW5wdXRfbGVuZ3RoO1xuICB9XG5cbiAgdmFsID0gdGhpcy5fX2lucHV0LnN1YnN0cmluZyh0aGlzLl9fcG9zaXRpb24sIG1hdGNoX2luZGV4KTtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gbWF0Y2hfaW5kZXg7XG4gIHJldHVybiB2YWw7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnJlYWRVbnRpbEFmdGVyID0gZnVuY3Rpb24ocGF0dGVybikge1xuICByZXR1cm4gdGhpcy5yZWFkVW50aWwocGF0dGVybiwgdHJ1ZSk7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmdldF9yZWdleHAgPSBmdW5jdGlvbihwYXR0ZXJuLCBtYXRjaF9mcm9tKSB7XG4gIHZhciByZXN1bHQgPSBudWxsO1xuICB2YXIgZmxhZ3MgPSAnZyc7XG4gIGlmIChtYXRjaF9mcm9tICYmIHJlZ2V4cF9oYXNfc3RpY2t5KSB7XG4gICAgZmxhZ3MgPSAneSc7XG4gIH1cbiAgLy8gc3RyaW5ncyBhcmUgY29udmVydGVkIHRvIHJlZ2V4cFxuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwic3RyaW5nXCIgJiYgcGF0dGVybiAhPT0gJycpIHtcbiAgICAvLyByZXN1bHQgPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyksIGZsYWdzKTtcbiAgICByZXN1bHQgPSBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgfSBlbHNlIGlmIChwYXR0ZXJuKSB7XG4gICAgcmVzdWx0ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgZmxhZ3MpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmdldF9saXRlcmFsX3JlZ2V4cCA9IGZ1bmN0aW9uKGxpdGVyYWxfc3RyaW5nKSB7XG4gIHJldHVybiBSZWdFeHAobGl0ZXJhbF9zdHJpbmcucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJykpO1xufTtcblxuLyogY3NzIGJlYXV0aWZpZXIgbGVnYWN5IGhlbHBlcnMgKi9cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucGVla1VudGlsQWZ0ZXIgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciBzdGFydCA9IHRoaXMuX19wb3NpdGlvbjtcbiAgdmFyIHZhbCA9IHRoaXMucmVhZFVudGlsQWZ0ZXIocGF0dGVybik7XG4gIHRoaXMuX19wb3NpdGlvbiA9IHN0YXJ0O1xuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5sb29rQmFjayA9IGZ1bmN0aW9uKHRlc3RWYWwpIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5fX3Bvc2l0aW9uIC0gMTtcbiAgcmV0dXJuIHN0YXJ0ID49IHRlc3RWYWwubGVuZ3RoICYmIHRoaXMuX19pbnB1dC5zdWJzdHJpbmcoc3RhcnQgLSB0ZXN0VmFsLmxlbmd0aCwgc3RhcnQpXG4gICAgLnRvTG93ZXJDYXNlKCkgPT09IHRlc3RWYWw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5JbnB1dFNjYW5uZXIgPSBJbnB1dFNjYW5uZXI7XG5cblxuLyoqKi8gfSksXG4vKiA5ICovLFxuLyogMTAgKi8sXG4vKiAxMSAqLyxcbi8qIDEyICovLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBEaXJlY3RpdmVzKHN0YXJ0X2Jsb2NrX3BhdHRlcm4sIGVuZF9ibG9ja19wYXR0ZXJuKSB7XG4gIHN0YXJ0X2Jsb2NrX3BhdHRlcm4gPSB0eXBlb2Ygc3RhcnRfYmxvY2tfcGF0dGVybiA9PT0gJ3N0cmluZycgPyBzdGFydF9ibG9ja19wYXR0ZXJuIDogc3RhcnRfYmxvY2tfcGF0dGVybi5zb3VyY2U7XG4gIGVuZF9ibG9ja19wYXR0ZXJuID0gdHlwZW9mIGVuZF9ibG9ja19wYXR0ZXJuID09PSAnc3RyaW5nJyA/IGVuZF9ibG9ja19wYXR0ZXJuIDogZW5kX2Jsb2NrX3BhdHRlcm4uc291cmNlO1xuICB0aGlzLl9fZGlyZWN0aXZlc19ibG9ja19wYXR0ZXJuID0gbmV3IFJlZ0V4cChzdGFydF9ibG9ja19wYXR0ZXJuICsgLyBiZWF1dGlmeSggXFx3K1s6XVxcdyspKyAvLnNvdXJjZSArIGVuZF9ibG9ja19wYXR0ZXJuLCAnZycpO1xuICB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4gPSAvIChcXHcrKVs6XShcXHcrKS9nO1xuXG4gIHRoaXMuX19kaXJlY3RpdmVzX2VuZF9pZ25vcmVfcGF0dGVybiA9IG5ldyBSZWdFeHAoc3RhcnRfYmxvY2tfcGF0dGVybiArIC9cXHNiZWF1dGlmeVxcc2lnbm9yZTplbmRcXHMvLnNvdXJjZSArIGVuZF9ibG9ja19wYXR0ZXJuLCAnZycpO1xufVxuXG5EaXJlY3RpdmVzLnByb3RvdHlwZS5nZXRfZGlyZWN0aXZlcyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgaWYgKCF0ZXh0Lm1hdGNoKHRoaXMuX19kaXJlY3RpdmVzX2Jsb2NrX3BhdHRlcm4pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZGlyZWN0aXZlcyA9IHt9O1xuICB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgdmFyIGRpcmVjdGl2ZV9tYXRjaCA9IHRoaXMuX19kaXJlY3RpdmVfcGF0dGVybi5leGVjKHRleHQpO1xuXG4gIHdoaWxlIChkaXJlY3RpdmVfbWF0Y2gpIHtcbiAgICBkaXJlY3RpdmVzW2RpcmVjdGl2ZV9tYXRjaFsxXV0gPSBkaXJlY3RpdmVfbWF0Y2hbMl07XG4gICAgZGlyZWN0aXZlX21hdGNoID0gdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuLmV4ZWModGV4dCk7XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aXZlcztcbn07XG5cbkRpcmVjdGl2ZXMucHJvdG90eXBlLnJlYWRJZ25vcmVkID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0LnJlYWRVbnRpbEFmdGVyKHRoaXMuX19kaXJlY3RpdmVzX2VuZF9pZ25vcmVfcGF0dGVybik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLkRpcmVjdGl2ZXMgPSBEaXJlY3RpdmVzO1xuXG5cbi8qKiovIH0pLFxuLyogMTQgKi8sXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIEJlYXV0aWZpZXIgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxNikuQmVhdXRpZmllciksXG4gIE9wdGlvbnMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxNykuT3B0aW9ucyk7XG5cbmZ1bmN0aW9uIGNzc19iZWF1dGlmeShzb3VyY2VfdGV4dCwgb3B0aW9ucykge1xuICB2YXIgYmVhdXRpZmllciA9IG5ldyBCZWF1dGlmaWVyKHNvdXJjZV90ZXh0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGJlYXV0aWZpZXIuYmVhdXRpZnkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjc3NfYmVhdXRpZnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IE9wdGlvbnMoKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIE9wdGlvbnMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxNykuT3B0aW9ucyk7XG52YXIgT3V0cHV0ID0gKF9fd2VicGFja19yZXF1aXJlX18oMikuT3V0cHV0KTtcbnZhciBJbnB1dFNjYW5uZXIgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg4KS5JbnB1dFNjYW5uZXIpO1xudmFyIERpcmVjdGl2ZXMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxMykuRGlyZWN0aXZlcyk7XG5cbnZhciBkaXJlY3RpdmVzX2NvcmUgPSBuZXcgRGlyZWN0aXZlcygvXFwvXFwqLywgL1xcKlxcLy8pO1xuXG52YXIgbGluZUJyZWFrID0gL1xcclxcbnxbXFxyXFxuXS87XG52YXIgYWxsTGluZUJyZWFrcyA9IC9cXHJcXG58W1xcclxcbl0vZztcblxuLy8gdG9rZW5pemVyXG52YXIgd2hpdGVzcGFjZUNoYXIgPSAvXFxzLztcbnZhciB3aGl0ZXNwYWNlUGF0dGVybiA9IC8oPzpcXHN8XFxuKSsvZztcbnZhciBibG9ja19jb21tZW50X3BhdHRlcm4gPSAvXFwvXFwqKD86W1xcc1xcU10qPykoKD86XFwqXFwvKXwkKS9nO1xudmFyIGNvbW1lbnRfcGF0dGVybiA9IC9cXC9cXC8oPzpbXlxcblxcclxcdTIwMjhcXHUyMDI5XSopL2c7XG5cbmZ1bmN0aW9uIEJlYXV0aWZpZXIoc291cmNlX3RleHQsIG9wdGlvbnMpIHtcbiAgdGhpcy5fc291cmNlX3RleHQgPSBzb3VyY2VfdGV4dCB8fCAnJztcbiAgLy8gQWxsb3cgdGhlIHNldHRpbmcgb2YgbGFuZ3VhZ2UvZmlsZS10eXBlIHNwZWNpZmljIG9wdGlvbnNcbiAgLy8gd2l0aCBpbmhlcml0YW5jZSBvZiBvdmVyYWxsIHNldHRpbmdzXG4gIHRoaXMuX29wdGlvbnMgPSBuZXcgT3B0aW9ucyhvcHRpb25zKTtcbiAgdGhpcy5fY2ggPSBudWxsO1xuICB0aGlzLl9pbnB1dCA9IG51bGw7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0F0LXJ1bGVcbiAgdGhpcy5ORVNURURfQVRfUlVMRSA9IHtcbiAgICBcInBhZ2VcIjogdHJ1ZSxcbiAgICBcImZvbnQtZmFjZVwiOiB0cnVlLFxuICAgIFwia2V5ZnJhbWVzXCI6IHRydWUsXG4gICAgLy8gYWxzbyBpbiBDT05ESVRJT05BTF9HUk9VUF9SVUxFIGJlbG93XG4gICAgXCJtZWRpYVwiOiB0cnVlLFxuICAgIFwic3VwcG9ydHNcIjogdHJ1ZSxcbiAgICBcImRvY3VtZW50XCI6IHRydWVcbiAgfTtcbiAgdGhpcy5DT05ESVRJT05BTF9HUk9VUF9SVUxFID0ge1xuICAgIFwibWVkaWFcIjogdHJ1ZSxcbiAgICBcInN1cHBvcnRzXCI6IHRydWUsXG4gICAgXCJkb2N1bWVudFwiOiB0cnVlXG4gIH07XG4gIHRoaXMuTk9OX1NFTUlDT0xPTl9ORVdMSU5FX1BST1BFUlRZID0gW1xuICAgIFwiZ3JpZC10ZW1wbGF0ZS1hcmVhc1wiLFxuICAgIFwiZ3JpZC10ZW1wbGF0ZVwiXG4gIF07XG5cbn1cblxuQmVhdXRpZmllci5wcm90b3R5cGUuZWF0U3RyaW5nID0gZnVuY3Rpb24oZW5kQ2hhcnMpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB0aGlzLl9jaCA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgd2hpbGUgKHRoaXMuX2NoKSB7XG4gICAgcmVzdWx0ICs9IHRoaXMuX2NoO1xuICAgIGlmICh0aGlzLl9jaCA9PT0gXCJcXFxcXCIpIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgfSBlbHNlIGlmIChlbmRDaGFycy5pbmRleE9mKHRoaXMuX2NoKSAhPT0gLTEgfHwgdGhpcy5fY2ggPT09IFwiXFxuXCIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl9jaCA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gU2tpcHMgYW55IHdoaXRlIHNwYWNlIGluIHRoZSBzb3VyY2UgdGV4dCBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuLy8gV2hlbiBhbGxvd0F0TGVhc3RPbmVOZXdMaW5lIGlzIHRydWUsIHdpbGwgb3V0cHV0IG5ldyBsaW5lcyBmb3IgZWFjaFxuLy8gbmV3bGluZSBjaGFyYWN0ZXIgZm91bmQ7IGlmIHRoZSB1c2VyIGhhcyBwcmVzZXJ2ZV9uZXdsaW5lcyBvZmYsIG9ubHlcbi8vIHRoZSBmaXJzdCBuZXdsaW5lIHdpbGwgYmUgb3V0cHV0XG5CZWF1dGlmaWVyLnByb3RvdHlwZS5lYXRXaGl0ZXNwYWNlID0gZnVuY3Rpb24oYWxsb3dBdExlYXN0T25lTmV3TGluZSkge1xuICB2YXIgcmVzdWx0ID0gd2hpdGVzcGFjZUNoYXIudGVzdCh0aGlzLl9pbnB1dC5wZWVrKCkpO1xuICB2YXIgbmV3bGluZV9jb3VudCA9IDA7XG4gIHdoaWxlICh3aGl0ZXNwYWNlQ2hhci50ZXN0KHRoaXMuX2lucHV0LnBlZWsoKSkpIHtcbiAgICB0aGlzLl9jaCA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICBpZiAoYWxsb3dBdExlYXN0T25lTmV3TGluZSAmJiB0aGlzLl9jaCA9PT0gJ1xcbicpIHtcbiAgICAgIGlmIChuZXdsaW5lX2NvdW50ID09PSAwIHx8IG5ld2xpbmVfY291bnQgPCB0aGlzLl9vcHRpb25zLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcykge1xuICAgICAgICBuZXdsaW5lX2NvdW50Kys7XG4gICAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBOZXN0ZWQgcHNldWRvLWNsYXNzIGlmIHdlIGFyZSBpbnNpZGVSdWxlXG4vLyBhbmQgdGhlIG5leHQgc3BlY2lhbCBjaGFyYWN0ZXIgZm91bmQgb3BlbnNcbi8vIGEgbmV3IGJsb2NrXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5mb3VuZE5lc3RlZFBzZXVkb0NsYXNzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvcGVuUGFyZW4gPSAwO1xuICB2YXIgaSA9IDE7XG4gIHZhciBjaCA9IHRoaXMuX2lucHV0LnBlZWsoaSk7XG4gIHdoaWxlIChjaCkge1xuICAgIGlmIChjaCA9PT0gXCJ7XCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09ICcoJykge1xuICAgICAgLy8gcHNldWRvY2xhc3NlcyBjYW4gY29udGFpbiAoKVxuICAgICAgb3BlblBhcmVuICs9IDE7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gJyknKSB7XG4gICAgICBpZiAob3BlblBhcmVuID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9wZW5QYXJlbiAtPSAxO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiO1wiIHx8IGNoID09PSBcIn1cIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpKys7XG4gICAgY2ggPSB0aGlzLl9pbnB1dC5wZWVrKGkpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLnByaW50X3N0cmluZyA9IGZ1bmN0aW9uKG91dHB1dF9zdHJpbmcpIHtcbiAgdGhpcy5fb3V0cHV0LnNldF9pbmRlbnQodGhpcy5faW5kZW50TGV2ZWwpO1xuICB0aGlzLl9vdXRwdXQubm9uX2JyZWFraW5nX3NwYWNlID0gdHJ1ZTtcbiAgdGhpcy5fb3V0cHV0LmFkZF90b2tlbihvdXRwdXRfc3RyaW5nKTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLnByZXNlcnZlU2luZ2xlU3BhY2UgPSBmdW5jdGlvbihpc0FmdGVyU3BhY2UpIHtcbiAgaWYgKGlzQWZ0ZXJTcGFjZSkge1xuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5faW5kZW50TGV2ZWwrKztcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLm91dGRlbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2luZGVudExldmVsID4gMCkge1xuICAgIHRoaXMuX2luZGVudExldmVsLS07XG4gIH1cbn07XG5cbi8qX19fX19fX19fX19fX19fX19fX19fLS0tLS0tLS0tLS0tLS0tLS0tLS1fX19fX19fX19fX19fX19fX19fX18qL1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5iZWF1dGlmeSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fb3B0aW9ucy5kaXNhYmxlZCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VfdGV4dDtcbiAgfVxuXG4gIHZhciBzb3VyY2VfdGV4dCA9IHRoaXMuX3NvdXJjZV90ZXh0O1xuICB2YXIgZW9sID0gdGhpcy5fb3B0aW9ucy5lb2w7XG4gIGlmIChlb2wgPT09ICdhdXRvJykge1xuICAgIGVvbCA9ICdcXG4nO1xuICAgIGlmIChzb3VyY2VfdGV4dCAmJiBsaW5lQnJlYWsudGVzdChzb3VyY2VfdGV4dCB8fCAnJykpIHtcbiAgICAgIGVvbCA9IHNvdXJjZV90ZXh0Lm1hdGNoKGxpbmVCcmVhaylbMF07XG4gICAgfVxuICB9XG5cblxuICAvLyBIQUNLOiBuZXdsaW5lIHBhcnNpbmcgaW5jb25zaXN0ZW50LiBUaGlzIGJydXRlIGZvcmNlIG5vcm1hbGl6ZXMgdGhlIHRoaXMuX2lucHV0LlxuICBzb3VyY2VfdGV4dCA9IHNvdXJjZV90ZXh0LnJlcGxhY2UoYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuXG4gIC8vIHJlc2V0XG4gIHZhciBiYXNlSW5kZW50U3RyaW5nID0gc291cmNlX3RleHQubWF0Y2goL15bXFx0IF0qLylbMF07XG5cbiAgdGhpcy5fb3V0cHV0ID0gbmV3IE91dHB1dCh0aGlzLl9vcHRpb25zLCBiYXNlSW5kZW50U3RyaW5nKTtcbiAgdGhpcy5faW5wdXQgPSBuZXcgSW5wdXRTY2FubmVyKHNvdXJjZV90ZXh0KTtcbiAgdGhpcy5faW5kZW50TGV2ZWwgPSAwO1xuICB0aGlzLl9uZXN0ZWRMZXZlbCA9IDA7XG5cbiAgdGhpcy5fY2ggPSBudWxsO1xuICB2YXIgcGFyZW5MZXZlbCA9IDA7XG5cbiAgdmFyIGluc2lkZVJ1bGUgPSBmYWxzZTtcbiAgLy8gVGhpcyBpcyB0aGUgdmFsdWUgc2lkZSBvZiBhIHByb3BlcnR5IHZhbHVlIHBhaXIgKGJsdWUgaW4gdGhlIGZvbGxvd2luZyBleClcbiAgLy8gbGFiZWwgeyBjb250ZW50OiBibHVlIH1cbiAgdmFyIGluc2lkZVByb3BlcnR5VmFsdWUgPSBmYWxzZTtcbiAgdmFyIGVudGVyaW5nQ29uZGl0aW9uYWxHcm91cCA9IGZhbHNlO1xuICB2YXIgaW5zaWRlTm9uTmVzdGVkQXRSdWxlID0gZmFsc2U7XG4gIHZhciBpbnNpZGVTY3NzTWFwID0gZmFsc2U7XG4gIHZhciB0b3BDaGFyYWN0ZXIgPSB0aGlzLl9jaDtcbiAgdmFyIGluc2lkZU5vblNlbWlDb2xvblZhbHVlcyA9IGZhbHNlO1xuICB2YXIgd2hpdGVzcGFjZTtcbiAgdmFyIGlzQWZ0ZXJTcGFjZTtcbiAgdmFyIHByZXZpb3VzX2NoO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgd2hpdGVzcGFjZSA9IHRoaXMuX2lucHV0LnJlYWQod2hpdGVzcGFjZVBhdHRlcm4pO1xuICAgIGlzQWZ0ZXJTcGFjZSA9IHdoaXRlc3BhY2UgIT09ICcnO1xuICAgIHByZXZpb3VzX2NoID0gdG9wQ2hhcmFjdGVyO1xuICAgIHRoaXMuX2NoID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIGlmICh0aGlzLl9jaCA9PT0gJ1xcXFwnICYmIHRoaXMuX2lucHV0Lmhhc05leHQoKSkge1xuICAgICAgdGhpcy5fY2ggKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIH1cbiAgICB0b3BDaGFyYWN0ZXIgPSB0aGlzLl9jaDtcblxuICAgIGlmICghdGhpcy5fY2gpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICcvJyAmJiB0aGlzLl9pbnB1dC5wZWVrKCkgPT09ICcqJykge1xuICAgICAgLy8gLyogY3NzIGNvbW1lbnQgKi9cbiAgICAgIC8vIEFsd2F5cyBzdGFydCBibG9jayBjb21tZW50cyBvbiBhIG5ldyBsaW5lLlxuICAgICAgLy8gVGhpcyBoYW5kbGVzIHNjZW5hcmlvcyB3aGVyZSBhIGJsb2NrIGNvbW1lbnQgaW1tZWRpYXRlbHlcbiAgICAgIC8vIGZvbGxvd3MgYSBwcm9wZXJ0eSBkZWZpbml0aW9uIG9uIHRoZSBzYW1lIGxpbmUgb3Igd2hlcmVcbiAgICAgIC8vIG1pbmlmaWVkIGNvZGUgaXMgYmVpbmcgYmVhdXRpZmllZC5cbiAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgIHRoaXMuX2lucHV0LmJhY2soKTtcblxuICAgICAgdmFyIGNvbW1lbnQgPSB0aGlzLl9pbnB1dC5yZWFkKGJsb2NrX2NvbW1lbnRfcGF0dGVybik7XG5cbiAgICAgIC8vIEhhbmRsZSBpZ25vcmUgZGlyZWN0aXZlXG4gICAgICB2YXIgZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXNfY29yZS5nZXRfZGlyZWN0aXZlcyhjb21tZW50KTtcbiAgICAgIGlmIChkaXJlY3RpdmVzICYmIGRpcmVjdGl2ZXMuaWdub3JlID09PSAnc3RhcnQnKSB7XG4gICAgICAgIGNvbW1lbnQgKz0gZGlyZWN0aXZlc19jb3JlLnJlYWRJZ25vcmVkKHRoaXMuX2lucHV0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcmludF9zdHJpbmcoY29tbWVudCk7XG5cbiAgICAgIC8vIEVuc3VyZXMgYW55IG5ldyBsaW5lcyBmb2xsb3dpbmcgdGhlIGNvbW1lbnQgYXJlIHByZXNlcnZlZFxuICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuXG4gICAgICAvLyBCbG9jayBjb21tZW50cyBhcmUgZm9sbG93ZWQgYnkgYSBuZXcgbGluZSBzbyB0aGV5IGRvbid0XG4gICAgICAvLyBzaGFyZSBhIGxpbmUgd2l0aCBvdGhlciBwcm9wZXJ0aWVzXG4gICAgICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJy8nICYmIHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJy8nKSB7XG4gICAgICAvLyAvLyBzaW5nbGUgbGluZSBjb21tZW50XG4gICAgICAvLyBQcmVzZXJ2ZXMgdGhlIHNwYWNlIGJlZm9yZSBhIGNvbW1lbnRcbiAgICAgIC8vIG9uIHRoZSBzYW1lIGxpbmUgYXMgYSBydWxlXG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2lucHV0LmJhY2soKTtcbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2lucHV0LnJlYWQoY29tbWVudF9wYXR0ZXJuKSk7XG5cbiAgICAgIC8vIEVuc3VyZXMgYW55IG5ldyBsaW5lcyBmb2xsb3dpbmcgdGhlIGNvbW1lbnQgYXJlIHByZXNlcnZlZFxuICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICckJykge1xuICAgICAgdGhpcy5wcmVzZXJ2ZVNpbmdsZVNwYWNlKGlzQWZ0ZXJTcGFjZSk7XG5cbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcblxuICAgICAgLy8gc3RyaXAgdHJhaWxpbmcgc3BhY2UsIGlmIHByZXNlbnQsIGZvciBoYXNoIHByb3BlcnR5IGNoZWNrc1xuICAgICAgdmFyIHZhcmlhYmxlID0gdGhpcy5faW5wdXQucGVla1VudGlsQWZ0ZXIoL1s6ICw7e30oKVtcXF1cXC89J1wiXS9nKTtcblxuICAgICAgaWYgKHZhcmlhYmxlLm1hdGNoKC9bIDpdJC8pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSB2YXJpYWJsZSBvciBwc2V1ZG8tY2xhc3MsIGFkZCBpdCBhbmQgaW5zZXJ0IG9uZSBzcGFjZSBiZWZvcmUgY29udGludWluZ1xuICAgICAgICB2YXJpYWJsZSA9IHRoaXMuZWF0U3RyaW5nKFwiOiBcIikucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHZhcmlhYmxlKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIG1pZ2h0IGJlIHNhc3MgdmFyaWFibGVcbiAgICAgIGlmIChwYXJlbkxldmVsID09PSAwICYmIHZhcmlhYmxlLmluZGV4T2YoJzonKSAhPT0gLTEpIHtcbiAgICAgICAgaW5zaWRlUHJvcGVydHlWYWx1ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJ0AnKSB7XG4gICAgICB0aGlzLnByZXNlcnZlU2luZ2xlU3BhY2UoaXNBZnRlclNwYWNlKTtcblxuICAgICAgLy8gZGVhbCB3aXRoIGxlc3MgcHJvcGVydHkgbWl4aW5zIEB7Li4ufVxuICAgICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJ3snKSB7XG4gICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoICsgdGhpcy5lYXRTdHJpbmcoJ30nKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG5cbiAgICAgICAgLy8gc3RyaXAgdHJhaWxpbmcgc3BhY2UsIGlmIHByZXNlbnQsIGZvciBoYXNoIHByb3BlcnR5IGNoZWNrc1xuICAgICAgICB2YXIgdmFyaWFibGVPclJ1bGUgPSB0aGlzLl9pbnB1dC5wZWVrVW50aWxBZnRlcigvWzogLDt7fSgpW1xcXVxcLz0nXCJdL2cpO1xuXG4gICAgICAgIGlmICh2YXJpYWJsZU9yUnVsZS5tYXRjaCgvWyA6XSQvKSkge1xuICAgICAgICAgIC8vIHdlIGhhdmUgYSB2YXJpYWJsZSBvciBwc2V1ZG8tY2xhc3MsIGFkZCBpdCBhbmQgaW5zZXJ0IG9uZSBzcGFjZSBiZWZvcmUgY29udGludWluZ1xuICAgICAgICAgIHZhcmlhYmxlT3JSdWxlID0gdGhpcy5lYXRTdHJpbmcoXCI6IFwiKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgICAgICB0aGlzLnByaW50X3N0cmluZyh2YXJpYWJsZU9yUnVsZSk7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtaWdodCBiZSBsZXNzIHZhcmlhYmxlXG4gICAgICAgIGlmIChwYXJlbkxldmVsID09PSAwICYmIHZhcmlhYmxlT3JSdWxlLmluZGV4T2YoJzonKSAhPT0gLTEpIHtcbiAgICAgICAgICBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmluZGVudCgpO1xuXG4gICAgICAgICAgLy8gbWlnaHQgYmUgYSBuZXN0aW5nIGF0LXJ1bGVcbiAgICAgICAgfSBlbHNlIGlmICh2YXJpYWJsZU9yUnVsZSBpbiB0aGlzLk5FU1RFRF9BVF9SVUxFKSB7XG4gICAgICAgICAgdGhpcy5fbmVzdGVkTGV2ZWwgKz0gMTtcbiAgICAgICAgICBpZiAodmFyaWFibGVPclJ1bGUgaW4gdGhpcy5DT05ESVRJT05BTF9HUk9VUF9SVUxFKSB7XG4gICAgICAgICAgICBlbnRlcmluZ0NvbmRpdGlvbmFsR3JvdXAgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG1pZ2h0IGJlIGEgbm9uLW5lc3RlZCBhdC1ydWxlXG4gICAgICAgIH0gZWxzZSBpZiAocGFyZW5MZXZlbCA9PT0gMCAmJiAhaW5zaWRlUHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgIGluc2lkZU5vbk5lc3RlZEF0UnVsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnIycgJiYgdGhpcy5faW5wdXQucGVlaygpID09PSAneycpIHtcbiAgICAgIHRoaXMucHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpO1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2ggKyB0aGlzLmVhdFN0cmluZygnfScpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAneycpIHtcbiAgICAgIGlmIChpbnNpZGVQcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgIGluc2lkZVByb3BlcnR5VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vdXRkZW50KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIG5vbiBuZXN0ZWQgYXQgcnVsZSBiZWNvbWVzIG5lc3RlZFxuICAgICAgaW5zaWRlTm9uTmVzdGVkQXRSdWxlID0gZmFsc2U7XG5cbiAgICAgIC8vIHdoZW4gZW50ZXJpbmcgY29uZGl0aW9uYWwgZ3JvdXBzLCBvbmx5IHJ1bGVzZXRzIGFyZSBhbGxvd2VkXG4gICAgICBpZiAoZW50ZXJpbmdDb25kaXRpb25hbEdyb3VwKSB7XG4gICAgICAgIGVudGVyaW5nQ29uZGl0aW9uYWxHcm91cCA9IGZhbHNlO1xuICAgICAgICBpbnNpZGVSdWxlID0gKHRoaXMuX2luZGVudExldmVsID49IHRoaXMuX25lc3RlZExldmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSwgZGVjbGFyYXRpb25zIGFyZSBhbHNvIGFsbG93ZWRcbiAgICAgICAgaW5zaWRlUnVsZSA9ICh0aGlzLl9pbmRlbnRMZXZlbCA+PSB0aGlzLl9uZXN0ZWRMZXZlbCAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX29wdGlvbnMubmV3bGluZV9iZXR3ZWVuX3J1bGVzICYmIGluc2lkZVJ1bGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX291dHB1dC5wcmV2aW91c19saW5lICYmIHRoaXMuX291dHB1dC5wcmV2aW91c19saW5lLml0ZW0oLTEpICE9PSAneycpIHtcbiAgICAgICAgICB0aGlzLl9vdXRwdXQuZW5zdXJlX2VtcHR5X2xpbmVfYWJvdmUoJy8nLCAnLCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuXG4gICAgICAvLyBUaGUgZGlmZmVyZW5jZSBpbiBwcmludF9zdHJpbmcgYW5kIGluZGVudCBvcmRlciBpcyBuZWNlc3NhcnkgdG8gaW5kZW50IHRoZSAneycgY29ycmVjdGx5XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gJ2V4cGFuZCcpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICAgIHRoaXMuX291dHB1dC5zZXRfaW5kZW50KHRoaXMuX2luZGVudExldmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGluc2lkZSBtaXhpbiBhbmQgZmlyc3QgcGFyYW0gaXMgb2JqZWN0XG4gICAgICAgIGlmIChwcmV2aW91c19jaCA9PT0gJygnKSB7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzX2NoICE9PSAnLCcpIHtcbiAgICAgICAgICB0aGlzLmluZGVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICd9Jykge1xuICAgICAgdGhpcy5vdXRkZW50KCk7XG4gICAgICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICBpZiAocHJldmlvdXNfY2ggPT09ICd7Jykge1xuICAgICAgICB0aGlzLl9vdXRwdXQudHJpbSh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluc2lkZVByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgdGhpcy5vdXRkZW50KCk7XG4gICAgICAgIGluc2lkZVByb3BlcnR5VmFsdWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICAgIGluc2lkZVJ1bGUgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLl9uZXN0ZWRMZXZlbCkge1xuICAgICAgICB0aGlzLl9uZXN0ZWRMZXZlbC0tO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVhdFdoaXRlc3BhY2UodHJ1ZSk7XG4gICAgICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKCk7XG5cbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLm5ld2xpbmVfYmV0d2Vlbl9ydWxlcyAmJiAhdGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfYmxhbmtsaW5lKCkpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSAhPT0gJ30nKSB7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJyknKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC50cmltKHRydWUpO1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJleHBhbmRcIikge1xuICAgICAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSBcIjpcIikge1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuTk9OX1NFTUlDT0xPTl9ORVdMSU5FX1BST1BFUlRZLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dC5sb29rQmFjayh0aGlzLk5PTl9TRU1JQ09MT05fTkVXTElORV9QUk9QRVJUWVtpXSkpIHtcbiAgICAgICAgICBpbnNpZGVOb25TZW1pQ29sb25WYWx1ZXMgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgoaW5zaWRlUnVsZSB8fCBlbnRlcmluZ0NvbmRpdGlvbmFsR3JvdXApICYmICEodGhpcy5faW5wdXQubG9va0JhY2soXCImXCIpIHx8IHRoaXMuZm91bmROZXN0ZWRQc2V1ZG9DbGFzcygpKSAmJiAhdGhpcy5faW5wdXQubG9va0JhY2soXCIoXCIpICYmICFpbnNpZGVOb25OZXN0ZWRBdFJ1bGUgJiYgcGFyZW5MZXZlbCA9PT0gMCkge1xuICAgICAgICAvLyAncHJvcGVydHk6IHZhbHVlJyBkZWxpbWl0ZXJcbiAgICAgICAgLy8gd2hpY2ggY291bGQgYmUgaW4gYSBjb25kaXRpb25hbCBncm91cCBxdWVyeVxuXG4gICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKCc6Jyk7XG4gICAgICAgIGlmICghaW5zaWRlUHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgIGluc2lkZVByb3BlcnR5VmFsdWUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSh0cnVlKTtcbiAgICAgICAgICB0aGlzLmluZGVudCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzYXNzL2xlc3MgcGFyZW50IHJlZmVyZW5jZSBkb24ndCB1c2UgYSBzcGFjZVxuICAgICAgICAvLyBzYXNzIG5lc3RlZCBwc2V1ZG8tY2xhc3MgZG9uJ3QgdXNlIGEgc3BhY2VcblxuICAgICAgICAvLyBwcmVzZXJ2ZSBzcGFjZSBiZWZvcmUgcHNldWRvY2xhc3Nlcy9wc2V1ZG9lbGVtZW50cywgYXMgaXQgbWVhbnMgXCJpbiBhbnkgY2hpbGRcIlxuICAgICAgICBpZiAodGhpcy5faW5wdXQubG9va0JhY2soXCIgXCIpKSB7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAvLyBwc2V1ZG8tZWxlbWVudFxuICAgICAgICAgIHRoaXMuX2NoID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKFwiOjpcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcHNldWRvLWNsYXNzXG4gICAgICAgICAgdGhpcy5wcmludF9zdHJpbmcoJzonKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICdcIicgfHwgdGhpcy5fY2ggPT09ICdcXCcnKSB7XG4gICAgICB2YXIgcHJlc2VydmVRdW90ZVNwYWNlID0gcHJldmlvdXNfY2ggPT09ICdcIicgfHwgcHJldmlvdXNfY2ggPT09ICdcXCcnO1xuICAgICAgdGhpcy5wcmVzZXJ2ZVNpbmdsZVNwYWNlKHByZXNlcnZlUXVvdGVTcGFjZSB8fCBpc0FmdGVyU3BhY2UpO1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2ggKyB0aGlzLmVhdFN0cmluZyh0aGlzLl9jaCkpO1xuICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICc7Jykge1xuICAgICAgaW5zaWRlTm9uU2VtaUNvbG9uVmFsdWVzID0gZmFsc2U7XG4gICAgICBpZiAocGFyZW5MZXZlbCA9PT0gMCkge1xuICAgICAgICBpZiAoaW5zaWRlUHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgIHRoaXMub3V0ZGVudCgpO1xuICAgICAgICAgIGluc2lkZVByb3BlcnR5VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbnNpZGVOb25OZXN0ZWRBdFJ1bGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgICAgICB0aGlzLmVhdFdoaXRlc3BhY2UodHJ1ZSk7XG5cbiAgICAgICAgLy8gVGhpcyBtYWludGFpbnMgc2luZ2xlIGxpbmUgY29tbWVudHMgb24gdGhlIHNhbWVcbiAgICAgICAgLy8gbGluZS4gQmxvY2sgY29tbWVudHMgYXJlIGFsc28gYWZmZWN0ZWQsIGJ1dFxuICAgICAgICAvLyBhIG5ldyBsaW5lIGlzIGFsd2F5cyBvdXRwdXQgYmVmb3JlIG9uZSBpbnNpZGVcbiAgICAgICAgLy8gdGhhdCBzZWN0aW9uXG4gICAgICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgIT09ICcvJykge1xuICAgICAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgICAgICB0aGlzLmVhdFdoaXRlc3BhY2UodHJ1ZSk7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICcoJykgeyAvLyBtYXkgYmUgYSB1cmxcbiAgICAgIGlmICh0aGlzLl9pbnB1dC5sb29rQmFjayhcInVybFwiKSkge1xuICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSgpO1xuICAgICAgICBwYXJlbkxldmVsKys7XG4gICAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICAgIHRoaXMuX2NoID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgICBpZiAodGhpcy5fY2ggPT09ICcpJyB8fCB0aGlzLl9jaCA9PT0gJ1wiJyB8fCB0aGlzLl9jaCA9PT0gJ1xcJycpIHtcbiAgICAgICAgICB0aGlzLl9pbnB1dC5iYWNrKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fY2gpIHtcbiAgICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCArIHRoaXMuZWF0U3RyaW5nKCcpJykpO1xuICAgICAgICAgIGlmIChwYXJlbkxldmVsKSB7XG4gICAgICAgICAgICBwYXJlbkxldmVsLS07XG4gICAgICAgICAgICB0aGlzLm91dGRlbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzcGFjZV9uZWVkZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2lucHV0Lmxvb2tCYWNrKFwid2l0aFwiKSkge1xuICAgICAgICAgIC8vIGxvb2sgYmFjayBpcyBub3QgYW4gYWNjdXJhdGUgc29sdXRpb24sIHdlIG5lZWQgdG9rZW5zIHRvIGNvbmZpcm0gd2l0aG91dCB3aGl0ZXNwYWNlc1xuICAgICAgICAgIHNwYWNlX25lZWRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVzZXJ2ZVNpbmdsZVNwYWNlKGlzQWZ0ZXJTcGFjZSB8fCBzcGFjZV9uZWVkZWQpO1xuICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG5cbiAgICAgICAgLy8gaGFuZGxlIHNjc3Mvc2FzcyBtYXBcbiAgICAgICAgaWYgKGluc2lkZVByb3BlcnR5VmFsdWUgJiYgcHJldmlvdXNfY2ggPT09IFwiJFwiICYmIHRoaXMuX29wdGlvbnMuc2VsZWN0b3Jfc2VwYXJhdG9yX25ld2xpbmUpIHtcbiAgICAgICAgICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICAgICAgaW5zaWRlU2Nzc01hcCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgcGFyZW5MZXZlbCsrO1xuICAgICAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnKScpIHtcbiAgICAgIGlmIChwYXJlbkxldmVsKSB7XG4gICAgICAgIHBhcmVuTGV2ZWwtLTtcbiAgICAgICAgdGhpcy5vdXRkZW50KCk7XG4gICAgICB9XG4gICAgICBpZiAoaW5zaWRlU2Nzc01hcCAmJiB0aGlzLl9pbnB1dC5wZWVrKCkgPT09IFwiO1wiICYmIHRoaXMuX29wdGlvbnMuc2VsZWN0b3Jfc2VwYXJhdG9yX25ld2xpbmUpIHtcbiAgICAgICAgaW5zaWRlU2Nzc01hcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm91dGRlbnQoKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICcsJykge1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuc2VsZWN0b3Jfc2VwYXJhdG9yX25ld2xpbmUgJiYgKCFpbnNpZGVQcm9wZXJ0eVZhbHVlIHx8IGluc2lkZVNjc3NNYXApICYmIHBhcmVuTGV2ZWwgPT09IDAgJiYgIWluc2lkZU5vbk5lc3RlZEF0UnVsZSkge1xuICAgICAgICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCh0aGlzLl9jaCA9PT0gJz4nIHx8IHRoaXMuX2NoID09PSAnKycgfHwgdGhpcy5fY2ggPT09ICd+JykgJiYgIWluc2lkZVByb3BlcnR5VmFsdWUgJiYgcGFyZW5MZXZlbCA9PT0gMCkge1xuICAgICAgLy9oYW5kbGUgY29tYmluYXRvciBzcGFjaW5nXG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5zcGFjZV9hcm91bmRfY29tYmluYXRvcikge1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKCk7XG4gICAgICAgIC8vIHNxdWFzaCBleHRyYSB3aGl0ZXNwYWNlXG4gICAgICAgIGlmICh0aGlzLl9jaCAmJiB3aGl0ZXNwYWNlQ2hhci50ZXN0KHRoaXMuX2NoKSkge1xuICAgICAgICAgIHRoaXMuX2NoID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnXScpIHtcbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnWycpIHtcbiAgICAgIHRoaXMucHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpO1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICc9JykgeyAvLyBubyB3aGl0ZXNwYWNlIGJlZm9yZSBvciBhZnRlclxuICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKCk7XG4gICAgICB0aGlzLnByaW50X3N0cmluZygnPScpO1xuICAgICAgaWYgKHdoaXRlc3BhY2VDaGFyLnRlc3QodGhpcy5fY2gpKSB7XG4gICAgICAgIHRoaXMuX2NoID0gJyc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJyEnICYmICF0aGlzLl9pbnB1dC5sb29rQmFjayhcIlxcXFxcIikpIHsgLy8gIWltcG9ydGFudFxuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmVzZXJ2ZUFmdGVyU3BhY2UgPSBwcmV2aW91c19jaCA9PT0gJ1wiJyB8fCBwcmV2aW91c19jaCA9PT0gJ1xcJyc7XG4gICAgICB0aGlzLnByZXNlcnZlU2luZ2xlU3BhY2UocHJlc2VydmVBZnRlclNwYWNlIHx8IGlzQWZ0ZXJTcGFjZSk7XG4gICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG5cbiAgICAgIGlmICghdGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpICYmIHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJ1xcbicgJiYgaW5zaWRlTm9uU2VtaUNvbG9uVmFsdWVzKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgc3dlZXRDb2RlID0gdGhpcy5fb3V0cHV0LmdldF9jb2RlKGVvbCk7XG5cbiAgcmV0dXJuIHN3ZWV0Q29kZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLkJlYXV0aWZpZXIgPSBCZWF1dGlmaWVyO1xuXG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBCYXNlT3B0aW9ucyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLk9wdGlvbnMpO1xuXG5mdW5jdGlvbiBPcHRpb25zKG9wdGlvbnMpIHtcbiAgQmFzZU9wdGlvbnMuY2FsbCh0aGlzLCBvcHRpb25zLCAnY3NzJyk7XG5cbiAgdGhpcy5zZWxlY3Rvcl9zZXBhcmF0b3JfbmV3bGluZSA9IHRoaXMuX2dldF9ib29sZWFuKCdzZWxlY3Rvcl9zZXBhcmF0b3JfbmV3bGluZScsIHRydWUpO1xuICB0aGlzLm5ld2xpbmVfYmV0d2Vlbl9ydWxlcyA9IHRoaXMuX2dldF9ib29sZWFuKCduZXdsaW5lX2JldHdlZW5fcnVsZXMnLCB0cnVlKTtcbiAgdmFyIHNwYWNlX2Fyb3VuZF9zZWxlY3Rvcl9zZXBhcmF0b3IgPSB0aGlzLl9nZXRfYm9vbGVhbignc3BhY2VfYXJvdW5kX3NlbGVjdG9yX3NlcGFyYXRvcicpO1xuICB0aGlzLnNwYWNlX2Fyb3VuZF9jb21iaW5hdG9yID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3NwYWNlX2Fyb3VuZF9jb21iaW5hdG9yJykgfHwgc3BhY2VfYXJvdW5kX3NlbGVjdG9yX3NlcGFyYXRvcjtcblxuICB2YXIgYnJhY2Vfc3R5bGVfc3BsaXQgPSB0aGlzLl9nZXRfc2VsZWN0aW9uX2xpc3QoJ2JyYWNlX3N0eWxlJywgWydjb2xsYXBzZScsICdleHBhbmQnLCAnZW5kLWV4cGFuZCcsICdub25lJywgJ3ByZXNlcnZlLWlubGluZSddKTtcbiAgdGhpcy5icmFjZV9zdHlsZSA9ICdjb2xsYXBzZSc7XG4gIGZvciAodmFyIGJzID0gMDsgYnMgPCBicmFjZV9zdHlsZV9zcGxpdC5sZW5ndGg7IGJzKyspIHtcbiAgICBpZiAoYnJhY2Vfc3R5bGVfc3BsaXRbYnNdICE9PSAnZXhwYW5kJykge1xuICAgICAgLy8gZGVmYXVsdCB0byBjb2xsYXBzZSwgYXMgb25seSBjb2xsYXBzZXxleHBhbmQgaXMgaW1wbGVtZW50ZWQgZm9yIG5vd1xuICAgICAgdGhpcy5icmFjZV9zdHlsZSA9ICdjb2xsYXBzZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYnJhY2Vfc3R5bGUgPSBicmFjZV9zdHlsZV9zcGxpdFtic107XG4gICAgfVxuICB9XG59XG5PcHRpb25zLnByb3RvdHlwZSA9IG5ldyBCYXNlT3B0aW9ucygpO1xuXG5cblxubW9kdWxlLmV4cG9ydHMuT3B0aW9ucyA9IE9wdGlvbnM7XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIFx0XSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHQvLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuLyoqKioqKi8gXHRsZWdhY3lfYmVhdXRpZnlfY3NzID0gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIFx0XG4vKioqKioqLyB9KSgpXG47XG52YXIgY3NzX2JlYXV0aWZ5ID0gbGVnYWN5X2JlYXV0aWZ5X2Nzcztcbi8qIEZvb3RlciAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIEFNRCAoIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTUQjZGVmaW5lYW1kLXByb3BlcnR5LSApXG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNzc19iZWF1dGlmeTogY3NzX2JlYXV0aWZ5XG4gICAgICAgIH07XG4gICAgfSk7XG59IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIENvbW1vbkpTLiBKdXN0IHB1dCB0aGlzIGZpbGUgc29tZXdoZXJlIG9uIHlvdXIgcmVxdWlyZS5wYXRoc1xuICAgIC8vIGFuZCB5b3Ugd2lsbCBiZSBhYmxlIHRvIGB2YXIgaHRtbF9iZWF1dGlmeSA9IHJlcXVpcmUoXCJiZWF1dGlmeVwiKS5odG1sX2JlYXV0aWZ5YC5cbiAgICBleHBvcnRzLmNzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeTtcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIElmIHdlJ3JlIHJ1bm5pbmcgYSB3ZWIgcGFnZSBhbmQgZG9uJ3QgaGF2ZSBlaXRoZXIgb2YgdGhlIGFib3ZlLCBhZGQgb3VyIG9uZSBnbG9iYWxcbiAgICB3aW5kb3cuY3NzX2JlYXV0aWZ5ID0gY3NzX2JlYXV0aWZ5O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgZXZlbiBoYXZlIHdpbmRvdywgdHJ5IGdsb2JhbC5cbiAgICBnbG9iYWwuY3NzX2JlYXV0aWZ5ID0gY3NzX2JlYXV0aWZ5O1xufVxuXG59KCkpO1xuIl0sIm5hbWVzIjpbImxlZ2FjeV9iZWF1dGlmeV9jc3MiLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwibW9kdWxlIiwiT3V0cHV0TGluZSIsInBhcmVudCIsIl9fcGFyZW50IiwiX19jaGFyYWN0ZXJfY291bnQiLCJfX2luZGVudF9jb3VudCIsIl9fYWxpZ25tZW50X2NvdW50IiwiX193cmFwX3BvaW50X2luZGV4IiwiX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudCIsIl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQiLCJfX3dyYXBfcG9pbnRfYWxpZ25tZW50X2NvdW50IiwiX19pdGVtcyIsInByb3RvdHlwZSIsImNsb25lX2VtcHR5IiwibGluZSIsInNldF9pbmRlbnQiLCJpdGVtIiwiaW5kZXgiLCJsZW5ndGgiLCJoYXNfbWF0Y2giLCJwYXR0ZXJuIiwibGFzdENoZWNrZWRPdXRwdXQiLCJtYXRjaCIsImluZGVudCIsImFsaWdubWVudCIsImlzX2VtcHR5IiwiZ2V0X2luZGVudF9zaXplIiwiX3NldF93cmFwX3BvaW50Iiwid3JhcF9saW5lX2xlbmd0aCIsIm5leHRfbGluZSIsIl9zaG91bGRfd3JhcCIsIl9hbGxvd193cmFwIiwiYWRkX25ld19saW5lIiwibmV4dCIsImN1cnJlbnRfbGluZSIsInNsaWNlIiwic3BsaWNlIiwibGFzdCIsInB1c2giLCJsYXN0X25ld2xpbmVfaW5kZXgiLCJsYXN0SW5kZXhPZiIsInBvcCIsIl9yZW1vdmVfaW5kZW50IiwiaW5kZW50X3NpemUiLCJfcmVtb3ZlX3dyYXBfaW5kZW50IiwidHJpbSIsInRvU3RyaW5nIiwicmVzdWx0IiwiaW5kZW50X2VtcHR5X2xpbmVzIiwiZ2V0X2luZGVudF9zdHJpbmciLCJqb2luIiwiSW5kZW50U3RyaW5nQ2FjaGUiLCJvcHRpb25zIiwiYmFzZUluZGVudFN0cmluZyIsIl9fY2FjaGUiLCJfX2luZGVudF9zaXplIiwiX19pbmRlbnRfc3RyaW5nIiwiaW5kZW50X2NoYXIiLCJpbmRlbnRfd2l0aF90YWJzIiwiQXJyYXkiLCJpbmRlbnRfbGV2ZWwiLCJfX2Jhc2Vfc3RyaW5nIiwiX19iYXNlX3N0cmluZ19sZW5ndGgiLCJjb2x1bW4iLCJfX2Vuc3VyZV9jYWNoZSIsIl9fYWRkX2NvbHVtbiIsIk1hdGgiLCJmbG9vciIsIk91dHB1dCIsIl9faW5kZW50X2NhY2hlIiwicmF3IiwiX2VuZF93aXRoX25ld2xpbmUiLCJlbmRfd2l0aF9uZXdsaW5lIiwiX19saW5lcyIsInByZXZpb3VzX2xpbmUiLCJzcGFjZV9iZWZvcmVfdG9rZW4iLCJub25fYnJlYWtpbmdfc3BhY2UiLCJwcmV2aW91c190b2tlbl93cmFwcGVkIiwiX19hZGRfb3V0cHV0bGluZSIsImdldF9saW5lX251bWJlciIsImZvcmNlX25ld2xpbmUiLCJqdXN0X2FkZGVkX25ld2xpbmUiLCJnZXRfY29kZSIsImVvbCIsImxhc3RfaXRlbSIsInJlcGxhY2UiLCJzd2VldF9jb2RlIiwic2V0X3dyYXBfcG9pbnQiLCJhZGRfcmF3X3Rva2VuIiwidG9rZW4iLCJ4IiwibmV3bGluZXMiLCJ3aGl0ZXNwYWNlX2JlZm9yZSIsInRleHQiLCJhZGRfdG9rZW4iLCJwcmludGFibGVfdG9rZW4iLCJfX2FkZF9zcGFjZV9iZWZvcmVfdG9rZW4iLCJyZW1vdmVfaW5kZW50Iiwib3V0cHV0X2xlbmd0aCIsImVhdF9uZXdsaW5lcyIsInVuZGVmaW5lZCIsImp1c3RfYWRkZWRfYmxhbmtsaW5lIiwiZW5zdXJlX2VtcHR5X2xpbmVfYWJvdmUiLCJzdGFydHNfd2l0aCIsImVuZHNfd2l0aCIsInBvdGVudGlhbEVtcHR5TGluZSIsImluZGV4T2YiLCJleHBvcnRzIiwiT3B0aW9ucyIsIm1lcmdlX2NoaWxkX2ZpZWxkIiwicmF3X29wdGlvbnMiLCJfbWVyZ2VPcHRzIiwiZGlzYWJsZWQiLCJfZ2V0X2Jvb2xlYW4iLCJfZ2V0X2NoYXJhY3RlcnMiLCJfZ2V0X251bWJlciIsInByZXNlcnZlX25ld2xpbmVzIiwibWF4X3ByZXNlcnZlX25ld2xpbmVzIiwidGVtcGxhdGluZyIsIl9nZXRfc2VsZWN0aW9uX2xpc3QiLCJfZ2V0X2FycmF5IiwibmFtZSIsImRlZmF1bHRfdmFsdWUiLCJvcHRpb25fdmFsdWUiLCJjb25jYXQiLCJzcGxpdCIsInBhcnNlSW50IiwiaXNOYU4iLCJfZ2V0X3NlbGVjdGlvbiIsInNlbGVjdGlvbl9saXN0IiwiRXJyb3IiLCJfaXNfdmFsaWRfc2VsZWN0aW9uIiwic29tZSIsImFsbE9wdGlvbnMiLCJjaGlsZEZpZWxkTmFtZSIsImZpbmFsT3B0cyIsIl9ub3JtYWxpemVPcHRzIiwiY29udmVydGVkT3B0cyIsImtleSIsIm5ld0tleSIsIm5vcm1hbGl6ZU9wdHMiLCJtZXJnZU9wdHMiLCJyZWdleHBfaGFzX3N0aWNreSIsIlJlZ0V4cCIsImhhc093blByb3BlcnR5IiwiSW5wdXRTY2FubmVyIiwiaW5wdXRfc3RyaW5nIiwiX19pbnB1dCIsIl9faW5wdXRfbGVuZ3RoIiwiX19wb3NpdGlvbiIsInJlc3RhcnQiLCJiYWNrIiwiaGFzTmV4dCIsInZhbCIsImNoYXJBdCIsInBlZWsiLCJfX21hdGNoIiwibGFzdEluZGV4IiwicGF0dGVybl9tYXRjaCIsImV4ZWMiLCJzdGlja3kiLCJ0ZXN0IiwidGVzdENoYXIiLCJyZWFkIiwic3RhcnRpbmdfcGF0dGVybiIsInVudGlsX3BhdHRlcm4iLCJ1bnRpbF9hZnRlciIsInJlYWRVbnRpbCIsIm1hdGNoX2luZGV4Iiwic3Vic3RyaW5nIiwicmVhZFVudGlsQWZ0ZXIiLCJnZXRfcmVnZXhwIiwibWF0Y2hfZnJvbSIsImZsYWdzIiwic291cmNlIiwiZ2V0X2xpdGVyYWxfcmVnZXhwIiwibGl0ZXJhbF9zdHJpbmciLCJwZWVrVW50aWxBZnRlciIsInN0YXJ0IiwibG9va0JhY2siLCJ0ZXN0VmFsIiwidG9Mb3dlckNhc2UiLCJEaXJlY3RpdmVzIiwic3RhcnRfYmxvY2tfcGF0dGVybiIsImVuZF9ibG9ja19wYXR0ZXJuIiwiX19kaXJlY3RpdmVzX2Jsb2NrX3BhdHRlcm4iLCJfX2RpcmVjdGl2ZV9wYXR0ZXJuIiwiX19kaXJlY3RpdmVzX2VuZF9pZ25vcmVfcGF0dGVybiIsImdldF9kaXJlY3RpdmVzIiwiZGlyZWN0aXZlcyIsImRpcmVjdGl2ZV9tYXRjaCIsInJlYWRJZ25vcmVkIiwiaW5wdXQiLCJfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiQmVhdXRpZmllciIsImNzc19iZWF1dGlmeSIsInNvdXJjZV90ZXh0IiwiYmVhdXRpZmllciIsImJlYXV0aWZ5IiwiZGVmYXVsdE9wdGlvbnMiLCJkaXJlY3RpdmVzX2NvcmUiLCJsaW5lQnJlYWsiLCJhbGxMaW5lQnJlYWtzIiwid2hpdGVzcGFjZUNoYXIiLCJ3aGl0ZXNwYWNlUGF0dGVybiIsImJsb2NrX2NvbW1lbnRfcGF0dGVybiIsImNvbW1lbnRfcGF0dGVybiIsIl9zb3VyY2VfdGV4dCIsIl9vcHRpb25zIiwiX2NoIiwiX2lucHV0IiwiTkVTVEVEX0FUX1JVTEUiLCJDT05ESVRJT05BTF9HUk9VUF9SVUxFIiwiTk9OX1NFTUlDT0xPTl9ORVdMSU5FX1BST1BFUlRZIiwiZWF0U3RyaW5nIiwiZW5kQ2hhcnMiLCJlYXRXaGl0ZXNwYWNlIiwiYWxsb3dBdExlYXN0T25lTmV3TGluZSIsIm5ld2xpbmVfY291bnQiLCJfb3V0cHV0IiwiZm91bmROZXN0ZWRQc2V1ZG9DbGFzcyIsIm9wZW5QYXJlbiIsImkiLCJjaCIsInByaW50X3N0cmluZyIsIm91dHB1dF9zdHJpbmciLCJfaW5kZW50TGV2ZWwiLCJwcmVzZXJ2ZVNpbmdsZVNwYWNlIiwiaXNBZnRlclNwYWNlIiwib3V0ZGVudCIsIl9uZXN0ZWRMZXZlbCIsInBhcmVuTGV2ZWwiLCJpbnNpZGVSdWxlIiwiaW5zaWRlUHJvcGVydHlWYWx1ZSIsImVudGVyaW5nQ29uZGl0aW9uYWxHcm91cCIsImluc2lkZU5vbk5lc3RlZEF0UnVsZSIsImluc2lkZVNjc3NNYXAiLCJ0b3BDaGFyYWN0ZXIiLCJpbnNpZGVOb25TZW1pQ29sb25WYWx1ZXMiLCJ3aGl0ZXNwYWNlIiwicHJldmlvdXNfY2giLCJjb21tZW50IiwiaWdub3JlIiwidmFyaWFibGUiLCJ2YXJpYWJsZU9yUnVsZSIsIm5ld2xpbmVfYmV0d2Vlbl9ydWxlcyIsImJyYWNlX3N0eWxlIiwicHJlc2VydmVRdW90ZVNwYWNlIiwic3BhY2VfbmVlZGVkIiwic2VsZWN0b3Jfc2VwYXJhdG9yX25ld2xpbmUiLCJzcGFjZV9hcm91bmRfY29tYmluYXRvciIsInByZXNlcnZlQWZ0ZXJTcGFjZSIsInN3ZWV0Q29kZSIsIkJhc2VPcHRpb25zIiwiY2FsbCIsInNwYWNlX2Fyb3VuZF9zZWxlY3Rvcl9zZXBhcmF0b3IiLCJicmFjZV9zdHlsZV9zcGxpdCIsImJzIiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwibW9kdWxlSWQiLCJjYWNoZWRNb2R1bGUiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiZGVmaW5lIiwiYW1kIiwid2luZG93IiwiZ2xvYmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/js-beautify/js/lib/beautify-css.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/js-beautify/js/lib/beautify-html.js":
/*!**********************************************************!*\
  !*** ./node_modules/js-beautify/js/lib/beautify-html.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/* AUTO-GENERATED. DO NOT MODIFY. */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n\n Style HTML\n---------------\n\n  Written by Nochum Sossonko, (nsossonko@hotmail.com)\n\n  Based on code initially developed by: Einar Lielmanis, <einar@beautifier.io>\n    https://beautifier.io/\n\n  Usage:\n    style_html(html_source);\n\n    style_html(html_source, options);\n\n  The options are:\n    indent_inner_html (default false)  — indent <head> and <body> sections,\n    indent_size (default 4)          — indentation size,\n    indent_char (default space)      — character to indent with,\n    wrap_line_length (default 250)            -  maximum amount of characters per line (0 = disable)\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\" | \"none\"\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.\n    inline (defaults to inline tags) - list of tags to be considered inline tags\n    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted\n    content_unformatted (defaults to [\"pre\", \"textarea\"] tags) - list of tags, whose content shouldn't be reformatted\n    indent_scripts (default normal)  - \"keep\"|\"separate\"|\"normal\"\n    preserve_newlines (default true) - whether existing line breaks before elements should be preserved\n                                        Only works before elements, not inside tags or for text.\n    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk\n    indent_handlebars (default false) - format and indent {{#foo}} and {{/foo}}\n    end_with_newline (false)          - end with a newline\n    extra_liners (default [head,body,/html]) -List of tags that should have an extra newline before them.\n\n    e.g.\n\n    style_html(html_source, {\n      'indent_inner_html': false,\n      'indent_size': 2,\n      'indent_char': ' ',\n      'wrap_line_length': 78,\n      'brace_style': 'expand',\n      'preserve_newlines': true,\n      'max_preserve_newlines': 5,\n      'indent_handlebars': false,\n      'extra_liners': ['/html']\n    });\n*/ (function() {\n    /* GENERATED_BUILD_OUTPUT */ var legacy_beautify_html;\n    /******/ (function() {\n        /******/ \"use strict\";\n        /******/ var __webpack_modules__ = [\n            ,\n            ,\n            /* 2 */ /***/ function(module) {\n                /*jshint node:true */ /*\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function OutputLine(parent) {\n                    this.__parent = parent;\n                    this.__character_count = 0;\n                    // use indent_count as a marker for this.__lines that have preserved indentation\n                    this.__indent_count = -1;\n                    this.__alignment_count = 0;\n                    this.__wrap_point_index = 0;\n                    this.__wrap_point_character_count = 0;\n                    this.__wrap_point_indent_count = -1;\n                    this.__wrap_point_alignment_count = 0;\n                    this.__items = [];\n                }\n                OutputLine.prototype.clone_empty = function() {\n                    var line = new OutputLine(this.__parent);\n                    line.set_indent(this.__indent_count, this.__alignment_count);\n                    return line;\n                };\n                OutputLine.prototype.item = function(index) {\n                    if (index < 0) {\n                        return this.__items[this.__items.length + index];\n                    } else {\n                        return this.__items[index];\n                    }\n                };\n                OutputLine.prototype.has_match = function(pattern) {\n                    for(var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--){\n                        if (this.__items[lastCheckedOutput].match(pattern)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n                OutputLine.prototype.set_indent = function(indent, alignment) {\n                    if (this.is_empty()) {\n                        this.__indent_count = indent || 0;\n                        this.__alignment_count = alignment || 0;\n                        this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);\n                    }\n                };\n                OutputLine.prototype._set_wrap_point = function() {\n                    if (this.__parent.wrap_line_length) {\n                        this.__wrap_point_index = this.__items.length;\n                        this.__wrap_point_character_count = this.__character_count;\n                        this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;\n                        this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;\n                    }\n                };\n                OutputLine.prototype._should_wrap = function() {\n                    return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;\n                };\n                OutputLine.prototype._allow_wrap = function() {\n                    if (this._should_wrap()) {\n                        this.__parent.add_new_line();\n                        var next = this.__parent.current_line;\n                        next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);\n                        next.__items = this.__items.slice(this.__wrap_point_index);\n                        this.__items = this.__items.slice(0, this.__wrap_point_index);\n                        next.__character_count += this.__character_count - this.__wrap_point_character_count;\n                        this.__character_count = this.__wrap_point_character_count;\n                        if (next.__items[0] === \" \") {\n                            next.__items.splice(0, 1);\n                            next.__character_count -= 1;\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                OutputLine.prototype.is_empty = function() {\n                    return this.__items.length === 0;\n                };\n                OutputLine.prototype.last = function() {\n                    if (!this.is_empty()) {\n                        return this.__items[this.__items.length - 1];\n                    } else {\n                        return null;\n                    }\n                };\n                OutputLine.prototype.push = function(item) {\n                    this.__items.push(item);\n                    var last_newline_index = item.lastIndexOf(\"\\n\");\n                    if (last_newline_index !== -1) {\n                        this.__character_count = item.length - last_newline_index;\n                    } else {\n                        this.__character_count += item.length;\n                    }\n                };\n                OutputLine.prototype.pop = function() {\n                    var item = null;\n                    if (!this.is_empty()) {\n                        item = this.__items.pop();\n                        this.__character_count -= item.length;\n                    }\n                    return item;\n                };\n                OutputLine.prototype._remove_indent = function() {\n                    if (this.__indent_count > 0) {\n                        this.__indent_count -= 1;\n                        this.__character_count -= this.__parent.indent_size;\n                    }\n                };\n                OutputLine.prototype._remove_wrap_indent = function() {\n                    if (this.__wrap_point_indent_count > 0) {\n                        this.__wrap_point_indent_count -= 1;\n                    }\n                };\n                OutputLine.prototype.trim = function() {\n                    while(this.last() === \" \"){\n                        this.__items.pop();\n                        this.__character_count -= 1;\n                    }\n                };\n                OutputLine.prototype.toString = function() {\n                    var result = \"\";\n                    if (this.is_empty()) {\n                        if (this.__parent.indent_empty_lines) {\n                            result = this.__parent.get_indent_string(this.__indent_count);\n                        }\n                    } else {\n                        result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);\n                        result += this.__items.join(\"\");\n                    }\n                    return result;\n                };\n                function IndentStringCache(options, baseIndentString) {\n                    this.__cache = [\n                        \"\"\n                    ];\n                    this.__indent_size = options.indent_size;\n                    this.__indent_string = options.indent_char;\n                    if (!options.indent_with_tabs) {\n                        this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);\n                    }\n                    // Set to null to continue support for auto detection of base indent\n                    baseIndentString = baseIndentString || \"\";\n                    if (options.indent_level > 0) {\n                        baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);\n                    }\n                    this.__base_string = baseIndentString;\n                    this.__base_string_length = baseIndentString.length;\n                }\n                IndentStringCache.prototype.get_indent_size = function(indent, column) {\n                    var result = this.__base_string_length;\n                    column = column || 0;\n                    if (indent < 0) {\n                        result = 0;\n                    }\n                    result += indent * this.__indent_size;\n                    result += column;\n                    return result;\n                };\n                IndentStringCache.prototype.get_indent_string = function(indent_level, column) {\n                    var result = this.__base_string;\n                    column = column || 0;\n                    if (indent_level < 0) {\n                        indent_level = 0;\n                        result = \"\";\n                    }\n                    column += indent_level * this.__indent_size;\n                    this.__ensure_cache(column);\n                    result += this.__cache[column];\n                    return result;\n                };\n                IndentStringCache.prototype.__ensure_cache = function(column) {\n                    while(column >= this.__cache.length){\n                        this.__add_column();\n                    }\n                };\n                IndentStringCache.prototype.__add_column = function() {\n                    var column = this.__cache.length;\n                    var indent = 0;\n                    var result = \"\";\n                    if (this.__indent_size && column >= this.__indent_size) {\n                        indent = Math.floor(column / this.__indent_size);\n                        column -= indent * this.__indent_size;\n                        result = new Array(indent + 1).join(this.__indent_string);\n                    }\n                    if (column) {\n                        result += new Array(column + 1).join(\" \");\n                    }\n                    this.__cache.push(result);\n                };\n                function Output(options, baseIndentString) {\n                    this.__indent_cache = new IndentStringCache(options, baseIndentString);\n                    this.raw = false;\n                    this._end_with_newline = options.end_with_newline;\n                    this.indent_size = options.indent_size;\n                    this.wrap_line_length = options.wrap_line_length;\n                    this.indent_empty_lines = options.indent_empty_lines;\n                    this.__lines = [];\n                    this.previous_line = null;\n                    this.current_line = null;\n                    this.next_line = new OutputLine(this);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = false;\n                    // initialize\n                    this.__add_outputline();\n                }\n                Output.prototype.__add_outputline = function() {\n                    this.previous_line = this.current_line;\n                    this.current_line = this.next_line.clone_empty();\n                    this.__lines.push(this.current_line);\n                };\n                Output.prototype.get_line_number = function() {\n                    return this.__lines.length;\n                };\n                Output.prototype.get_indent_string = function(indent, column) {\n                    return this.__indent_cache.get_indent_string(indent, column);\n                };\n                Output.prototype.get_indent_size = function(indent, column) {\n                    return this.__indent_cache.get_indent_size(indent, column);\n                };\n                Output.prototype.is_empty = function() {\n                    return !this.previous_line && this.current_line.is_empty();\n                };\n                Output.prototype.add_new_line = function(force_newline) {\n                    // never newline at the start of file\n                    // otherwise, newline only if we didn't just add one or we're forced\n                    if (this.is_empty() || !force_newline && this.just_added_newline()) {\n                        return false;\n                    }\n                    // if raw output is enabled, don't print additional newlines,\n                    // but still return True as though you had\n                    if (!this.raw) {\n                        this.__add_outputline();\n                    }\n                    return true;\n                };\n                Output.prototype.get_code = function(eol) {\n                    this.trim(true);\n                    // handle some edge cases where the last tokens\n                    // has text that ends with newline(s)\n                    var last_item = this.current_line.pop();\n                    if (last_item) {\n                        if (last_item[last_item.length - 1] === \"\\n\") {\n                            last_item = last_item.replace(/\\n+$/g, \"\");\n                        }\n                        this.current_line.push(last_item);\n                    }\n                    if (this._end_with_newline) {\n                        this.__add_outputline();\n                    }\n                    var sweet_code = this.__lines.join(\"\\n\");\n                    if (eol !== \"\\n\") {\n                        sweet_code = sweet_code.replace(/[\\n]/g, eol);\n                    }\n                    return sweet_code;\n                };\n                Output.prototype.set_wrap_point = function() {\n                    this.current_line._set_wrap_point();\n                };\n                Output.prototype.set_indent = function(indent, alignment) {\n                    indent = indent || 0;\n                    alignment = alignment || 0;\n                    // Next line stores alignment values\n                    this.next_line.set_indent(indent, alignment);\n                    // Never indent your first output indent at the start of the file\n                    if (this.__lines.length > 1) {\n                        this.current_line.set_indent(indent, alignment);\n                        return true;\n                    }\n                    this.current_line.set_indent();\n                    return false;\n                };\n                Output.prototype.add_raw_token = function(token) {\n                    for(var x = 0; x < token.newlines; x++){\n                        this.__add_outputline();\n                    }\n                    this.current_line.set_indent(-1);\n                    this.current_line.push(token.whitespace_before);\n                    this.current_line.push(token.text);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = false;\n                };\n                Output.prototype.add_token = function(printable_token) {\n                    this.__add_space_before_token();\n                    this.current_line.push(printable_token);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = this.current_line._allow_wrap();\n                };\n                Output.prototype.__add_space_before_token = function() {\n                    if (this.space_before_token && !this.just_added_newline()) {\n                        if (!this.non_breaking_space) {\n                            this.set_wrap_point();\n                        }\n                        this.current_line.push(\" \");\n                    }\n                };\n                Output.prototype.remove_indent = function(index) {\n                    var output_length = this.__lines.length;\n                    while(index < output_length){\n                        this.__lines[index]._remove_indent();\n                        index++;\n                    }\n                    this.current_line._remove_wrap_indent();\n                };\n                Output.prototype.trim = function(eat_newlines) {\n                    eat_newlines = eat_newlines === undefined ? false : eat_newlines;\n                    this.current_line.trim();\n                    while(eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()){\n                        this.__lines.pop();\n                        this.current_line = this.__lines[this.__lines.length - 1];\n                        this.current_line.trim();\n                    }\n                    this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;\n                };\n                Output.prototype.just_added_newline = function() {\n                    return this.current_line.is_empty();\n                };\n                Output.prototype.just_added_blankline = function() {\n                    return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();\n                };\n                Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {\n                    var index = this.__lines.length - 2;\n                    while(index >= 0){\n                        var potentialEmptyLine = this.__lines[index];\n                        if (potentialEmptyLine.is_empty()) {\n                            break;\n                        } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {\n                            this.__lines.splice(index + 1, 0, new OutputLine(this));\n                            this.previous_line = this.__lines[this.__lines.length - 2];\n                            break;\n                        }\n                        index--;\n                    }\n                };\n                module.exports.Output = Output;\n            /***/ },\n            /* 3 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Token(type, text, newlines, whitespace_before) {\n                    this.type = type;\n                    this.text = text;\n                    // comments_before are\n                    // comments that have a new line before them\n                    // and may or may not have a newline after\n                    // this is a set of comments before\n                    this.comments_before = null; /* inline comment*/ \n                    // this.comments_after =  new TokenStream(); // no new line before and newline after\n                    this.newlines = newlines || 0;\n                    this.whitespace_before = whitespace_before || \"\";\n                    this.parent = null;\n                    this.next = null;\n                    this.previous = null;\n                    this.opened = null;\n                    this.closed = null;\n                    this.directives = null;\n                }\n                module.exports.Token = Token;\n            /***/ },\n            ,\n            ,\n            /* 6 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Options(options, merge_child_field) {\n                    this.raw_options = _mergeOpts(options, merge_child_field);\n                    // Support passing the source text back with no change\n                    this.disabled = this._get_boolean(\"disabled\");\n                    this.eol = this._get_characters(\"eol\", \"auto\");\n                    this.end_with_newline = this._get_boolean(\"end_with_newline\");\n                    this.indent_size = this._get_number(\"indent_size\", 4);\n                    this.indent_char = this._get_characters(\"indent_char\", \" \");\n                    this.indent_level = this._get_number(\"indent_level\");\n                    this.preserve_newlines = this._get_boolean(\"preserve_newlines\", true);\n                    this.max_preserve_newlines = this._get_number(\"max_preserve_newlines\", 32786);\n                    if (!this.preserve_newlines) {\n                        this.max_preserve_newlines = 0;\n                    }\n                    this.indent_with_tabs = this._get_boolean(\"indent_with_tabs\", this.indent_char === \"\t\");\n                    if (this.indent_with_tabs) {\n                        this.indent_char = \"\t\";\n                        // indent_size behavior changed after 1.8.6\n                        // It used to be that indent_size would be\n                        // set to 1 for indent_with_tabs. That is no longer needed and\n                        // actually doesn't make sense - why not use spaces? Further,\n                        // that might produce unexpected behavior - tabs being used\n                        // for single-column alignment. So, when indent_with_tabs is true\n                        // and indent_size is 1, reset indent_size to 4.\n                        if (this.indent_size === 1) {\n                            this.indent_size = 4;\n                        }\n                    }\n                    // Backwards compat with 1.3.x\n                    this.wrap_line_length = this._get_number(\"wrap_line_length\", this._get_number(\"max_char\"));\n                    this.indent_empty_lines = this._get_boolean(\"indent_empty_lines\");\n                    // valid templating languages ['django', 'erb', 'handlebars', 'php', 'smarty', 'angular']\n                    // For now, 'auto' = all off for javascript, all except angular on for html (and inline javascript/css).\n                    // other values ignored\n                    this.templating = this._get_selection_list(\"templating\", [\n                        \"auto\",\n                        \"none\",\n                        \"angular\",\n                        \"django\",\n                        \"erb\",\n                        \"handlebars\",\n                        \"php\",\n                        \"smarty\"\n                    ], [\n                        \"auto\"\n                    ]);\n                }\n                Options.prototype._get_array = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = default_value || [];\n                    if (typeof option_value === \"object\") {\n                        if (option_value !== null && typeof option_value.concat === \"function\") {\n                            result = option_value.concat();\n                        }\n                    } else if (typeof option_value === \"string\") {\n                        result = option_value.split(/[^a-zA-Z0-9_\\/\\-]+/);\n                    }\n                    return result;\n                };\n                Options.prototype._get_boolean = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = option_value === undefined ? !!default_value : !!option_value;\n                    return result;\n                };\n                Options.prototype._get_characters = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = default_value || \"\";\n                    if (typeof option_value === \"string\") {\n                        result = option_value.replace(/\\\\r/, \"\\r\").replace(/\\\\n/, \"\\n\").replace(/\\\\t/, \"\t\");\n                    }\n                    return result;\n                };\n                Options.prototype._get_number = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    default_value = parseInt(default_value, 10);\n                    if (isNaN(default_value)) {\n                        default_value = 0;\n                    }\n                    var result = parseInt(option_value, 10);\n                    if (isNaN(result)) {\n                        result = default_value;\n                    }\n                    return result;\n                };\n                Options.prototype._get_selection = function(name, selection_list, default_value) {\n                    var result = this._get_selection_list(name, selection_list, default_value);\n                    if (result.length !== 1) {\n                        throw new Error(\"Invalid Option Value: The option '\" + name + \"' can only be one of the following values:\\n\" + selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n                    }\n                    return result[0];\n                };\n                Options.prototype._get_selection_list = function(name, selection_list, default_value) {\n                    if (!selection_list || selection_list.length === 0) {\n                        throw new Error(\"Selection list cannot be empty.\");\n                    }\n                    default_value = default_value || [\n                        selection_list[0]\n                    ];\n                    if (!this._is_valid_selection(default_value, selection_list)) {\n                        throw new Error(\"Invalid Default Value!\");\n                    }\n                    var result = this._get_array(name, default_value);\n                    if (!this._is_valid_selection(result, selection_list)) {\n                        throw new Error(\"Invalid Option Value: The option '\" + name + \"' can contain only the following values:\\n\" + selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n                    }\n                    return result;\n                };\n                Options.prototype._is_valid_selection = function(result, selection_list) {\n                    return result.length && selection_list.length && !result.some(function(item) {\n                        return selection_list.indexOf(item) === -1;\n                    });\n                };\n                // merges child options up with the parent options object\n                // Example: obj = {a: 1, b: {a: 2}}\n                //          mergeOpts(obj, 'b')\n                //\n                //          Returns: {a: 2}\n                function _mergeOpts(allOptions, childFieldName) {\n                    var finalOpts = {};\n                    allOptions = _normalizeOpts(allOptions);\n                    var name;\n                    for(name in allOptions){\n                        if (name !== childFieldName) {\n                            finalOpts[name] = allOptions[name];\n                        }\n                    }\n                    //merge in the per type settings for the childFieldName\n                    if (childFieldName && allOptions[childFieldName]) {\n                        for(name in allOptions[childFieldName]){\n                            finalOpts[name] = allOptions[childFieldName][name];\n                        }\n                    }\n                    return finalOpts;\n                }\n                function _normalizeOpts(options) {\n                    var convertedOpts = {};\n                    var key;\n                    for(key in options){\n                        var newKey = key.replace(/-/g, \"_\");\n                        convertedOpts[newKey] = options[key];\n                    }\n                    return convertedOpts;\n                }\n                module.exports.Options = Options;\n                module.exports.normalizeOpts = _normalizeOpts;\n                module.exports.mergeOpts = _mergeOpts;\n            /***/ },\n            ,\n            /* 8 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var regexp_has_sticky = RegExp.prototype.hasOwnProperty(\"sticky\");\n                function InputScanner(input_string) {\n                    this.__input = input_string || \"\";\n                    this.__input_length = this.__input.length;\n                    this.__position = 0;\n                }\n                InputScanner.prototype.restart = function() {\n                    this.__position = 0;\n                };\n                InputScanner.prototype.back = function() {\n                    if (this.__position > 0) {\n                        this.__position -= 1;\n                    }\n                };\n                InputScanner.prototype.hasNext = function() {\n                    return this.__position < this.__input_length;\n                };\n                InputScanner.prototype.next = function() {\n                    var val = null;\n                    if (this.hasNext()) {\n                        val = this.__input.charAt(this.__position);\n                        this.__position += 1;\n                    }\n                    return val;\n                };\n                InputScanner.prototype.peek = function(index) {\n                    var val = null;\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__input_length) {\n                        val = this.__input.charAt(index);\n                    }\n                    return val;\n                };\n                // This is a JavaScript only helper function (not in python)\n                // Javascript doesn't have a match method\n                // and not all implementation support \"sticky\" flag.\n                // If they do not support sticky then both this.match() and this.test() method\n                // must get the match and check the index of the match.\n                // If sticky is supported and set, this method will use it.\n                // Otherwise it will check that global is set, and fall back to the slower method.\n                InputScanner.prototype.__match = function(pattern, index) {\n                    pattern.lastIndex = index;\n                    var pattern_match = pattern.exec(this.__input);\n                    if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {\n                        if (pattern_match.index !== index) {\n                            pattern_match = null;\n                        }\n                    }\n                    return pattern_match;\n                };\n                InputScanner.prototype.test = function(pattern, index) {\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__input_length) {\n                        return !!this.__match(pattern, index);\n                    } else {\n                        return false;\n                    }\n                };\n                InputScanner.prototype.testChar = function(pattern, index) {\n                    // test one character regex match\n                    var val = this.peek(index);\n                    pattern.lastIndex = 0;\n                    return val !== null && pattern.test(val);\n                };\n                InputScanner.prototype.match = function(pattern) {\n                    var pattern_match = this.__match(pattern, this.__position);\n                    if (pattern_match) {\n                        this.__position += pattern_match[0].length;\n                    } else {\n                        pattern_match = null;\n                    }\n                    return pattern_match;\n                };\n                InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {\n                    var val = \"\";\n                    var match;\n                    if (starting_pattern) {\n                        match = this.match(starting_pattern);\n                        if (match) {\n                            val += match[0];\n                        }\n                    }\n                    if (until_pattern && (match || !starting_pattern)) {\n                        val += this.readUntil(until_pattern, until_after);\n                    }\n                    return val;\n                };\n                InputScanner.prototype.readUntil = function(pattern, until_after) {\n                    var val = \"\";\n                    var match_index = this.__position;\n                    pattern.lastIndex = this.__position;\n                    var pattern_match = pattern.exec(this.__input);\n                    if (pattern_match) {\n                        match_index = pattern_match.index;\n                        if (until_after) {\n                            match_index += pattern_match[0].length;\n                        }\n                    } else {\n                        match_index = this.__input_length;\n                    }\n                    val = this.__input.substring(this.__position, match_index);\n                    this.__position = match_index;\n                    return val;\n                };\n                InputScanner.prototype.readUntilAfter = function(pattern) {\n                    return this.readUntil(pattern, true);\n                };\n                InputScanner.prototype.get_regexp = function(pattern, match_from) {\n                    var result = null;\n                    var flags = \"g\";\n                    if (match_from && regexp_has_sticky) {\n                        flags = \"y\";\n                    }\n                    // strings are converted to regexp\n                    if (typeof pattern === \"string\" && pattern !== \"\") {\n                        // result = new RegExp(pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'), flags);\n                        result = new RegExp(pattern, flags);\n                    } else if (pattern) {\n                        result = new RegExp(pattern.source, flags);\n                    }\n                    return result;\n                };\n                InputScanner.prototype.get_literal_regexp = function(literal_string) {\n                    return RegExp(literal_string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"));\n                };\n                /* css beautifier legacy helpers */ InputScanner.prototype.peekUntilAfter = function(pattern) {\n                    var start = this.__position;\n                    var val = this.readUntilAfter(pattern);\n                    this.__position = start;\n                    return val;\n                };\n                InputScanner.prototype.lookBack = function(testVal) {\n                    var start = this.__position - 1;\n                    return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;\n                };\n                module.exports.InputScanner = InputScanner;\n            /***/ },\n            /* 9 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_41702__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var InputScanner = __nested_webpack_require_41702__(8).InputScanner;\n                var Token = __nested_webpack_require_41702__(3).Token;\n                var TokenStream = __nested_webpack_require_41702__(10).TokenStream;\n                var WhitespacePattern = __nested_webpack_require_41702__(11).WhitespacePattern;\n                var TOKEN = {\n                    START: \"TK_START\",\n                    RAW: \"TK_RAW\",\n                    EOF: \"TK_EOF\"\n                };\n                var Tokenizer = function(input_string, options) {\n                    this._input = new InputScanner(input_string);\n                    this._options = options || {};\n                    this.__tokens = null;\n                    this._patterns = {};\n                    this._patterns.whitespace = new WhitespacePattern(this._input);\n                };\n                Tokenizer.prototype.tokenize = function() {\n                    this._input.restart();\n                    this.__tokens = new TokenStream();\n                    this._reset();\n                    var current;\n                    var previous = new Token(TOKEN.START, \"\");\n                    var open_token = null;\n                    var open_stack = [];\n                    var comments = new TokenStream();\n                    while(previous.type !== TOKEN.EOF){\n                        current = this._get_next_token(previous, open_token);\n                        while(this._is_comment(current)){\n                            comments.add(current);\n                            current = this._get_next_token(previous, open_token);\n                        }\n                        if (!comments.isEmpty()) {\n                            current.comments_before = comments;\n                            comments = new TokenStream();\n                        }\n                        current.parent = open_token;\n                        if (this._is_opening(current)) {\n                            open_stack.push(open_token);\n                            open_token = current;\n                        } else if (open_token && this._is_closing(current, open_token)) {\n                            current.opened = open_token;\n                            open_token.closed = current;\n                            open_token = open_stack.pop();\n                            current.parent = open_token;\n                        }\n                        current.previous = previous;\n                        previous.next = current;\n                        this.__tokens.add(current);\n                        previous = current;\n                    }\n                    return this.__tokens;\n                };\n                Tokenizer.prototype._is_first_token = function() {\n                    return this.__tokens.isEmpty();\n                };\n                Tokenizer.prototype._reset = function() {};\n                Tokenizer.prototype._get_next_token = function(previous_token, open_token) {\n                    this._readWhitespace();\n                    var resulting_string = this._input.read(/.+/g);\n                    if (resulting_string) {\n                        return this._create_token(TOKEN.RAW, resulting_string);\n                    } else {\n                        return this._create_token(TOKEN.EOF, \"\");\n                    }\n                };\n                Tokenizer.prototype._is_comment = function(current_token) {\n                    return false;\n                };\n                Tokenizer.prototype._is_opening = function(current_token) {\n                    return false;\n                };\n                Tokenizer.prototype._is_closing = function(current_token, open_token) {\n                    return false;\n                };\n                Tokenizer.prototype._create_token = function(type, text) {\n                    var token = new Token(type, text, this._patterns.whitespace.newline_count, this._patterns.whitespace.whitespace_before_token);\n                    return token;\n                };\n                Tokenizer.prototype._readWhitespace = function() {\n                    return this._patterns.whitespace.read();\n                };\n                module.exports.Tokenizer = Tokenizer;\n                module.exports.TOKEN = TOKEN;\n            /***/ },\n            /* 10 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function TokenStream(parent_token) {\n                    // private\n                    this.__tokens = [];\n                    this.__tokens_length = this.__tokens.length;\n                    this.__position = 0;\n                    this.__parent_token = parent_token;\n                }\n                TokenStream.prototype.restart = function() {\n                    this.__position = 0;\n                };\n                TokenStream.prototype.isEmpty = function() {\n                    return this.__tokens_length === 0;\n                };\n                TokenStream.prototype.hasNext = function() {\n                    return this.__position < this.__tokens_length;\n                };\n                TokenStream.prototype.next = function() {\n                    var val = null;\n                    if (this.hasNext()) {\n                        val = this.__tokens[this.__position];\n                        this.__position += 1;\n                    }\n                    return val;\n                };\n                TokenStream.prototype.peek = function(index) {\n                    var val = null;\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__tokens_length) {\n                        val = this.__tokens[index];\n                    }\n                    return val;\n                };\n                TokenStream.prototype.add = function(token) {\n                    if (this.__parent_token) {\n                        token.parent = this.__parent_token;\n                    }\n                    this.__tokens.push(token);\n                    this.__tokens_length += 1;\n                };\n                module.exports.TokenStream = TokenStream;\n            /***/ },\n            /* 11 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_50236__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Pattern = __nested_webpack_require_50236__(12).Pattern;\n                function WhitespacePattern(input_scanner, parent) {\n                    Pattern.call(this, input_scanner, parent);\n                    if (parent) {\n                        this._line_regexp = this._input.get_regexp(parent._line_regexp);\n                    } else {\n                        this.__set_whitespace_patterns(\"\", \"\");\n                    }\n                    this.newline_count = 0;\n                    this.whitespace_before_token = \"\";\n                }\n                WhitespacePattern.prototype = new Pattern();\n                WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {\n                    whitespace_chars += \"\\\\t \";\n                    newline_chars += \"\\\\n\\\\r\";\n                    this._match_pattern = this._input.get_regexp(\"[\" + whitespace_chars + newline_chars + \"]+\", true);\n                    this._newline_regexp = this._input.get_regexp(\"\\\\r\\\\n|[\" + newline_chars + \"]\");\n                };\n                WhitespacePattern.prototype.read = function() {\n                    this.newline_count = 0;\n                    this.whitespace_before_token = \"\";\n                    var resulting_string = this._input.read(this._match_pattern);\n                    if (resulting_string === \" \") {\n                        this.whitespace_before_token = \" \";\n                    } else if (resulting_string) {\n                        var matches = this.__split(this._newline_regexp, resulting_string);\n                        this.newline_count = matches.length - 1;\n                        this.whitespace_before_token = matches[this.newline_count];\n                    }\n                    return resulting_string;\n                };\n                WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {\n                    var result = this._create();\n                    result.__set_whitespace_patterns(whitespace_chars, newline_chars);\n                    result._update();\n                    return result;\n                };\n                WhitespacePattern.prototype._create = function() {\n                    return new WhitespacePattern(this._input, this);\n                };\n                WhitespacePattern.prototype.__split = function(regexp, input_string) {\n                    regexp.lastIndex = 0;\n                    var start_index = 0;\n                    var result = [];\n                    var next_match = regexp.exec(input_string);\n                    while(next_match){\n                        result.push(input_string.substring(start_index, next_match.index));\n                        start_index = next_match.index + next_match[0].length;\n                        next_match = regexp.exec(input_string);\n                    }\n                    if (start_index < input_string.length) {\n                        result.push(input_string.substring(start_index, input_string.length));\n                    } else {\n                        result.push(\"\");\n                    }\n                    return result;\n                };\n                module.exports.WhitespacePattern = WhitespacePattern;\n            /***/ },\n            /* 12 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Pattern(input_scanner, parent) {\n                    this._input = input_scanner;\n                    this._starting_pattern = null;\n                    this._match_pattern = null;\n                    this._until_pattern = null;\n                    this._until_after = false;\n                    if (parent) {\n                        this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);\n                        this._match_pattern = this._input.get_regexp(parent._match_pattern, true);\n                        this._until_pattern = this._input.get_regexp(parent._until_pattern);\n                        this._until_after = parent._until_after;\n                    }\n                }\n                Pattern.prototype.read = function() {\n                    var result = this._input.read(this._starting_pattern);\n                    if (!this._starting_pattern || result) {\n                        result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);\n                    }\n                    return result;\n                };\n                Pattern.prototype.read_match = function() {\n                    return this._input.match(this._match_pattern);\n                };\n                Pattern.prototype.until_after = function(pattern) {\n                    var result = this._create();\n                    result._until_after = true;\n                    result._until_pattern = this._input.get_regexp(pattern);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype.until = function(pattern) {\n                    var result = this._create();\n                    result._until_after = false;\n                    result._until_pattern = this._input.get_regexp(pattern);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype.starting_with = function(pattern) {\n                    var result = this._create();\n                    result._starting_pattern = this._input.get_regexp(pattern, true);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype.matching = function(pattern) {\n                    var result = this._create();\n                    result._match_pattern = this._input.get_regexp(pattern, true);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype._create = function() {\n                    return new Pattern(this._input, this);\n                };\n                Pattern.prototype._update = function() {};\n                module.exports.Pattern = Pattern;\n            /***/ },\n            /* 13 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Directives(start_block_pattern, end_block_pattern) {\n                    start_block_pattern = typeof start_block_pattern === \"string\" ? start_block_pattern : start_block_pattern.source;\n                    end_block_pattern = typeof end_block_pattern === \"string\" ? end_block_pattern : end_block_pattern.source;\n                    this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \\w+[:]\\w+)+ /.source + end_block_pattern, \"g\");\n                    this.__directive_pattern = / (\\w+)[:](\\w+)/g;\n                    this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\\sbeautify\\signore:end\\s/.source + end_block_pattern, \"g\");\n                }\n                Directives.prototype.get_directives = function(text) {\n                    if (!text.match(this.__directives_block_pattern)) {\n                        return null;\n                    }\n                    var directives = {};\n                    this.__directive_pattern.lastIndex = 0;\n                    var directive_match = this.__directive_pattern.exec(text);\n                    while(directive_match){\n                        directives[directive_match[1]] = directive_match[2];\n                        directive_match = this.__directive_pattern.exec(text);\n                    }\n                    return directives;\n                };\n                Directives.prototype.readIgnored = function(input) {\n                    return input.readUntilAfter(this.__directives_end_ignore_pattern);\n                };\n                module.exports.Directives = Directives;\n            /***/ },\n            /* 14 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_61628__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Pattern = __nested_webpack_require_61628__(12).Pattern;\n                var template_names = {\n                    django: false,\n                    erb: false,\n                    handlebars: false,\n                    php: false,\n                    smarty: false,\n                    angular: false\n                };\n                // This lets templates appear anywhere we would do a readUntil\n                // The cost is higher but it is pay to play.\n                function TemplatablePattern(input_scanner, parent) {\n                    Pattern.call(this, input_scanner, parent);\n                    this.__template_pattern = null;\n                    this._disabled = Object.assign({}, template_names);\n                    this._excluded = Object.assign({}, template_names);\n                    if (parent) {\n                        this.__template_pattern = this._input.get_regexp(parent.__template_pattern);\n                        this._excluded = Object.assign(this._excluded, parent._excluded);\n                        this._disabled = Object.assign(this._disabled, parent._disabled);\n                    }\n                    var pattern = new Pattern(input_scanner);\n                    this.__patterns = {\n                        handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),\n                        handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),\n                        handlebars: pattern.starting_with(/{{/).until_after(/}}/),\n                        php: pattern.starting_with(/<\\?(?:[= ]|php)/).until_after(/\\?>/),\n                        erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),\n                        // django coflicts with handlebars a bit.\n                        django: pattern.starting_with(/{%/).until_after(/%}/),\n                        django_value: pattern.starting_with(/{{/).until_after(/}}/),\n                        django_comment: pattern.starting_with(/{#/).until_after(/#}/),\n                        smarty: pattern.starting_with(/{(?=[^}{\\s\\n])/).until_after(/[^\\s\\n]}/),\n                        smarty_comment: pattern.starting_with(/{\\*/).until_after(/\\*}/),\n                        smarty_literal: pattern.starting_with(/{literal}/).until_after(/{\\/literal}/)\n                    };\n                }\n                TemplatablePattern.prototype = new Pattern();\n                TemplatablePattern.prototype._create = function() {\n                    return new TemplatablePattern(this._input, this);\n                };\n                TemplatablePattern.prototype._update = function() {\n                    this.__set_templated_pattern();\n                };\n                TemplatablePattern.prototype.disable = function(language) {\n                    var result = this._create();\n                    result._disabled[language] = true;\n                    result._update();\n                    return result;\n                };\n                TemplatablePattern.prototype.read_options = function(options) {\n                    var result = this._create();\n                    for(var language in template_names){\n                        result._disabled[language] = options.templating.indexOf(language) === -1;\n                    }\n                    result._update();\n                    return result;\n                };\n                TemplatablePattern.prototype.exclude = function(language) {\n                    var result = this._create();\n                    result._excluded[language] = true;\n                    result._update();\n                    return result;\n                };\n                TemplatablePattern.prototype.read = function() {\n                    var result = \"\";\n                    if (this._match_pattern) {\n                        result = this._input.read(this._starting_pattern);\n                    } else {\n                        result = this._input.read(this._starting_pattern, this.__template_pattern);\n                    }\n                    var next = this._read_template();\n                    while(next){\n                        if (this._match_pattern) {\n                            next += this._input.read(this._match_pattern);\n                        } else {\n                            next += this._input.readUntil(this.__template_pattern);\n                        }\n                        result += next;\n                        next = this._read_template();\n                    }\n                    if (this._until_after) {\n                        result += this._input.readUntilAfter(this._until_pattern);\n                    }\n                    return result;\n                };\n                TemplatablePattern.prototype.__set_templated_pattern = function() {\n                    var items = [];\n                    if (!this._disabled.php) {\n                        items.push(this.__patterns.php._starting_pattern.source);\n                    }\n                    if (!this._disabled.handlebars) {\n                        items.push(this.__patterns.handlebars._starting_pattern.source);\n                    }\n                    if (!this._disabled.erb) {\n                        items.push(this.__patterns.erb._starting_pattern.source);\n                    }\n                    if (!this._disabled.django) {\n                        items.push(this.__patterns.django._starting_pattern.source);\n                        // The starting pattern for django is more complex because it has different\n                        // patterns for value, comment, and other sections\n                        items.push(this.__patterns.django_value._starting_pattern.source);\n                        items.push(this.__patterns.django_comment._starting_pattern.source);\n                    }\n                    if (!this._disabled.smarty) {\n                        items.push(this.__patterns.smarty._starting_pattern.source);\n                    }\n                    if (this._until_pattern) {\n                        items.push(this._until_pattern.source);\n                    }\n                    this.__template_pattern = this._input.get_regexp(\"(?:\" + items.join(\"|\") + \")\");\n                };\n                TemplatablePattern.prototype._read_template = function() {\n                    var resulting_string = \"\";\n                    var c = this._input.peek();\n                    if (c === \"<\") {\n                        var peek1 = this._input.peek(1);\n                        //if we're in a comment, do something special\n                        // We treat all comments as literals, even more than preformatted tags\n                        // we just look for the appropriate close tag\n                        if (!this._disabled.php && !this._excluded.php && peek1 === \"?\") {\n                            resulting_string = resulting_string || this.__patterns.php.read();\n                        }\n                        if (!this._disabled.erb && !this._excluded.erb && peek1 === \"%\") {\n                            resulting_string = resulting_string || this.__patterns.erb.read();\n                        }\n                    } else if (c === \"{\") {\n                        if (!this._disabled.handlebars && !this._excluded.handlebars) {\n                            resulting_string = resulting_string || this.__patterns.handlebars_comment.read();\n                            resulting_string = resulting_string || this.__patterns.handlebars_unescaped.read();\n                            resulting_string = resulting_string || this.__patterns.handlebars.read();\n                        }\n                        if (!this._disabled.django) {\n                            // django coflicts with handlebars a bit.\n                            if (!this._excluded.django && !this._excluded.handlebars) {\n                                resulting_string = resulting_string || this.__patterns.django_value.read();\n                            }\n                            if (!this._excluded.django) {\n                                resulting_string = resulting_string || this.__patterns.django_comment.read();\n                                resulting_string = resulting_string || this.__patterns.django.read();\n                            }\n                        }\n                        if (!this._disabled.smarty) {\n                            // smarty cannot be enabled with django or handlebars enabled\n                            if (this._disabled.django && this._disabled.handlebars) {\n                                resulting_string = resulting_string || this.__patterns.smarty_comment.read();\n                                resulting_string = resulting_string || this.__patterns.smarty_literal.read();\n                                resulting_string = resulting_string || this.__patterns.smarty.read();\n                            }\n                        }\n                    }\n                    return resulting_string;\n                };\n                module.exports.TemplatablePattern = TemplatablePattern;\n            /***/ },\n            ,\n            ,\n            ,\n            /* 18 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_72011__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Beautifier = __nested_webpack_require_72011__(19).Beautifier, Options = __nested_webpack_require_72011__(20).Options;\n                function style_html(html_source, options, js_beautify, css_beautify) {\n                    var beautifier = new Beautifier(html_source, options, js_beautify, css_beautify);\n                    return beautifier.beautify();\n                }\n                module.exports = style_html;\n                module.exports.defaultOptions = function() {\n                    return new Options();\n                };\n            /***/ },\n            /* 19 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_73847__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Options = __nested_webpack_require_73847__(20).Options;\n                var Output = __nested_webpack_require_73847__(2).Output;\n                var Tokenizer = __nested_webpack_require_73847__(21).Tokenizer;\n                var TOKEN = __nested_webpack_require_73847__(21).TOKEN;\n                var lineBreak = /\\r\\n|[\\r\\n]/;\n                var allLineBreaks = /\\r\\n|[\\r\\n]/g;\n                var Printer = function(options, base_indent_string) {\n                    this.indent_level = 0;\n                    this.alignment_size = 0;\n                    this.max_preserve_newlines = options.max_preserve_newlines;\n                    this.preserve_newlines = options.preserve_newlines;\n                    this._output = new Output(options, base_indent_string);\n                };\n                Printer.prototype.current_line_has_match = function(pattern) {\n                    return this._output.current_line.has_match(pattern);\n                };\n                Printer.prototype.set_space_before_token = function(value, non_breaking) {\n                    this._output.space_before_token = value;\n                    this._output.non_breaking_space = non_breaking;\n                };\n                Printer.prototype.set_wrap_point = function() {\n                    this._output.set_indent(this.indent_level, this.alignment_size);\n                    this._output.set_wrap_point();\n                };\n                Printer.prototype.add_raw_token = function(token) {\n                    this._output.add_raw_token(token);\n                };\n                Printer.prototype.print_preserved_newlines = function(raw_token) {\n                    var newlines = 0;\n                    if (raw_token.type !== TOKEN.TEXT && raw_token.previous.type !== TOKEN.TEXT) {\n                        newlines = raw_token.newlines ? 1 : 0;\n                    }\n                    if (this.preserve_newlines) {\n                        newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;\n                    }\n                    for(var n = 0; n < newlines; n++){\n                        this.print_newline(n > 0);\n                    }\n                    return newlines !== 0;\n                };\n                Printer.prototype.traverse_whitespace = function(raw_token) {\n                    if (raw_token.whitespace_before || raw_token.newlines) {\n                        if (!this.print_preserved_newlines(raw_token)) {\n                            this._output.space_before_token = true;\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                Printer.prototype.previous_token_wrapped = function() {\n                    return this._output.previous_token_wrapped;\n                };\n                Printer.prototype.print_newline = function(force) {\n                    this._output.add_new_line(force);\n                };\n                Printer.prototype.print_token = function(token) {\n                    if (token.text) {\n                        this._output.set_indent(this.indent_level, this.alignment_size);\n                        this._output.add_token(token.text);\n                    }\n                };\n                Printer.prototype.indent = function() {\n                    this.indent_level++;\n                };\n                Printer.prototype.deindent = function() {\n                    if (this.indent_level > 0) {\n                        this.indent_level--;\n                        this._output.set_indent(this.indent_level, this.alignment_size);\n                    }\n                };\n                Printer.prototype.get_full_indent = function(level) {\n                    level = this.indent_level + (level || 0);\n                    if (level < 1) {\n                        return \"\";\n                    }\n                    return this._output.get_indent_string(level);\n                };\n                var get_type_attribute = function(start_token) {\n                    var result = null;\n                    var raw_token = start_token.next;\n                    // Search attributes for a type attribute\n                    while(raw_token.type !== TOKEN.EOF && start_token.closed !== raw_token){\n                        if (raw_token.type === TOKEN.ATTRIBUTE && raw_token.text === \"type\") {\n                            if (raw_token.next && raw_token.next.type === TOKEN.EQUALS && raw_token.next.next && raw_token.next.next.type === TOKEN.VALUE) {\n                                result = raw_token.next.next.text;\n                            }\n                            break;\n                        }\n                        raw_token = raw_token.next;\n                    }\n                    return result;\n                };\n                var get_custom_beautifier_name = function(tag_check, raw_token) {\n                    var typeAttribute = null;\n                    var result = null;\n                    if (!raw_token.closed) {\n                        return null;\n                    }\n                    if (tag_check === \"script\") {\n                        typeAttribute = \"text/javascript\";\n                    } else if (tag_check === \"style\") {\n                        typeAttribute = \"text/css\";\n                    }\n                    typeAttribute = get_type_attribute(raw_token) || typeAttribute;\n                    // For script and style tags that have a type attribute, only enable custom beautifiers for matching values\n                    // For those without a type attribute use default;\n                    if (typeAttribute.search(\"text/css\") > -1) {\n                        result = \"css\";\n                    } else if (typeAttribute.search(/module|((text|application|dojo)\\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\\+)?json|method|aspect))/) > -1) {\n                        result = \"javascript\";\n                    } else if (typeAttribute.search(/(text|application|dojo)\\/(x-)?(html)/) > -1) {\n                        result = \"html\";\n                    } else if (typeAttribute.search(/test\\/null/) > -1) {\n                        // Test only mime-type for testing the beautifier when null is passed as beautifing function\n                        result = \"null\";\n                    }\n                    return result;\n                };\n                function in_array(what, arr) {\n                    return arr.indexOf(what) !== -1;\n                }\n                function TagFrame(parent, parser_token, indent_level) {\n                    this.parent = parent || null;\n                    this.tag = parser_token ? parser_token.tag_name : \"\";\n                    this.indent_level = indent_level || 0;\n                    this.parser_token = parser_token || null;\n                }\n                function TagStack(printer) {\n                    this._printer = printer;\n                    this._current_frame = null;\n                }\n                TagStack.prototype.get_parser_token = function() {\n                    return this._current_frame ? this._current_frame.parser_token : null;\n                };\n                TagStack.prototype.record_tag = function(parser_token) {\n                    var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);\n                    this._current_frame = new_frame;\n                };\n                TagStack.prototype._try_pop_frame = function(frame) {\n                    var parser_token = null;\n                    if (frame) {\n                        parser_token = frame.parser_token;\n                        this._printer.indent_level = frame.indent_level;\n                        this._current_frame = frame.parent;\n                    }\n                    return parser_token;\n                };\n                TagStack.prototype._get_frame = function(tag_list, stop_list) {\n                    var frame = this._current_frame;\n                    while(frame){\n                        if (tag_list.indexOf(frame.tag) !== -1) {\n                            break;\n                        } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {\n                            frame = null;\n                            break;\n                        }\n                        frame = frame.parent;\n                    }\n                    return frame;\n                };\n                TagStack.prototype.try_pop = function(tag, stop_list) {\n                    var frame = this._get_frame([\n                        tag\n                    ], stop_list);\n                    return this._try_pop_frame(frame);\n                };\n                TagStack.prototype.indent_to_tag = function(tag_list) {\n                    var frame = this._get_frame(tag_list);\n                    if (frame) {\n                        this._printer.indent_level = frame.indent_level;\n                    }\n                };\n                function Beautifier(source_text, options, js_beautify, css_beautify) {\n                    //Wrapper function to invoke all the necessary constructors and deal with the output.\n                    this._source_text = source_text || \"\";\n                    options = options || {};\n                    this._js_beautify = js_beautify;\n                    this._css_beautify = css_beautify;\n                    this._tag_stack = null;\n                    // Allow the setting of language/file-type specific options\n                    // with inheritance of overall settings\n                    var optionHtml = new Options(options, \"html\");\n                    this._options = optionHtml;\n                    this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, \"force\".length) === \"force\";\n                    this._is_wrap_attributes_force_expand_multiline = this._options.wrap_attributes === \"force-expand-multiline\";\n                    this._is_wrap_attributes_force_aligned = this._options.wrap_attributes === \"force-aligned\";\n                    this._is_wrap_attributes_aligned_multiple = this._options.wrap_attributes === \"aligned-multiple\";\n                    this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, \"preserve\".length) === \"preserve\";\n                    this._is_wrap_attributes_preserve_aligned = this._options.wrap_attributes === \"preserve-aligned\";\n                }\n                Beautifier.prototype.beautify = function() {\n                    // if disabled, return the input unchanged.\n                    if (this._options.disabled) {\n                        return this._source_text;\n                    }\n                    var source_text = this._source_text;\n                    var eol = this._options.eol;\n                    if (this._options.eol === \"auto\") {\n                        eol = \"\\n\";\n                        if (source_text && lineBreak.test(source_text)) {\n                            eol = source_text.match(lineBreak)[0];\n                        }\n                    }\n                    // HACK: newline parsing inconsistent. This brute force normalizes the input.\n                    source_text = source_text.replace(allLineBreaks, \"\\n\");\n                    var baseIndentString = source_text.match(/^[\\t ]*/)[0];\n                    var last_token = {\n                        text: \"\",\n                        type: \"\"\n                    };\n                    var last_tag_token = new TagOpenParserToken();\n                    var printer = new Printer(this._options, baseIndentString);\n                    var tokens = new Tokenizer(source_text, this._options).tokenize();\n                    this._tag_stack = new TagStack(printer);\n                    var parser_token = null;\n                    var raw_token = tokens.next();\n                    while(raw_token.type !== TOKEN.EOF){\n                        if (raw_token.type === TOKEN.TAG_OPEN || raw_token.type === TOKEN.COMMENT) {\n                            parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token, tokens);\n                            last_tag_token = parser_token;\n                        } else if (raw_token.type === TOKEN.ATTRIBUTE || raw_token.type === TOKEN.EQUALS || raw_token.type === TOKEN.VALUE || raw_token.type === TOKEN.TEXT && !last_tag_token.tag_complete) {\n                            parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, last_token);\n                        } else if (raw_token.type === TOKEN.TAG_CLOSE) {\n                            parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);\n                        } else if (raw_token.type === TOKEN.TEXT) {\n                            parser_token = this._handle_text(printer, raw_token, last_tag_token);\n                        } else if (raw_token.type === TOKEN.CONTROL_FLOW_OPEN) {\n                            parser_token = this._handle_control_flow_open(printer, raw_token);\n                        } else if (raw_token.type === TOKEN.CONTROL_FLOW_CLOSE) {\n                            parser_token = this._handle_control_flow_close(printer, raw_token);\n                        } else {\n                            // This should never happen, but if it does. Print the raw token\n                            printer.add_raw_token(raw_token);\n                        }\n                        last_token = parser_token;\n                        raw_token = tokens.next();\n                    }\n                    var sweet_code = printer._output.get_code(eol);\n                    return sweet_code;\n                };\n                Beautifier.prototype._handle_control_flow_open = function(printer, raw_token) {\n                    var parser_token = {\n                        text: raw_token.text,\n                        type: raw_token.type\n                    };\n                    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== \"\", true);\n                    if (raw_token.newlines) {\n                        printer.print_preserved_newlines(raw_token);\n                    } else {\n                        printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== \"\", true);\n                    }\n                    printer.print_token(raw_token);\n                    printer.indent();\n                    return parser_token;\n                };\n                Beautifier.prototype._handle_control_flow_close = function(printer, raw_token) {\n                    var parser_token = {\n                        text: raw_token.text,\n                        type: raw_token.type\n                    };\n                    printer.deindent();\n                    if (raw_token.newlines) {\n                        printer.print_preserved_newlines(raw_token);\n                    } else {\n                        printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== \"\", true);\n                    }\n                    printer.print_token(raw_token);\n                    return parser_token;\n                };\n                Beautifier.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {\n                    var parser_token = {\n                        text: raw_token.text,\n                        type: raw_token.type\n                    };\n                    printer.alignment_size = 0;\n                    last_tag_token.tag_complete = true;\n                    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== \"\", true);\n                    if (last_tag_token.is_unformatted) {\n                        printer.add_raw_token(raw_token);\n                    } else {\n                        if (last_tag_token.tag_start_char === \"<\") {\n                            printer.set_space_before_token(raw_token.text[0] === \"/\", true); // space before />, no space before >\n                            if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {\n                                printer.print_newline(false);\n                            }\n                        }\n                        printer.print_token(raw_token);\n                    }\n                    if (last_tag_token.indent_content && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {\n                        printer.indent();\n                        // only indent once per opened tag\n                        last_tag_token.indent_content = false;\n                    }\n                    if (!last_tag_token.is_inline_element && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {\n                        printer.set_wrap_point();\n                    }\n                    return parser_token;\n                };\n                Beautifier.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, last_token) {\n                    var wrapped = last_tag_token.has_wrapped_attrs;\n                    var parser_token = {\n                        text: raw_token.text,\n                        type: raw_token.type\n                    };\n                    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== \"\", true);\n                    if (last_tag_token.is_unformatted) {\n                        printer.add_raw_token(raw_token);\n                    } else if (last_tag_token.tag_start_char === \"{\" && raw_token.type === TOKEN.TEXT) {\n                        // For the insides of handlebars allow newlines or a single space between open and contents\n                        if (printer.print_preserved_newlines(raw_token)) {\n                            raw_token.newlines = 0;\n                            printer.add_raw_token(raw_token);\n                        } else {\n                            printer.print_token(raw_token);\n                        }\n                    } else {\n                        if (raw_token.type === TOKEN.ATTRIBUTE) {\n                            printer.set_space_before_token(true);\n                        } else if (raw_token.type === TOKEN.EQUALS) {\n                            printer.set_space_before_token(false);\n                        } else if (raw_token.type === TOKEN.VALUE && raw_token.previous.type === TOKEN.EQUALS) {\n                            printer.set_space_before_token(false);\n                        }\n                        if (raw_token.type === TOKEN.ATTRIBUTE && last_tag_token.tag_start_char === \"<\") {\n                            if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {\n                                printer.traverse_whitespace(raw_token);\n                                wrapped = wrapped || raw_token.newlines !== 0;\n                            }\n                            // Wrap for 'force' options, and if the number of attributes is at least that specified in 'wrap_attributes_min_attrs':\n                            // 1. always wrap the second and beyond attributes\n                            // 2. wrap the first attribute only if 'force-expand-multiline' is specified\n                            if (this._is_wrap_attributes_force && last_tag_token.attr_count >= this._options.wrap_attributes_min_attrs && (last_token.type !== TOKEN.TAG_OPEN || // ie. second attribute and beyond\n                            this._is_wrap_attributes_force_expand_multiline)) {\n                                printer.print_newline(false);\n                                wrapped = true;\n                            }\n                        }\n                        printer.print_token(raw_token);\n                        wrapped = wrapped || printer.previous_token_wrapped();\n                        last_tag_token.has_wrapped_attrs = wrapped;\n                    }\n                    return parser_token;\n                };\n                Beautifier.prototype._handle_text = function(printer, raw_token, last_tag_token) {\n                    var parser_token = {\n                        text: raw_token.text,\n                        type: \"TK_CONTENT\"\n                    };\n                    if (last_tag_token.custom_beautifier_name) {\n                        this._print_custom_beatifier_text(printer, raw_token, last_tag_token);\n                    } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {\n                        printer.add_raw_token(raw_token);\n                    } else {\n                        printer.traverse_whitespace(raw_token);\n                        printer.print_token(raw_token);\n                    }\n                    return parser_token;\n                };\n                Beautifier.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {\n                    var local = this;\n                    if (raw_token.text !== \"\") {\n                        var text = raw_token.text, _beautifier, script_indent_level = 1, pre = \"\", post = \"\";\n                        if (last_tag_token.custom_beautifier_name === \"javascript\" && typeof this._js_beautify === \"function\") {\n                            _beautifier = this._js_beautify;\n                        } else if (last_tag_token.custom_beautifier_name === \"css\" && typeof this._css_beautify === \"function\") {\n                            _beautifier = this._css_beautify;\n                        } else if (last_tag_token.custom_beautifier_name === \"html\") {\n                            _beautifier = function(html_source, options) {\n                                var beautifier = new Beautifier(html_source, options, local._js_beautify, local._css_beautify);\n                                return beautifier.beautify();\n                            };\n                        }\n                        if (this._options.indent_scripts === \"keep\") {\n                            script_indent_level = 0;\n                        } else if (this._options.indent_scripts === \"separate\") {\n                            script_indent_level = -printer.indent_level;\n                        }\n                        var indentation = printer.get_full_indent(script_indent_level);\n                        // if there is at least one empty line at the end of this text, strip it\n                        // we'll be adding one back after the text but before the containing tag.\n                        text = text.replace(/\\n[ \\t]*$/, \"\");\n                        // Handle the case where content is wrapped in a comment or cdata.\n                        if (last_tag_token.custom_beautifier_name !== \"html\" && text[0] === \"<\" && text.match(/^(<!--|<!\\[CDATA\\[)/)) {\n                            var matched = /^(<!--[^\\n]*|<!\\[CDATA\\[)(\\n?)([ \\t\\n]*)([\\s\\S]*)(-->|]]>)$/.exec(text);\n                            // if we start to wrap but don't finish, print raw\n                            if (!matched) {\n                                printer.add_raw_token(raw_token);\n                                return;\n                            }\n                            pre = indentation + matched[1] + \"\\n\";\n                            text = matched[4];\n                            if (matched[5]) {\n                                post = indentation + matched[5];\n                            }\n                            // if there is at least one empty line at the end of this text, strip it\n                            // we'll be adding one back after the text but before the containing tag.\n                            text = text.replace(/\\n[ \\t]*$/, \"\");\n                            if (matched[2] || matched[3].indexOf(\"\\n\") !== -1) {\n                                // if the first line of the non-comment text has spaces\n                                // use that as the basis for indenting in null case.\n                                matched = matched[3].match(/[ \\t]+$/);\n                                if (matched) {\n                                    raw_token.whitespace_before = matched[0];\n                                }\n                            }\n                        }\n                        if (text) {\n                            if (_beautifier) {\n                                // call the Beautifier if avaliable\n                                var Child_options = function() {\n                                    this.eol = \"\\n\";\n                                };\n                                Child_options.prototype = this._options.raw_options;\n                                var child_options = new Child_options();\n                                text = _beautifier(indentation + text, child_options);\n                            } else {\n                                // simply indent the string otherwise\n                                var white = raw_token.whitespace_before;\n                                if (white) {\n                                    text = text.replace(new RegExp(\"\\n(\" + white + \")?\", \"g\"), \"\\n\");\n                                }\n                                text = indentation + text.replace(/\\n/g, \"\\n\" + indentation);\n                            }\n                        }\n                        if (pre) {\n                            if (!text) {\n                                text = pre + post;\n                            } else {\n                                text = pre + text + \"\\n\" + post;\n                            }\n                        }\n                        printer.print_newline(false);\n                        if (text) {\n                            raw_token.text = text;\n                            raw_token.whitespace_before = \"\";\n                            raw_token.newlines = 0;\n                            printer.add_raw_token(raw_token);\n                            printer.print_newline(true);\n                        }\n                    }\n                };\n                Beautifier.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token, tokens) {\n                    var parser_token = this._get_tag_open_token(raw_token);\n                    if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) && !last_tag_token.is_empty_element && raw_token.type === TOKEN.TAG_OPEN && !parser_token.is_start_tag) {\n                        // End element tags for unformatted or content_unformatted elements\n                        // are printed raw to keep any newlines inside them exactly the same.\n                        printer.add_raw_token(raw_token);\n                        parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);\n                    } else {\n                        printer.traverse_whitespace(raw_token);\n                        this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);\n                        if (!parser_token.is_inline_element) {\n                            printer.set_wrap_point();\n                        }\n                        printer.print_token(raw_token);\n                    }\n                    // count the number of attributes\n                    if (parser_token.is_start_tag && this._is_wrap_attributes_force) {\n                        var peek_index = 0;\n                        var peek_token;\n                        do {\n                            peek_token = tokens.peek(peek_index);\n                            if (peek_token.type === TOKEN.ATTRIBUTE) {\n                                parser_token.attr_count += 1;\n                            }\n                            peek_index += 1;\n                        }while (peek_token.type !== TOKEN.EOF && peek_token.type !== TOKEN.TAG_CLOSE);\n                    }\n                    //indent attributes an auto, forced, aligned or forced-align line-wrap\n                    if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {\n                        parser_token.alignment_size = raw_token.text.length + 1;\n                    }\n                    if (!parser_token.tag_complete && !parser_token.is_unformatted) {\n                        printer.alignment_size = parser_token.alignment_size;\n                    }\n                    return parser_token;\n                };\n                var TagOpenParserToken = function(parent, raw_token) {\n                    this.parent = parent || null;\n                    this.text = \"\";\n                    this.type = \"TK_TAG_OPEN\";\n                    this.tag_name = \"\";\n                    this.is_inline_element = false;\n                    this.is_unformatted = false;\n                    this.is_content_unformatted = false;\n                    this.is_empty_element = false;\n                    this.is_start_tag = false;\n                    this.is_end_tag = false;\n                    this.indent_content = false;\n                    this.multiline_content = false;\n                    this.custom_beautifier_name = null;\n                    this.start_tag_token = null;\n                    this.attr_count = 0;\n                    this.has_wrapped_attrs = false;\n                    this.alignment_size = 0;\n                    this.tag_complete = false;\n                    this.tag_start_char = \"\";\n                    this.tag_check = \"\";\n                    if (!raw_token) {\n                        this.tag_complete = true;\n                    } else {\n                        var tag_check_match;\n                        this.tag_start_char = raw_token.text[0];\n                        this.text = raw_token.text;\n                        if (this.tag_start_char === \"<\") {\n                            tag_check_match = raw_token.text.match(/^<([^\\s>]*)/);\n                            this.tag_check = tag_check_match ? tag_check_match[1] : \"\";\n                        } else {\n                            tag_check_match = raw_token.text.match(/^{{~?(?:[\\^]|#\\*?)?([^\\s}]+)/);\n                            this.tag_check = tag_check_match ? tag_check_match[1] : \"\";\n                            // handle \"{{#> myPartial}}\" or \"{{~#> myPartial}}\"\n                            if ((raw_token.text.startsWith(\"{{#>\") || raw_token.text.startsWith(\"{{~#>\")) && this.tag_check[0] === \">\") {\n                                if (this.tag_check === \">\" && raw_token.next !== null) {\n                                    this.tag_check = raw_token.next.text.split(\" \")[0];\n                                } else {\n                                    this.tag_check = raw_token.text.split(\">\")[1];\n                                }\n                            }\n                        }\n                        this.tag_check = this.tag_check.toLowerCase();\n                        if (raw_token.type === TOKEN.COMMENT) {\n                            this.tag_complete = true;\n                        }\n                        this.is_start_tag = this.tag_check.charAt(0) !== \"/\";\n                        this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;\n                        this.is_end_tag = !this.is_start_tag || raw_token.closed && raw_token.closed.text === \"/>\";\n                        // if whitespace handler ~ included (i.e. {{~#if true}}), handlebars tags start at pos 3 not pos 2\n                        var handlebar_starts = 2;\n                        if (this.tag_start_char === \"{\" && this.text.length >= 3) {\n                            if (this.text.charAt(2) === \"~\") {\n                                handlebar_starts = 3;\n                            }\n                        }\n                        // handlebars tags that don't start with # or ^ are single_tags, and so also start and end.\n                        this.is_end_tag = this.is_end_tag || this.tag_start_char === \"{\" && (this.text.length < 3 || /[^#\\^]/.test(this.text.charAt(handlebar_starts)));\n                    }\n                };\n                Beautifier.prototype._get_tag_open_token = function(raw_token) {\n                    var parser_token = new TagOpenParserToken(this._tag_stack.get_parser_token(), raw_token);\n                    parser_token.alignment_size = this._options.wrap_attributes_indent_size;\n                    parser_token.is_end_tag = parser_token.is_end_tag || in_array(parser_token.tag_check, this._options.void_elements);\n                    parser_token.is_empty_element = parser_token.tag_complete || parser_token.is_start_tag && parser_token.is_end_tag;\n                    parser_token.is_unformatted = !parser_token.tag_complete && in_array(parser_token.tag_check, this._options.unformatted);\n                    parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array(parser_token.tag_check, this._options.content_unformatted);\n                    parser_token.is_inline_element = in_array(parser_token.tag_name, this._options.inline) || this._options.inline_custom_elements && parser_token.tag_name.includes(\"-\") || parser_token.tag_start_char === \"{\";\n                    return parser_token;\n                };\n                Beautifier.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {\n                    if (!parser_token.is_empty_element) {\n                        if (parser_token.is_end_tag) {\n                            parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name); //remove it and all ancestors\n                        } else {\n                            // check if this tag is starting an element that has optional end element\n                            // and do an ending needed\n                            if (this._do_optional_end_element(parser_token)) {\n                                if (!parser_token.is_inline_element) {\n                                    printer.print_newline(false);\n                                }\n                            }\n                            this._tag_stack.record_tag(parser_token); //push it on the tag stack\n                            if ((parser_token.tag_name === \"script\" || parser_token.tag_name === \"style\") && !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {\n                                parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);\n                            }\n                        }\n                    }\n                    if (in_array(parser_token.tag_check, this._options.extra_liners)) {\n                        printer.print_newline(false);\n                        if (!printer._output.just_added_blankline()) {\n                            printer.print_newline(true);\n                        }\n                    }\n                    if (parser_token.is_empty_element) {\n                        // if you hit an else case, reset the indent level if you are inside an:\n                        // 'if', 'unless', or 'each' block.\n                        if (parser_token.tag_start_char === \"{\" && parser_token.tag_check === \"else\") {\n                            this._tag_stack.indent_to_tag([\n                                \"if\",\n                                \"unless\",\n                                \"each\"\n                            ]);\n                            parser_token.indent_content = true;\n                            // Don't add a newline if opening {{#if}} tag is on the current line\n                            var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);\n                            if (!foundIfOnCurrentLine) {\n                                printer.print_newline(false);\n                            }\n                        }\n                        // Don't add a newline before elements that should remain where they are.\n                        if (parser_token.tag_name === \"!--\" && last_token.type === TOKEN.TAG_CLOSE && last_tag_token.is_end_tag && parser_token.text.indexOf(\"\\n\") === -1) {\n                        //Do nothing. Leave comments on same line.\n                        } else {\n                            if (!(parser_token.is_inline_element || parser_token.is_unformatted)) {\n                                printer.print_newline(false);\n                            }\n                            this._calcluate_parent_multiline(printer, parser_token);\n                        }\n                    } else if (parser_token.is_end_tag) {\n                        var do_end_expand = false;\n                        // deciding whether a block is multiline should not be this hard\n                        do_end_expand = parser_token.start_tag_token && parser_token.start_tag_token.multiline_content;\n                        do_end_expand = do_end_expand || !parser_token.is_inline_element && !(last_tag_token.is_inline_element || last_tag_token.is_unformatted) && !(last_token.type === TOKEN.TAG_CLOSE && parser_token.start_tag_token === last_tag_token) && last_token.type !== \"TK_CONTENT\";\n                        if (parser_token.is_content_unformatted || parser_token.is_unformatted) {\n                            do_end_expand = false;\n                        }\n                        if (do_end_expand) {\n                            printer.print_newline(false);\n                        }\n                    } else {\n                        parser_token.indent_content = !parser_token.custom_beautifier_name;\n                        if (parser_token.tag_start_char === \"<\") {\n                            if (parser_token.tag_name === \"html\") {\n                                parser_token.indent_content = this._options.indent_inner_html;\n                            } else if (parser_token.tag_name === \"head\") {\n                                parser_token.indent_content = this._options.indent_head_inner_html;\n                            } else if (parser_token.tag_name === \"body\") {\n                                parser_token.indent_content = this._options.indent_body_inner_html;\n                            }\n                        }\n                        if (!(parser_token.is_inline_element || parser_token.is_unformatted) && (last_token.type !== \"TK_CONTENT\" || parser_token.is_content_unformatted)) {\n                            printer.print_newline(false);\n                        }\n                        this._calcluate_parent_multiline(printer, parser_token);\n                    }\n                };\n                Beautifier.prototype._calcluate_parent_multiline = function(printer, parser_token) {\n                    if (parser_token.parent && printer._output.just_added_newline() && !((parser_token.is_inline_element || parser_token.is_unformatted) && parser_token.parent.is_inline_element)) {\n                        parser_token.parent.multiline_content = true;\n                    }\n                };\n                //To be used for <p> tag special case:\n                var p_closers = [\n                    \"address\",\n                    \"article\",\n                    \"aside\",\n                    \"blockquote\",\n                    \"details\",\n                    \"div\",\n                    \"dl\",\n                    \"fieldset\",\n                    \"figcaption\",\n                    \"figure\",\n                    \"footer\",\n                    \"form\",\n                    \"h1\",\n                    \"h2\",\n                    \"h3\",\n                    \"h4\",\n                    \"h5\",\n                    \"h6\",\n                    \"header\",\n                    \"hr\",\n                    \"main\",\n                    \"menu\",\n                    \"nav\",\n                    \"ol\",\n                    \"p\",\n                    \"pre\",\n                    \"section\",\n                    \"table\",\n                    \"ul\"\n                ];\n                var p_parent_excludes = [\n                    \"a\",\n                    \"audio\",\n                    \"del\",\n                    \"ins\",\n                    \"map\",\n                    \"noscript\",\n                    \"video\"\n                ];\n                Beautifier.prototype._do_optional_end_element = function(parser_token) {\n                    var result = null;\n                    // NOTE: cases of \"if there is no more content in the parent element\"\n                    // are handled automatically by the beautifier.\n                    // It assumes parent or ancestor close tag closes all children.\n                    // https://www.w3.org/TR/html5/syntax.html#optional-tags\n                    if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {\n                        return;\n                    }\n                    if (parser_token.tag_name === \"body\") {\n                        // A head element’s end tag may be omitted if the head element is not immediately followed by a space character or a comment.\n                        result = result || this._tag_stack.try_pop(\"head\");\n                    //} else if (parser_token.tag_name === 'body') {\n                    // DONE: A body element’s end tag may be omitted if the body element is not immediately followed by a comment.\n                    } else if (parser_token.tag_name === \"li\") {\n                        // An li element’s end tag may be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element.\n                        result = result || this._tag_stack.try_pop(\"li\", [\n                            \"ol\",\n                            \"ul\",\n                            \"menu\"\n                        ]);\n                    } else if (parser_token.tag_name === \"dd\" || parser_token.tag_name === \"dt\") {\n                        // A dd element’s end tag may be omitted if the dd element is immediately followed by another dd element or a dt element, or if there is no more content in the parent element.\n                        // A dt element’s end tag may be omitted if the dt element is immediately followed by another dt element or a dd element.\n                        result = result || this._tag_stack.try_pop(\"dt\", [\n                            \"dl\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"dd\", [\n                            \"dl\"\n                        ]);\n                    } else if (parser_token.parent.tag_name === \"p\" && p_closers.indexOf(parser_token.tag_name) !== -1) {\n                        // IMPORTANT: this else-if works because p_closers has no overlap with any other element we look for in this method\n                        // check for the parent element is an HTML element that is not an <a>, <audio>, <del>, <ins>, <map>, <noscript>, or <video> element,  or an autonomous custom element.\n                        // To do this right, this needs to be coded as an inclusion of the inverse of the exclusion above.\n                        // But to start with (if we ignore \"autonomous custom elements\") the exclusion would be fine.\n                        var p_parent = parser_token.parent.parent;\n                        if (!p_parent || p_parent_excludes.indexOf(p_parent.tag_name) === -1) {\n                            result = result || this._tag_stack.try_pop(\"p\");\n                        }\n                    } else if (parser_token.tag_name === \"rp\" || parser_token.tag_name === \"rt\") {\n                        // An rt element’s end tag may be omitted if the rt element is immediately followed by an rt or rp element, or if there is no more content in the parent element.\n                        // An rp element’s end tag may be omitted if the rp element is immediately followed by an rt or rp element, or if there is no more content in the parent element.\n                        result = result || this._tag_stack.try_pop(\"rt\", [\n                            \"ruby\",\n                            \"rtc\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"rp\", [\n                            \"ruby\",\n                            \"rtc\"\n                        ]);\n                    } else if (parser_token.tag_name === \"optgroup\") {\n                        // An optgroup element’s end tag may be omitted if the optgroup element is immediately followed by another optgroup element, or if there is no more content in the parent element.\n                        // An option element’s end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.\n                        result = result || this._tag_stack.try_pop(\"optgroup\", [\n                            \"select\"\n                        ]);\n                    //result = result || this._tag_stack.try_pop('option', ['select']);\n                    } else if (parser_token.tag_name === \"option\") {\n                        // An option element’s end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.\n                        result = result || this._tag_stack.try_pop(\"option\", [\n                            \"select\",\n                            \"datalist\",\n                            \"optgroup\"\n                        ]);\n                    } else if (parser_token.tag_name === \"colgroup\") {\n                        // DONE: A colgroup element’s end tag may be omitted if the colgroup element is not immediately followed by a space character or a comment.\n                        // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.\n                        result = result || this._tag_stack.try_pop(\"caption\", [\n                            \"table\"\n                        ]);\n                    } else if (parser_token.tag_name === \"thead\") {\n                        // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.\n                        // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.\n                        result = result || this._tag_stack.try_pop(\"caption\", [\n                            \"table\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"colgroup\", [\n                            \"table\"\n                        ]);\n                    //} else if (parser_token.tag_name === 'caption') {\n                    // DONE: A caption element’s end tag may be omitted if the caption element is not immediately followed by a space character or a comment.\n                    } else if (parser_token.tag_name === \"tbody\" || parser_token.tag_name === \"tfoot\") {\n                        // A thead element’s end tag may be omitted if the thead element is immediately followed by a tbody or tfoot element.\n                        // A tbody element’s end tag may be omitted if the tbody element is immediately followed by a tbody or tfoot element, or if there is no more content in the parent element.\n                        // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.\n                        // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.\n                        result = result || this._tag_stack.try_pop(\"caption\", [\n                            \"table\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"colgroup\", [\n                            \"table\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"thead\", [\n                            \"table\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"tbody\", [\n                            \"table\"\n                        ]);\n                    //} else if (parser_token.tag_name === 'tfoot') {\n                    // DONE: A tfoot element’s end tag may be omitted if there is no more content in the parent element.\n                    } else if (parser_token.tag_name === \"tr\") {\n                        // A tr element’s end tag may be omitted if the tr element is immediately followed by another tr element, or if there is no more content in the parent element.\n                        // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.\n                        // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.\n                        result = result || this._tag_stack.try_pop(\"caption\", [\n                            \"table\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"colgroup\", [\n                            \"table\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"tr\", [\n                            \"table\",\n                            \"thead\",\n                            \"tbody\",\n                            \"tfoot\"\n                        ]);\n                    } else if (parser_token.tag_name === \"th\" || parser_token.tag_name === \"td\") {\n                        // A td element’s end tag may be omitted if the td element is immediately followed by a td or th element, or if there is no more content in the parent element.\n                        // A th element’s end tag may be omitted if the th element is immediately followed by a td or th element, or if there is no more content in the parent element.\n                        result = result || this._tag_stack.try_pop(\"td\", [\n                            \"table\",\n                            \"thead\",\n                            \"tbody\",\n                            \"tfoot\",\n                            \"tr\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"th\", [\n                            \"table\",\n                            \"thead\",\n                            \"tbody\",\n                            \"tfoot\",\n                            \"tr\"\n                        ]);\n                    }\n                    // Start element omission not handled currently\n                    // A head element’s start tag may be omitted if the element is empty, or if the first thing inside the head element is an element.\n                    // A tbody element’s start tag may be omitted if the first thing inside the tbody element is a tr element, and if the element is not immediately preceded by a tbody, thead, or tfoot element whose end tag has been omitted. (It can’t be omitted if the element is empty.)\n                    // A colgroup element’s start tag may be omitted if the first thing inside the colgroup element is a col element, and if the element is not immediately preceded by another colgroup element whose end tag has been omitted. (It can’t be omitted if the element is empty.)\n                    // Fix up the parent of the parser token\n                    parser_token.parent = this._tag_stack.get_parser_token();\n                    return result;\n                };\n                module.exports.Beautifier = Beautifier;\n            /***/ },\n            /* 20 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_126558__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var BaseOptions = __nested_webpack_require_126558__(6).Options;\n                function Options(options) {\n                    BaseOptions.call(this, options, \"html\");\n                    if (this.templating.length === 1 && this.templating[0] === \"auto\") {\n                        this.templating = [\n                            \"django\",\n                            \"erb\",\n                            \"handlebars\",\n                            \"php\"\n                        ];\n                    }\n                    this.indent_inner_html = this._get_boolean(\"indent_inner_html\");\n                    this.indent_body_inner_html = this._get_boolean(\"indent_body_inner_html\", true);\n                    this.indent_head_inner_html = this._get_boolean(\"indent_head_inner_html\", true);\n                    this.indent_handlebars = this._get_boolean(\"indent_handlebars\", true);\n                    this.wrap_attributes = this._get_selection(\"wrap_attributes\", [\n                        \"auto\",\n                        \"force\",\n                        \"force-aligned\",\n                        \"force-expand-multiline\",\n                        \"aligned-multiple\",\n                        \"preserve\",\n                        \"preserve-aligned\"\n                    ]);\n                    this.wrap_attributes_min_attrs = this._get_number(\"wrap_attributes_min_attrs\", 2);\n                    this.wrap_attributes_indent_size = this._get_number(\"wrap_attributes_indent_size\", this.indent_size);\n                    this.extra_liners = this._get_array(\"extra_liners\", [\n                        \"head\",\n                        \"body\",\n                        \"/html\"\n                    ]);\n                    // Block vs inline elements\n                    // https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\n                    // https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements\n                    // https://www.w3.org/TR/html5/dom.html#phrasing-content\n                    this.inline = this._get_array(\"inline\", [\n                        \"a\",\n                        \"abbr\",\n                        \"area\",\n                        \"audio\",\n                        \"b\",\n                        \"bdi\",\n                        \"bdo\",\n                        \"br\",\n                        \"button\",\n                        \"canvas\",\n                        \"cite\",\n                        \"code\",\n                        \"data\",\n                        \"datalist\",\n                        \"del\",\n                        \"dfn\",\n                        \"em\",\n                        \"embed\",\n                        \"i\",\n                        \"iframe\",\n                        \"img\",\n                        \"input\",\n                        \"ins\",\n                        \"kbd\",\n                        \"keygen\",\n                        \"label\",\n                        \"map\",\n                        \"mark\",\n                        \"math\",\n                        \"meter\",\n                        \"noscript\",\n                        \"object\",\n                        \"output\",\n                        \"progress\",\n                        \"q\",\n                        \"ruby\",\n                        \"s\",\n                        \"samp\",\n                        /* 'script', */ \"select\",\n                        \"small\",\n                        \"span\",\n                        \"strong\",\n                        \"sub\",\n                        \"sup\",\n                        \"svg\",\n                        \"template\",\n                        \"textarea\",\n                        \"time\",\n                        \"u\",\n                        \"var\",\n                        \"video\",\n                        \"wbr\",\n                        \"text\",\n                        // obsolete inline tags\n                        \"acronym\",\n                        \"big\",\n                        \"strike\",\n                        \"tt\"\n                    ]);\n                    this.inline_custom_elements = this._get_boolean(\"inline_custom_elements\", true);\n                    this.void_elements = this._get_array(\"void_elements\", [\n                        // HTLM void elements - aka self-closing tags - aka singletons\n                        // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\n                        \"area\",\n                        \"base\",\n                        \"br\",\n                        \"col\",\n                        \"embed\",\n                        \"hr\",\n                        \"img\",\n                        \"input\",\n                        \"keygen\",\n                        \"link\",\n                        \"menuitem\",\n                        \"meta\",\n                        \"param\",\n                        \"source\",\n                        \"track\",\n                        \"wbr\",\n                        // NOTE: Optional tags are too complex for a simple list\n                        // they are hard coded in _do_optional_end_element\n                        // Doctype and xml elements\n                        \"!doctype\",\n                        \"?xml\",\n                        // obsolete tags\n                        // basefont: https://www.computerhope.com/jargon/h/html-basefont-tag.htm\n                        // isndex: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/isindex\n                        \"basefont\",\n                        \"isindex\"\n                    ]);\n                    this.unformatted = this._get_array(\"unformatted\", []);\n                    this.content_unformatted = this._get_array(\"content_unformatted\", [\n                        \"pre\",\n                        \"textarea\"\n                    ]);\n                    this.unformatted_content_delimiter = this._get_characters(\"unformatted_content_delimiter\");\n                    this.indent_scripts = this._get_selection(\"indent_scripts\", [\n                        \"normal\",\n                        \"keep\",\n                        \"separate\"\n                    ]);\n                }\n                Options.prototype = new BaseOptions();\n                module.exports.Options = Options;\n            /***/ },\n            /* 21 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_134019__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var BaseTokenizer = __nested_webpack_require_134019__(9).Tokenizer;\n                var BASETOKEN = __nested_webpack_require_134019__(9).TOKEN;\n                var Directives = __nested_webpack_require_134019__(13).Directives;\n                var TemplatablePattern = __nested_webpack_require_134019__(14).TemplatablePattern;\n                var Pattern = __nested_webpack_require_134019__(12).Pattern;\n                var TOKEN = {\n                    TAG_OPEN: \"TK_TAG_OPEN\",\n                    TAG_CLOSE: \"TK_TAG_CLOSE\",\n                    CONTROL_FLOW_OPEN: \"TK_CONTROL_FLOW_OPEN\",\n                    CONTROL_FLOW_CLOSE: \"TK_CONTROL_FLOW_CLOSE\",\n                    ATTRIBUTE: \"TK_ATTRIBUTE\",\n                    EQUALS: \"TK_EQUALS\",\n                    VALUE: \"TK_VALUE\",\n                    COMMENT: \"TK_COMMENT\",\n                    TEXT: \"TK_TEXT\",\n                    UNKNOWN: \"TK_UNKNOWN\",\n                    START: BASETOKEN.START,\n                    RAW: BASETOKEN.RAW,\n                    EOF: BASETOKEN.EOF\n                };\n                var directives_core = new Directives(/<\\!--/, /-->/);\n                var Tokenizer = function(input_string, options) {\n                    BaseTokenizer.call(this, input_string, options);\n                    this._current_tag_name = \"\";\n                    // Words end at whitespace or when a tag starts\n                    // if we are indenting handlebars, they are considered tags\n                    var templatable_reader = new TemplatablePattern(this._input).read_options(this._options);\n                    var pattern_reader = new Pattern(this._input);\n                    this.__patterns = {\n                        word: templatable_reader.until(/[\\n\\r\\t <]/),\n                        word_control_flow_close_excluded: templatable_reader.until(/[\\n\\r\\t <}]/),\n                        single_quote: templatable_reader.until_after(/'/),\n                        double_quote: templatable_reader.until_after(/\"/),\n                        attribute: templatable_reader.until(/[\\n\\r\\t =>]|\\/>/),\n                        element_name: templatable_reader.until(/[\\n\\r\\t >\\/]/),\n                        angular_control_flow_start: pattern_reader.matching(/\\@[a-zA-Z]+[^({]*[({]/),\n                        handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),\n                        handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),\n                        handlebars_open: pattern_reader.until(/[\\n\\r\\t }]/),\n                        handlebars_raw_close: pattern_reader.until(/}}/),\n                        comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),\n                        cdata: pattern_reader.starting_with(/<!\\[CDATA\\[/).until_after(/]]>/),\n                        // https://en.wikipedia.org/wiki/Conditional_comment\n                        conditional_comment: pattern_reader.starting_with(/<!\\[/).until_after(/]>/),\n                        processing: pattern_reader.starting_with(/<\\?/).until_after(/\\?>/)\n                    };\n                    if (this._options.indent_handlebars) {\n                        this.__patterns.word = this.__patterns.word.exclude(\"handlebars\");\n                        this.__patterns.word_control_flow_close_excluded = this.__patterns.word_control_flow_close_excluded.exclude(\"handlebars\");\n                    }\n                    this._unformatted_content_delimiter = null;\n                    if (this._options.unformatted_content_delimiter) {\n                        var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);\n                        this.__patterns.unformatted_content_delimiter = pattern_reader.matching(literal_regexp).until_after(literal_regexp);\n                    }\n                };\n                Tokenizer.prototype = new BaseTokenizer();\n                Tokenizer.prototype._is_comment = function(current_token) {\n                    return false; //current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.UNKNOWN;\n                };\n                Tokenizer.prototype._is_opening = function(current_token) {\n                    return current_token.type === TOKEN.TAG_OPEN || current_token.type === TOKEN.CONTROL_FLOW_OPEN;\n                };\n                Tokenizer.prototype._is_closing = function(current_token, open_token) {\n                    return current_token.type === TOKEN.TAG_CLOSE && open_token && ((current_token.text === \">\" || current_token.text === \"/>\") && open_token.text[0] === \"<\" || current_token.text === \"}}\" && open_token.text[0] === \"{\" && open_token.text[1] === \"{\") || current_token.type === TOKEN.CONTROL_FLOW_CLOSE && current_token.text === \"}\" && open_token.text.endsWith(\"{\");\n                };\n                Tokenizer.prototype._reset = function() {\n                    this._current_tag_name = \"\";\n                };\n                Tokenizer.prototype._get_next_token = function(previous_token, open_token) {\n                    var token = null;\n                    this._readWhitespace();\n                    var c = this._input.peek();\n                    if (c === null) {\n                        return this._create_token(TOKEN.EOF, \"\");\n                    }\n                    token = token || this._read_open_handlebars(c, open_token);\n                    token = token || this._read_attribute(c, previous_token, open_token);\n                    token = token || this._read_close(c, open_token);\n                    token = token || this._read_control_flows(c, open_token);\n                    token = token || this._read_raw_content(c, previous_token, open_token);\n                    token = token || this._read_content_word(c, open_token);\n                    token = token || this._read_comment_or_cdata(c);\n                    token = token || this._read_processing(c);\n                    token = token || this._read_open(c, open_token);\n                    token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());\n                    return token;\n                };\n                Tokenizer.prototype._read_comment_or_cdata = function(c) {\n                    var token = null;\n                    var resulting_string = null;\n                    var directives = null;\n                    if (c === \"<\") {\n                        var peek1 = this._input.peek(1);\n                        // We treat all comments as literals, even more than preformatted tags\n                        // we only look for the appropriate closing marker\n                        if (peek1 === \"!\") {\n                            resulting_string = this.__patterns.comment.read();\n                            // only process directive on html comments\n                            if (resulting_string) {\n                                directives = directives_core.get_directives(resulting_string);\n                                if (directives && directives.ignore === \"start\") {\n                                    resulting_string += directives_core.readIgnored(this._input);\n                                }\n                            } else {\n                                resulting_string = this.__patterns.cdata.read();\n                            }\n                        }\n                        if (resulting_string) {\n                            token = this._create_token(TOKEN.COMMENT, resulting_string);\n                            token.directives = directives;\n                        }\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_processing = function(c) {\n                    var token = null;\n                    var resulting_string = null;\n                    var directives = null;\n                    if (c === \"<\") {\n                        var peek1 = this._input.peek(1);\n                        if (peek1 === \"!\" || peek1 === \"?\") {\n                            resulting_string = this.__patterns.conditional_comment.read();\n                            resulting_string = resulting_string || this.__patterns.processing.read();\n                        }\n                        if (resulting_string) {\n                            token = this._create_token(TOKEN.COMMENT, resulting_string);\n                            token.directives = directives;\n                        }\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_open = function(c, open_token) {\n                    var resulting_string = null;\n                    var token = null;\n                    if (!open_token || open_token.type === TOKEN.CONTROL_FLOW_OPEN) {\n                        if (c === \"<\") {\n                            resulting_string = this._input.next();\n                            if (this._input.peek() === \"/\") {\n                                resulting_string += this._input.next();\n                            }\n                            resulting_string += this.__patterns.element_name.read();\n                            token = this._create_token(TOKEN.TAG_OPEN, resulting_string);\n                        }\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_open_handlebars = function(c, open_token) {\n                    var resulting_string = null;\n                    var token = null;\n                    if (!open_token || open_token.type === TOKEN.CONTROL_FLOW_OPEN) {\n                        if (this._options.indent_handlebars && c === \"{\" && this._input.peek(1) === \"{\") {\n                            if (this._input.peek(2) === \"!\") {\n                                resulting_string = this.__patterns.handlebars_comment.read();\n                                resulting_string = resulting_string || this.__patterns.handlebars.read();\n                                token = this._create_token(TOKEN.COMMENT, resulting_string);\n                            } else {\n                                resulting_string = this.__patterns.handlebars_open.read();\n                                token = this._create_token(TOKEN.TAG_OPEN, resulting_string);\n                            }\n                        }\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_control_flows = function(c, open_token) {\n                    var resulting_string = \"\";\n                    var token = null;\n                    // Only check for control flows if angular templating is set AND indenting is set\n                    if (!this._options.templating.includes(\"angular\") || !this._options.indent_handlebars) {\n                        return token;\n                    }\n                    if (c === \"@\") {\n                        resulting_string = this.__patterns.angular_control_flow_start.read();\n                        if (resulting_string === \"\") {\n                            return token;\n                        }\n                        var opening_parentheses_count = resulting_string.endsWith(\"(\") ? 1 : 0;\n                        var closing_parentheses_count = 0;\n                        // The opening brace of the control flow is where the number of opening and closing parentheses equal\n                        // e.g. @if({value: true} !== null) { \n                        while(!(resulting_string.endsWith(\"{\") && opening_parentheses_count === closing_parentheses_count)){\n                            var next_char = this._input.next();\n                            if (next_char === null) {\n                                break;\n                            } else if (next_char === \"(\") {\n                                opening_parentheses_count++;\n                            } else if (next_char === \")\") {\n                                closing_parentheses_count++;\n                            }\n                            resulting_string += next_char;\n                        }\n                        token = this._create_token(TOKEN.CONTROL_FLOW_OPEN, resulting_string);\n                    } else if (c === \"}\" && open_token && open_token.type === TOKEN.CONTROL_FLOW_OPEN) {\n                        resulting_string = this._input.next();\n                        token = this._create_token(TOKEN.CONTROL_FLOW_CLOSE, resulting_string);\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_close = function(c, open_token) {\n                    var resulting_string = null;\n                    var token = null;\n                    if (open_token && open_token.type === TOKEN.TAG_OPEN) {\n                        if (open_token.text[0] === \"<\" && (c === \">\" || c === \"/\" && this._input.peek(1) === \">\")) {\n                            resulting_string = this._input.next();\n                            if (c === \"/\") {\n                                resulting_string += this._input.next();\n                            }\n                            token = this._create_token(TOKEN.TAG_CLOSE, resulting_string);\n                        } else if (open_token.text[0] === \"{\" && c === \"}\" && this._input.peek(1) === \"}\") {\n                            this._input.next();\n                            this._input.next();\n                            token = this._create_token(TOKEN.TAG_CLOSE, \"}}\");\n                        }\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_attribute = function(c, previous_token, open_token) {\n                    var token = null;\n                    var resulting_string = \"\";\n                    if (open_token && open_token.text[0] === \"<\") {\n                        if (c === \"=\") {\n                            token = this._create_token(TOKEN.EQUALS, this._input.next());\n                        } else if (c === '\"' || c === \"'\") {\n                            var content = this._input.next();\n                            if (c === '\"') {\n                                content += this.__patterns.double_quote.read();\n                            } else {\n                                content += this.__patterns.single_quote.read();\n                            }\n                            token = this._create_token(TOKEN.VALUE, content);\n                        } else {\n                            resulting_string = this.__patterns.attribute.read();\n                            if (resulting_string) {\n                                if (previous_token.type === TOKEN.EQUALS) {\n                                    token = this._create_token(TOKEN.VALUE, resulting_string);\n                                } else {\n                                    token = this._create_token(TOKEN.ATTRIBUTE, resulting_string);\n                                }\n                            }\n                        }\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._is_content_unformatted = function(tag_name) {\n                    // void_elements have no content and so cannot have unformatted content\n                    // script and style tags should always be read as unformatted content\n                    // finally content_unformatted and unformatted element contents are unformatted\n                    return this._options.void_elements.indexOf(tag_name) === -1 && (this._options.content_unformatted.indexOf(tag_name) !== -1 || this._options.unformatted.indexOf(tag_name) !== -1);\n                };\n                Tokenizer.prototype._read_raw_content = function(c, previous_token, open_token) {\n                    var resulting_string = \"\";\n                    if (open_token && open_token.text[0] === \"{\") {\n                        resulting_string = this.__patterns.handlebars_raw_close.read();\n                    } else if (previous_token.type === TOKEN.TAG_CLOSE && previous_token.opened.text[0] === \"<\" && previous_token.text[0] !== \"/\") {\n                        // ^^ empty tag has no content \n                        var tag_name = previous_token.opened.text.substr(1).toLowerCase();\n                        if (tag_name === \"script\" || tag_name === \"style\") {\n                            // Script and style tags are allowed to have comments wrapping their content\n                            // or just have regular content.\n                            var token = this._read_comment_or_cdata(c);\n                            if (token) {\n                                token.type = TOKEN.TEXT;\n                                return token;\n                            }\n                            resulting_string = this._input.readUntil(new RegExp(\"</\" + tag_name + \"[\\\\n\\\\r\\\\t ]*?>\", \"ig\"));\n                        } else if (this._is_content_unformatted(tag_name)) {\n                            resulting_string = this._input.readUntil(new RegExp(\"</\" + tag_name + \"[\\\\n\\\\r\\\\t ]*?>\", \"ig\"));\n                        }\n                    }\n                    if (resulting_string) {\n                        return this._create_token(TOKEN.TEXT, resulting_string);\n                    }\n                    return null;\n                };\n                Tokenizer.prototype._read_content_word = function(c, open_token) {\n                    var resulting_string = \"\";\n                    if (this._options.unformatted_content_delimiter) {\n                        if (c === this._options.unformatted_content_delimiter[0]) {\n                            resulting_string = this.__patterns.unformatted_content_delimiter.read();\n                        }\n                    }\n                    if (!resulting_string) {\n                        resulting_string = open_token && open_token.type === TOKEN.CONTROL_FLOW_OPEN ? this.__patterns.word_control_flow_close_excluded.read() : this.__patterns.word.read();\n                    }\n                    if (resulting_string) {\n                        return this._create_token(TOKEN.TEXT, resulting_string);\n                    }\n                };\n                module.exports.Tokenizer = Tokenizer;\n                module.exports.TOKEN = TOKEN;\n            /***/ }\n        ];\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_153626__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_153626__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /******/ // startup\n        /******/ // Load entry module and return exports\n        /******/ // This entry module is referenced by other modules so it can't be inlined\n        /******/ var __nested_webpack_exports__ = __nested_webpack_require_153626__(18);\n        /******/ legacy_beautify_html = __nested_webpack_exports__;\n    /******/ /******/ })();\n    var style_html = legacy_beautify_html;\n    /* Footer */ if (true) {\n        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__,\n            __webpack_require__(/*! ./beautify */ \"(rsc)/./node_modules/js-beautify/js/lib/beautify.js\"),\n            __webpack_require__(/*! ./beautify-css */ \"(rsc)/./node_modules/js-beautify/js/lib/beautify-css.js\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(requireamd) {\n            var js_beautify = __webpack_require__(/*! ./beautify */ \"(rsc)/./node_modules/js-beautify/js/lib/beautify.js\");\n            var css_beautify = __webpack_require__(/*! ./beautify-css */ \"(rsc)/./node_modules/js-beautify/js/lib/beautify-css.js\");\n            return {\n                html_beautify: function(html_source, options) {\n                    return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);\n                }\n            };\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else { var css_beautify, js_beautify; }\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvbGliL2JlYXV0aWZ5LWh0bWwuanMiLCJtYXBwaW5ncyI6IjtBQUFBLGtDQUFrQyxHQUNsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1RUEsR0FFQztJQUVELDBCQUEwQixHQUMxQixJQUFJQTtJQUNKLE1BQU0sR0FBSTtRQUNWLE1BQU0sR0FBSTtRQUNWLE1BQU0sR0FBSSxJQUFJQyxzQkFBdUI7OztZQUdyQyxLQUFLLEdBQ0wsR0FBRyxHQUFJLFNBQVNDLE1BQU07Z0JBRXRCLG1CQUFtQixHQUNuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBLEdBSUEsU0FBU0MsV0FBV0MsTUFBTTtvQkFDeEIsSUFBSSxDQUFDQyxRQUFRLEdBQUdEO29CQUNoQixJQUFJLENBQUNFLGlCQUFpQixHQUFHO29CQUN6QixnRkFBZ0Y7b0JBQ2hGLElBQUksQ0FBQ0MsY0FBYyxHQUFHLENBQUM7b0JBQ3ZCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7b0JBQ3pCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUc7b0JBQzFCLElBQUksQ0FBQ0MsNEJBQTRCLEdBQUc7b0JBQ3BDLElBQUksQ0FBQ0MseUJBQXlCLEdBQUcsQ0FBQztvQkFDbEMsSUFBSSxDQUFDQyw0QkFBNEIsR0FBRztvQkFFcEMsSUFBSSxDQUFDQyxPQUFPLEdBQUcsRUFBRTtnQkFDbkI7Z0JBRUFWLFdBQVdXLFNBQVMsQ0FBQ0MsV0FBVyxHQUFHO29CQUNqQyxJQUFJQyxPQUFPLElBQUliLFdBQVcsSUFBSSxDQUFDRSxRQUFRO29CQUN2Q1csS0FBS0MsVUFBVSxDQUFDLElBQUksQ0FBQ1YsY0FBYyxFQUFFLElBQUksQ0FBQ0MsaUJBQWlCO29CQUMzRCxPQUFPUTtnQkFDVDtnQkFFQWIsV0FBV1csU0FBUyxDQUFDSSxJQUFJLEdBQUcsU0FBU0MsS0FBSztvQkFDeEMsSUFB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UUFDcEIsTUFBTSxHQUFJLHVDQUF1QztRQUNqRCxNQUFNLEdBQUksMEVBQTBFO1FBQ3BGLE1BQU0sR0FBSSxJQUFJOFcsMEJBQW1CQSxHQUFHM1IsaUNBQW1CQSxDQUFDO1FBQ3hELE1BQU0sR0FBSWhNLHVCQUF1QjJkLDBCQUFtQkE7SUFDcEQsTUFBTSxHQUNOLE1BQU0sR0FBRztJQUVULElBQUl4TCxhQUFhblM7SUFDakIsVUFBVSxHQUNWLElBQUksSUFBMEMsRUFBRTtRQUM1QywwRkFBMEY7UUFDMUY0ZCxpQ0FBTztZQUFDLG1CQUFTO1lBQUUsNEZBQVk7WUFBRSxvR0FBZ0I7U0FBQyxtQ0FBRSxTQUFTRSxVQUFVO1lBQ25FLElBQUl6TCxjQUFjeUwsbUJBQVVBLENBQUMsdUVBQVk7WUFDekMsSUFBSXhMLGVBQWV3TCxtQkFBVUEsQ0FBQywrRUFBZ0I7WUFFOUMsT0FBTztnQkFDSEMsZUFBZSxTQUFTM0wsV0FBVyxFQUFFOU8sT0FBTztvQkFDeEMsT0FBTzZPLFdBQVdDLGFBQWE5TyxTQUFTK08sWUFBWUEsV0FBVyxFQUFFQyxhQUFhQSxZQUFZO2dCQUM5RjtZQUNKO1FBQ0osQ0FBQztBQUFBLGtHQUFDO0lBQ04sT0FBTyxrQ0FtQk47QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9saWIvYmVhdXRpZnktaHRtbC5qcz84MTIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIEFVVE8tR0VORVJBVEVELiBETyBOT1QgTU9ESUZZLiAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG5cblxuIFN0eWxlIEhUTUxcbi0tLS0tLS0tLS0tLS0tLVxuXG4gIFdyaXR0ZW4gYnkgTm9jaHVtIFNvc3NvbmtvLCAobnNvc3NvbmtvQGhvdG1haWwuY29tKVxuXG4gIEJhc2VkIG9uIGNvZGUgaW5pdGlhbGx5IGRldmVsb3BlZCBieTogRWluYXIgTGllbG1hbmlzLCA8ZWluYXJAYmVhdXRpZmllci5pbz5cbiAgICBodHRwczovL2JlYXV0aWZpZXIuaW8vXG5cbiAgVXNhZ2U6XG4gICAgc3R5bGVfaHRtbChodG1sX3NvdXJjZSk7XG5cbiAgICBzdHlsZV9odG1sKGh0bWxfc291cmNlLCBvcHRpb25zKTtcblxuICBUaGUgb3B0aW9ucyBhcmU6XG4gICAgaW5kZW50X2lubmVyX2h0bWwgKGRlZmF1bHQgZmFsc2UpICDigJQgaW5kZW50IDxoZWFkPiBhbmQgPGJvZHk+IHNlY3Rpb25zLFxuICAgIGluZGVudF9zaXplIChkZWZhdWx0IDQpICAgICAgICAgIOKAlCBpbmRlbnRhdGlvbiBzaXplLFxuICAgIGluZGVudF9jaGFyIChkZWZhdWx0IHNwYWNlKSAgICAgIOKAlCBjaGFyYWN0ZXIgdG8gaW5kZW50IHdpdGgsXG4gICAgd3JhcF9saW5lX2xlbmd0aCAoZGVmYXVsdCAyNTApICAgICAgICAgICAgLSAgbWF4aW11bSBhbW91bnQgb2YgY2hhcmFjdGVycyBwZXIgbGluZSAoMCA9IGRpc2FibGUpXG4gICAgYnJhY2Vfc3R5bGUgKGRlZmF1bHQgXCJjb2xsYXBzZVwiKSAtIFwiY29sbGFwc2VcIiB8IFwiZXhwYW5kXCIgfCBcImVuZC1leHBhbmRcIiB8IFwibm9uZVwiXG4gICAgICAgICAgICBwdXQgYnJhY2VzIG9uIHRoZSBzYW1lIGxpbmUgYXMgY29udHJvbCBzdGF0ZW1lbnRzIChkZWZhdWx0KSwgb3IgcHV0IGJyYWNlcyBvbiBvd24gbGluZSAoQWxsbWFuIC8gQU5TSSBzdHlsZSksIG9yIGp1c3QgcHV0IGVuZCBicmFjZXMgb24gb3duIGxpbmUsIG9yIGF0dGVtcHQgdG8ga2VlcCB0aGVtIHdoZXJlIHRoZXkgYXJlLlxuICAgIGlubGluZSAoZGVmYXVsdHMgdG8gaW5saW5lIHRhZ3MpIC0gbGlzdCBvZiB0YWdzIHRvIGJlIGNvbnNpZGVyZWQgaW5saW5lIHRhZ3NcbiAgICB1bmZvcm1hdHRlZCAoZGVmYXVsdHMgdG8gaW5saW5lIHRhZ3MpIC0gbGlzdCBvZiB0YWdzLCB0aGF0IHNob3VsZG4ndCBiZSByZWZvcm1hdHRlZFxuICAgIGNvbnRlbnRfdW5mb3JtYXR0ZWQgKGRlZmF1bHRzIHRvIFtcInByZVwiLCBcInRleHRhcmVhXCJdIHRhZ3MpIC0gbGlzdCBvZiB0YWdzLCB3aG9zZSBjb250ZW50IHNob3VsZG4ndCBiZSByZWZvcm1hdHRlZFxuICAgIGluZGVudF9zY3JpcHRzIChkZWZhdWx0IG5vcm1hbCkgIC0gXCJrZWVwXCJ8XCJzZXBhcmF0ZVwifFwibm9ybWFsXCJcbiAgICBwcmVzZXJ2ZV9uZXdsaW5lcyAoZGVmYXVsdCB0cnVlKSAtIHdoZXRoZXIgZXhpc3RpbmcgbGluZSBicmVha3MgYmVmb3JlIGVsZW1lbnRzIHNob3VsZCBiZSBwcmVzZXJ2ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IHdvcmtzIGJlZm9yZSBlbGVtZW50cywgbm90IGluc2lkZSB0YWdzIG9yIGZvciB0ZXh0LlxuICAgIG1heF9wcmVzZXJ2ZV9uZXdsaW5lcyAoZGVmYXVsdCB1bmxpbWl0ZWQpIC0gbWF4aW11bSBudW1iZXIgb2YgbGluZSBicmVha3MgdG8gYmUgcHJlc2VydmVkIGluIG9uZSBjaHVua1xuICAgIGluZGVudF9oYW5kbGViYXJzIChkZWZhdWx0IGZhbHNlKSAtIGZvcm1hdCBhbmQgaW5kZW50IHt7I2Zvb319IGFuZCB7ey9mb299fVxuICAgIGVuZF93aXRoX25ld2xpbmUgKGZhbHNlKSAgICAgICAgICAtIGVuZCB3aXRoIGEgbmV3bGluZVxuICAgIGV4dHJhX2xpbmVycyAoZGVmYXVsdCBbaGVhZCxib2R5LC9odG1sXSkgLUxpc3Qgb2YgdGFncyB0aGF0IHNob3VsZCBoYXZlIGFuIGV4dHJhIG5ld2xpbmUgYmVmb3JlIHRoZW0uXG5cbiAgICBlLmcuXG5cbiAgICBzdHlsZV9odG1sKGh0bWxfc291cmNlLCB7XG4gICAgICAnaW5kZW50X2lubmVyX2h0bWwnOiBmYWxzZSxcbiAgICAgICdpbmRlbnRfc2l6ZSc6IDIsXG4gICAgICAnaW5kZW50X2NoYXInOiAnICcsXG4gICAgICAnd3JhcF9saW5lX2xlbmd0aCc6IDc4LFxuICAgICAgJ2JyYWNlX3N0eWxlJzogJ2V4cGFuZCcsXG4gICAgICAncHJlc2VydmVfbmV3bGluZXMnOiB0cnVlLFxuICAgICAgJ21heF9wcmVzZXJ2ZV9uZXdsaW5lcyc6IDUsXG4gICAgICAnaW5kZW50X2hhbmRsZWJhcnMnOiBmYWxzZSxcbiAgICAgICdleHRyYV9saW5lcnMnOiBbJy9odG1sJ11cbiAgICB9KTtcbiovXG5cbihmdW5jdGlvbigpIHtcblxuLyogR0VORVJBVEVEX0JVSUxEX09VVFBVVCAqL1xudmFyIGxlZ2FjeV9iZWF1dGlmeV9odG1sO1xuLyoqKioqKi8gKGZ1bmN0aW9uKCkgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdFwidXNlIHN0cmljdFwiO1xuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9IChbXG4vKiAwICovLFxuLyogMSAqLyxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gT3V0cHV0TGluZShwYXJlbnQpIHtcbiAgdGhpcy5fX3BhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IDA7XG4gIC8vIHVzZSBpbmRlbnRfY291bnQgYXMgYSBtYXJrZXIgZm9yIHRoaXMuX19saW5lcyB0aGF0IGhhdmUgcHJlc2VydmVkIGluZGVudGF0aW9uXG4gIHRoaXMuX19pbmRlbnRfY291bnQgPSAtMTtcbiAgdGhpcy5fX2FsaWdubWVudF9jb3VudCA9IDA7XG4gIHRoaXMuX193cmFwX3BvaW50X2luZGV4ID0gMDtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50ID0gMDtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50ID0gLTE7XG4gIHRoaXMuX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCA9IDA7XG5cbiAgdGhpcy5fX2l0ZW1zID0gW107XG59XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmNsb25lX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsaW5lID0gbmV3IE91dHB1dExpbmUodGhpcy5fX3BhcmVudCk7XG4gIGxpbmUuc2V0X2luZGVudCh0aGlzLl9faW5kZW50X2NvdW50LCB0aGlzLl9fYWxpZ25tZW50X2NvdW50KTtcbiAgcmV0dXJuIGxpbmU7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5pdGVtID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiB0aGlzLl9faXRlbXNbdGhpcy5fX2l0ZW1zLmxlbmd0aCArIGluZGV4XTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZW1zW2luZGV4XTtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuaGFzX21hdGNoID0gZnVuY3Rpb24ocGF0dGVybikge1xuICBmb3IgKHZhciBsYXN0Q2hlY2tlZE91dHB1dCA9IHRoaXMuX19pdGVtcy5sZW5ndGggLSAxOyBsYXN0Q2hlY2tlZE91dHB1dCA+PSAwOyBsYXN0Q2hlY2tlZE91dHB1dC0tKSB7XG4gICAgaWYgKHRoaXMuX19pdGVtc1tsYXN0Q2hlY2tlZE91dHB1dF0ubWF0Y2gocGF0dGVybikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5zZXRfaW5kZW50ID0gZnVuY3Rpb24oaW5kZW50LCBhbGlnbm1lbnQpIHtcbiAgaWYgKHRoaXMuaXNfZW1wdHkoKSkge1xuICAgIHRoaXMuX19pbmRlbnRfY291bnQgPSBpbmRlbnQgfHwgMDtcbiAgICB0aGlzLl9fYWxpZ25tZW50X2NvdW50ID0gYWxpZ25tZW50IHx8IDA7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IHRoaXMuX19wYXJlbnQuZ2V0X2luZGVudF9zaXplKHRoaXMuX19pbmRlbnRfY291bnQsIHRoaXMuX19hbGlnbm1lbnRfY291bnQpO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fc2V0X3dyYXBfcG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX19wYXJlbnQud3JhcF9saW5lX2xlbmd0aCkge1xuICAgIHRoaXMuX193cmFwX3BvaW50X2luZGV4ID0gdGhpcy5fX2l0ZW1zLmxlbmd0aDtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQgPSB0aGlzLl9fY2hhcmFjdGVyX2NvdW50O1xuICAgIHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCA9IHRoaXMuX19wYXJlbnQubmV4dF9saW5lLl9faW5kZW50X2NvdW50O1xuICAgIHRoaXMuX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCA9IHRoaXMuX19wYXJlbnQubmV4dF9saW5lLl9fYWxpZ25tZW50X2NvdW50O1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fc2hvdWxkX3dyYXAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX193cmFwX3BvaW50X2luZGV4ICYmXG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA+IHRoaXMuX19wYXJlbnQud3JhcF9saW5lX2xlbmd0aCAmJlxuICAgIHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudCA+IHRoaXMuX19wYXJlbnQubmV4dF9saW5lLl9fY2hhcmFjdGVyX2NvdW50O1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX2FsbG93X3dyYXAgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3Nob3VsZF93cmFwKCkpIHtcbiAgICB0aGlzLl9fcGFyZW50LmFkZF9uZXdfbGluZSgpO1xuICAgIHZhciBuZXh0ID0gdGhpcy5fX3BhcmVudC5jdXJyZW50X2xpbmU7XG4gICAgbmV4dC5zZXRfaW5kZW50KHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCwgdGhpcy5fX3dyYXBfcG9pbnRfYWxpZ25tZW50X2NvdW50KTtcbiAgICBuZXh0Ll9faXRlbXMgPSB0aGlzLl9faXRlbXMuc2xpY2UodGhpcy5fX3dyYXBfcG9pbnRfaW5kZXgpO1xuICAgIHRoaXMuX19pdGVtcyA9IHRoaXMuX19pdGVtcy5zbGljZSgwLCB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCk7XG5cbiAgICBuZXh0Ll9fY2hhcmFjdGVyX2NvdW50ICs9IHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLSB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQ7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudDtcblxuICAgIGlmIChuZXh0Ll9faXRlbXNbMF0gPT09IFwiIFwiKSB7XG4gICAgICBuZXh0Ll9faXRlbXMuc3BsaWNlKDAsIDEpO1xuICAgICAgbmV4dC5fX2NoYXJhY3Rlcl9jb3VudCAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5pc19lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX2l0ZW1zLmxlbmd0aCA9PT0gMDtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZW1zW3RoaXMuX19pdGVtcy5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgdGhpcy5fX2l0ZW1zLnB1c2goaXRlbSk7XG4gIHZhciBsYXN0X25ld2xpbmVfaW5kZXggPSBpdGVtLmxhc3RJbmRleE9mKCdcXG4nKTtcbiAgaWYgKGxhc3RfbmV3bGluZV9pbmRleCAhPT0gLTEpIHtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID0gaXRlbS5sZW5ndGggLSBsYXN0X25ld2xpbmVfaW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCArPSBpdGVtLmxlbmd0aDtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtID0gbnVsbDtcbiAgaWYgKCF0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICBpdGVtID0gdGhpcy5fX2l0ZW1zLnBvcCgpO1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLT0gaXRlbS5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9yZW1vdmVfaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9faW5kZW50X2NvdW50ID4gMCkge1xuICAgIHRoaXMuX19pbmRlbnRfY291bnQgLT0gMTtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50IC09IHRoaXMuX19wYXJlbnQuaW5kZW50X3NpemU7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9yZW1vdmVfd3JhcF9pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCA+IDApIHtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQgLT0gMTtcbiAgfVxufTtcbk91dHB1dExpbmUucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbigpIHtcbiAgd2hpbGUgKHRoaXMubGFzdCgpID09PSAnICcpIHtcbiAgICB0aGlzLl9faXRlbXMucG9wKCk7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCAtPSAxO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICBpZiAodGhpcy5fX3BhcmVudC5pbmRlbnRfZW1wdHlfbGluZXMpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX19wYXJlbnQuZ2V0X2luZGVudF9zdHJpbmcodGhpcy5fX2luZGVudF9jb3VudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHRoaXMuX19wYXJlbnQuZ2V0X2luZGVudF9zdHJpbmcodGhpcy5fX2luZGVudF9jb3VudCwgdGhpcy5fX2FsaWdubWVudF9jb3VudCk7XG4gICAgcmVzdWx0ICs9IHRoaXMuX19pdGVtcy5qb2luKCcnKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gSW5kZW50U3RyaW5nQ2FjaGUob3B0aW9ucywgYmFzZUluZGVudFN0cmluZykge1xuICB0aGlzLl9fY2FjaGUgPSBbJyddO1xuICB0aGlzLl9faW5kZW50X3NpemUgPSBvcHRpb25zLmluZGVudF9zaXplO1xuICB0aGlzLl9faW5kZW50X3N0cmluZyA9IG9wdGlvbnMuaW5kZW50X2NoYXI7XG4gIGlmICghb3B0aW9ucy5pbmRlbnRfd2l0aF90YWJzKSB7XG4gICAgdGhpcy5fX2luZGVudF9zdHJpbmcgPSBuZXcgQXJyYXkob3B0aW9ucy5pbmRlbnRfc2l6ZSArIDEpLmpvaW4ob3B0aW9ucy5pbmRlbnRfY2hhcik7XG4gIH1cblxuICAvLyBTZXQgdG8gbnVsbCB0byBjb250aW51ZSBzdXBwb3J0IGZvciBhdXRvIGRldGVjdGlvbiBvZiBiYXNlIGluZGVudFxuICBiYXNlSW5kZW50U3RyaW5nID0gYmFzZUluZGVudFN0cmluZyB8fCAnJztcbiAgaWYgKG9wdGlvbnMuaW5kZW50X2xldmVsID4gMCkge1xuICAgIGJhc2VJbmRlbnRTdHJpbmcgPSBuZXcgQXJyYXkob3B0aW9ucy5pbmRlbnRfbGV2ZWwgKyAxKS5qb2luKHRoaXMuX19pbmRlbnRfc3RyaW5nKTtcbiAgfVxuXG4gIHRoaXMuX19iYXNlX3N0cmluZyA9IGJhc2VJbmRlbnRTdHJpbmc7XG4gIHRoaXMuX19iYXNlX3N0cmluZ19sZW5ndGggPSBiYXNlSW5kZW50U3RyaW5nLmxlbmd0aDtcbn1cblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLmdldF9pbmRlbnRfc2l6ZSA9IGZ1bmN0aW9uKGluZGVudCwgY29sdW1uKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9fYmFzZV9zdHJpbmdfbGVuZ3RoO1xuICBjb2x1bW4gPSBjb2x1bW4gfHwgMDtcbiAgaWYgKGluZGVudCA8IDApIHtcbiAgICByZXN1bHQgPSAwO1xuICB9XG4gIHJlc3VsdCArPSBpbmRlbnQgKiB0aGlzLl9faW5kZW50X3NpemU7XG4gIHJlc3VsdCArPSBjb2x1bW47XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5JbmRlbnRTdHJpbmdDYWNoZS5wcm90b3R5cGUuZ2V0X2luZGVudF9zdHJpbmcgPSBmdW5jdGlvbihpbmRlbnRfbGV2ZWwsIGNvbHVtbikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fX2Jhc2Vfc3RyaW5nO1xuICBjb2x1bW4gPSBjb2x1bW4gfHwgMDtcbiAgaWYgKGluZGVudF9sZXZlbCA8IDApIHtcbiAgICBpbmRlbnRfbGV2ZWwgPSAwO1xuICAgIHJlc3VsdCA9ICcnO1xuICB9XG4gIGNvbHVtbiArPSBpbmRlbnRfbGV2ZWwgKiB0aGlzLl9faW5kZW50X3NpemU7XG4gIHRoaXMuX19lbnN1cmVfY2FjaGUoY29sdW1uKTtcbiAgcmVzdWx0ICs9IHRoaXMuX19jYWNoZVtjb2x1bW5dO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLl9fZW5zdXJlX2NhY2hlID0gZnVuY3Rpb24oY29sdW1uKSB7XG4gIHdoaWxlIChjb2x1bW4gPj0gdGhpcy5fX2NhY2hlLmxlbmd0aCkge1xuICAgIHRoaXMuX19hZGRfY29sdW1uKCk7XG4gIH1cbn07XG5cbkluZGVudFN0cmluZ0NhY2hlLnByb3RvdHlwZS5fX2FkZF9jb2x1bW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvbHVtbiA9IHRoaXMuX19jYWNoZS5sZW5ndGg7XG4gIHZhciBpbmRlbnQgPSAwO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGlzLl9faW5kZW50X3NpemUgJiYgY29sdW1uID49IHRoaXMuX19pbmRlbnRfc2l6ZSkge1xuICAgIGluZGVudCA9IE1hdGguZmxvb3IoY29sdW1uIC8gdGhpcy5fX2luZGVudF9zaXplKTtcbiAgICBjb2x1bW4gLT0gaW5kZW50ICogdGhpcy5fX2luZGVudF9zaXplO1xuICAgIHJlc3VsdCA9IG5ldyBBcnJheShpbmRlbnQgKyAxKS5qb2luKHRoaXMuX19pbmRlbnRfc3RyaW5nKTtcbiAgfVxuICBpZiAoY29sdW1uKSB7XG4gICAgcmVzdWx0ICs9IG5ldyBBcnJheShjb2x1bW4gKyAxKS5qb2luKCcgJyk7XG4gIH1cblxuICB0aGlzLl9fY2FjaGUucHVzaChyZXN1bHQpO1xufTtcblxuZnVuY3Rpb24gT3V0cHV0KG9wdGlvbnMsIGJhc2VJbmRlbnRTdHJpbmcpIHtcbiAgdGhpcy5fX2luZGVudF9jYWNoZSA9IG5ldyBJbmRlbnRTdHJpbmdDYWNoZShvcHRpb25zLCBiYXNlSW5kZW50U3RyaW5nKTtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5fZW5kX3dpdGhfbmV3bGluZSA9IG9wdGlvbnMuZW5kX3dpdGhfbmV3bGluZTtcbiAgdGhpcy5pbmRlbnRfc2l6ZSA9IG9wdGlvbnMuaW5kZW50X3NpemU7XG4gIHRoaXMud3JhcF9saW5lX2xlbmd0aCA9IG9wdGlvbnMud3JhcF9saW5lX2xlbmd0aDtcbiAgdGhpcy5pbmRlbnRfZW1wdHlfbGluZXMgPSBvcHRpb25zLmluZGVudF9lbXB0eV9saW5lcztcbiAgdGhpcy5fX2xpbmVzID0gW107XG4gIHRoaXMucHJldmlvdXNfbGluZSA9IG51bGw7XG4gIHRoaXMuY3VycmVudF9saW5lID0gbnVsbDtcbiAgdGhpcy5uZXh0X2xpbmUgPSBuZXcgT3V0cHV0TGluZSh0aGlzKTtcbiAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UgPSBmYWxzZTtcbiAgdGhpcy5wcmV2aW91c190b2tlbl93cmFwcGVkID0gZmFsc2U7XG4gIC8vIGluaXRpYWxpemVcbiAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG59XG5cbk91dHB1dC5wcm90b3R5cGUuX19hZGRfb3V0cHV0bGluZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnByZXZpb3VzX2xpbmUgPSB0aGlzLmN1cnJlbnRfbGluZTtcbiAgdGhpcy5jdXJyZW50X2xpbmUgPSB0aGlzLm5leHRfbGluZS5jbG9uZV9lbXB0eSgpO1xuICB0aGlzLl9fbGluZXMucHVzaCh0aGlzLmN1cnJlbnRfbGluZSk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9saW5lX251bWJlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX2xpbmVzLmxlbmd0aDtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0X2luZGVudF9zdHJpbmcgPSBmdW5jdGlvbihpbmRlbnQsIGNvbHVtbikge1xuICByZXR1cm4gdGhpcy5fX2luZGVudF9jYWNoZS5nZXRfaW5kZW50X3N0cmluZyhpbmRlbnQsIGNvbHVtbik7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9pbmRlbnRfc2l6ZSA9IGZ1bmN0aW9uKGluZGVudCwgY29sdW1uKSB7XG4gIHJldHVybiB0aGlzLl9faW5kZW50X2NhY2hlLmdldF9pbmRlbnRfc2l6ZShpbmRlbnQsIGNvbHVtbik7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmlzX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5wcmV2aW91c19saW5lICYmIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmFkZF9uZXdfbGluZSA9IGZ1bmN0aW9uKGZvcmNlX25ld2xpbmUpIHtcbiAgLy8gbmV2ZXIgbmV3bGluZSBhdCB0aGUgc3RhcnQgb2YgZmlsZVxuICAvLyBvdGhlcndpc2UsIG5ld2xpbmUgb25seSBpZiB3ZSBkaWRuJ3QganVzdCBhZGQgb25lIG9yIHdlJ3JlIGZvcmNlZFxuICBpZiAodGhpcy5pc19lbXB0eSgpIHx8XG4gICAgKCFmb3JjZV9uZXdsaW5lICYmIHRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaWYgcmF3IG91dHB1dCBpcyBlbmFibGVkLCBkb24ndCBwcmludCBhZGRpdGlvbmFsIG5ld2xpbmVzLFxuICAvLyBidXQgc3RpbGwgcmV0dXJuIFRydWUgYXMgdGhvdWdoIHlvdSBoYWRcbiAgaWYgKCF0aGlzLnJhdykge1xuICAgIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5nZXRfY29kZSA9IGZ1bmN0aW9uKGVvbCkge1xuICB0aGlzLnRyaW0odHJ1ZSk7XG5cbiAgLy8gaGFuZGxlIHNvbWUgZWRnZSBjYXNlcyB3aGVyZSB0aGUgbGFzdCB0b2tlbnNcbiAgLy8gaGFzIHRleHQgdGhhdCBlbmRzIHdpdGggbmV3bGluZShzKVxuICB2YXIgbGFzdF9pdGVtID0gdGhpcy5jdXJyZW50X2xpbmUucG9wKCk7XG4gIGlmIChsYXN0X2l0ZW0pIHtcbiAgICBpZiAobGFzdF9pdGVtW2xhc3RfaXRlbS5sZW5ndGggLSAxXSA9PT0gJ1xcbicpIHtcbiAgICAgIGxhc3RfaXRlbSA9IGxhc3RfaXRlbS5yZXBsYWNlKC9cXG4rJC9nLCAnJyk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2gobGFzdF9pdGVtKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9lbmRfd2l0aF9uZXdsaW5lKSB7XG4gICAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG4gIH1cblxuICB2YXIgc3dlZXRfY29kZSA9IHRoaXMuX19saW5lcy5qb2luKCdcXG4nKTtcblxuICBpZiAoZW9sICE9PSAnXFxuJykge1xuICAgIHN3ZWV0X2NvZGUgPSBzd2VldF9jb2RlLnJlcGxhY2UoL1tcXG5dL2csIGVvbCk7XG4gIH1cbiAgcmV0dXJuIHN3ZWV0X2NvZGU7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnNldF93cmFwX3BvaW50ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY3VycmVudF9saW5lLl9zZXRfd3JhcF9wb2ludCgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5zZXRfaW5kZW50ID0gZnVuY3Rpb24oaW5kZW50LCBhbGlnbm1lbnQpIHtcbiAgaW5kZW50ID0gaW5kZW50IHx8IDA7XG4gIGFsaWdubWVudCA9IGFsaWdubWVudCB8fCAwO1xuXG4gIC8vIE5leHQgbGluZSBzdG9yZXMgYWxpZ25tZW50IHZhbHVlc1xuICB0aGlzLm5leHRfbGluZS5zZXRfaW5kZW50KGluZGVudCwgYWxpZ25tZW50KTtcblxuICAvLyBOZXZlciBpbmRlbnQgeW91ciBmaXJzdCBvdXRwdXQgaW5kZW50IGF0IHRoZSBzdGFydCBvZiB0aGUgZmlsZVxuICBpZiAodGhpcy5fX2xpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KGluZGVudCwgYWxpZ25tZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQoKTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5hZGRfcmF3X3Rva2VuID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCB0b2tlbi5uZXdsaW5lczsgeCsrKSB7XG4gICAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG4gIH1cbiAgdGhpcy5jdXJyZW50X2xpbmUuc2V0X2luZGVudCgtMSk7XG4gIHRoaXMuY3VycmVudF9saW5lLnB1c2godG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUpO1xuICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHRva2VuLnRleHQpO1xuICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICB0aGlzLm5vbl9icmVha2luZ19zcGFjZSA9IGZhbHNlO1xuICB0aGlzLnByZXZpb3VzX3Rva2VuX3dyYXBwZWQgPSBmYWxzZTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuYWRkX3Rva2VuID0gZnVuY3Rpb24ocHJpbnRhYmxlX3Rva2VuKSB7XG4gIHRoaXMuX19hZGRfc3BhY2VfYmVmb3JlX3Rva2VuKCk7XG4gIHRoaXMuY3VycmVudF9saW5lLnB1c2gocHJpbnRhYmxlX3Rva2VuKTtcbiAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UgPSBmYWxzZTtcbiAgdGhpcy5wcmV2aW91c190b2tlbl93cmFwcGVkID0gdGhpcy5jdXJyZW50X2xpbmUuX2FsbG93X3dyYXAoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuX19hZGRfc3BhY2VfYmVmb3JlX3Rva2VuID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiAmJiAhdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgIGlmICghdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UpIHtcbiAgICAgIHRoaXMuc2V0X3dyYXBfcG9pbnQoKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCgnICcpO1xuICB9XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnJlbW92ZV9pbmRlbnQgPSBmdW5jdGlvbihpbmRleCkge1xuICB2YXIgb3V0cHV0X2xlbmd0aCA9IHRoaXMuX19saW5lcy5sZW5ndGg7XG4gIHdoaWxlIChpbmRleCA8IG91dHB1dF9sZW5ndGgpIHtcbiAgICB0aGlzLl9fbGluZXNbaW5kZXhdLl9yZW1vdmVfaW5kZW50KCk7XG4gICAgaW5kZXgrKztcbiAgfVxuICB0aGlzLmN1cnJlbnRfbGluZS5fcmVtb3ZlX3dyYXBfaW5kZW50KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbihlYXRfbmV3bGluZXMpIHtcbiAgZWF0X25ld2xpbmVzID0gKGVhdF9uZXdsaW5lcyA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogZWF0X25ld2xpbmVzO1xuXG4gIHRoaXMuY3VycmVudF9saW5lLnRyaW0oKTtcblxuICB3aGlsZSAoZWF0X25ld2xpbmVzICYmIHRoaXMuX19saW5lcy5sZW5ndGggPiAxICYmXG4gICAgdGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKSkge1xuICAgIHRoaXMuX19saW5lcy5wb3AoKTtcbiAgICB0aGlzLmN1cnJlbnRfbGluZSA9IHRoaXMuX19saW5lc1t0aGlzLl9fbGluZXMubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5jdXJyZW50X2xpbmUudHJpbSgpO1xuICB9XG5cbiAgdGhpcy5wcmV2aW91c19saW5lID0gdGhpcy5fX2xpbmVzLmxlbmd0aCA+IDEgP1xuICAgIHRoaXMuX19saW5lc1t0aGlzLl9fbGluZXMubGVuZ3RoIC0gMl0gOiBudWxsO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5qdXN0X2FkZGVkX25ld2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmp1c3RfYWRkZWRfYmxhbmtsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmlzX2VtcHR5KCkgfHxcbiAgICAodGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKSAmJiB0aGlzLnByZXZpb3VzX2xpbmUuaXNfZW1wdHkoKSk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmVuc3VyZV9lbXB0eV9saW5lX2Fib3ZlID0gZnVuY3Rpb24oc3RhcnRzX3dpdGgsIGVuZHNfd2l0aCkge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fbGluZXMubGVuZ3RoIC0gMjtcbiAgd2hpbGUgKGluZGV4ID49IDApIHtcbiAgICB2YXIgcG90ZW50aWFsRW1wdHlMaW5lID0gdGhpcy5fX2xpbmVzW2luZGV4XTtcbiAgICBpZiAocG90ZW50aWFsRW1wdHlMaW5lLmlzX2VtcHR5KCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAocG90ZW50aWFsRW1wdHlMaW5lLml0ZW0oMCkuaW5kZXhPZihzdGFydHNfd2l0aCkgIT09IDAgJiZcbiAgICAgIHBvdGVudGlhbEVtcHR5TGluZS5pdGVtKC0xKSAhPT0gZW5kc193aXRoKSB7XG4gICAgICB0aGlzLl9fbGluZXMuc3BsaWNlKGluZGV4ICsgMSwgMCwgbmV3IE91dHB1dExpbmUodGhpcykpO1xuICAgICAgdGhpcy5wcmV2aW91c19saW5lID0gdGhpcy5fX2xpbmVzW3RoaXMuX19saW5lcy5sZW5ndGggLSAyXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleC0tO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5PdXRwdXQgPSBPdXRwdXQ7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gVG9rZW4odHlwZSwgdGV4dCwgbmV3bGluZXMsIHdoaXRlc3BhY2VfYmVmb3JlKSB7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMudGV4dCA9IHRleHQ7XG5cbiAgLy8gY29tbWVudHNfYmVmb3JlIGFyZVxuICAvLyBjb21tZW50cyB0aGF0IGhhdmUgYSBuZXcgbGluZSBiZWZvcmUgdGhlbVxuICAvLyBhbmQgbWF5IG9yIG1heSBub3QgaGF2ZSBhIG5ld2xpbmUgYWZ0ZXJcbiAgLy8gdGhpcyBpcyBhIHNldCBvZiBjb21tZW50cyBiZWZvcmVcbiAgdGhpcy5jb21tZW50c19iZWZvcmUgPSBudWxsOyAvKiBpbmxpbmUgY29tbWVudCovXG5cblxuICAvLyB0aGlzLmNvbW1lbnRzX2FmdGVyID0gIG5ldyBUb2tlblN0cmVhbSgpOyAvLyBubyBuZXcgbGluZSBiZWZvcmUgYW5kIG5ld2xpbmUgYWZ0ZXJcbiAgdGhpcy5uZXdsaW5lcyA9IG5ld2xpbmVzIHx8IDA7XG4gIHRoaXMud2hpdGVzcGFjZV9iZWZvcmUgPSB3aGl0ZXNwYWNlX2JlZm9yZSB8fCAnJztcbiAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbiAgdGhpcy5vcGVuZWQgPSBudWxsO1xuICB0aGlzLmNsb3NlZCA9IG51bGw7XG4gIHRoaXMuZGlyZWN0aXZlcyA9IG51bGw7XG59XG5cblxubW9kdWxlLmV4cG9ydHMuVG9rZW4gPSBUb2tlbjtcblxuXG4vKioqLyB9KSxcbi8qIDQgKi8sXG4vKiA1ICovLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIE9wdGlvbnMob3B0aW9ucywgbWVyZ2VfY2hpbGRfZmllbGQpIHtcbiAgdGhpcy5yYXdfb3B0aW9ucyA9IF9tZXJnZU9wdHMob3B0aW9ucywgbWVyZ2VfY2hpbGRfZmllbGQpO1xuXG4gIC8vIFN1cHBvcnQgcGFzc2luZyB0aGUgc291cmNlIHRleHQgYmFjayB3aXRoIG5vIGNoYW5nZVxuICB0aGlzLmRpc2FibGVkID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2Rpc2FibGVkJyk7XG5cbiAgdGhpcy5lb2wgPSB0aGlzLl9nZXRfY2hhcmFjdGVycygnZW9sJywgJ2F1dG8nKTtcbiAgdGhpcy5lbmRfd2l0aF9uZXdsaW5lID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2VuZF93aXRoX25ld2xpbmUnKTtcbiAgdGhpcy5pbmRlbnRfc2l6ZSA9IHRoaXMuX2dldF9udW1iZXIoJ2luZGVudF9zaXplJywgNCk7XG4gIHRoaXMuaW5kZW50X2NoYXIgPSB0aGlzLl9nZXRfY2hhcmFjdGVycygnaW5kZW50X2NoYXInLCAnICcpO1xuICB0aGlzLmluZGVudF9sZXZlbCA9IHRoaXMuX2dldF9udW1iZXIoJ2luZGVudF9sZXZlbCcpO1xuXG4gIHRoaXMucHJlc2VydmVfbmV3bGluZXMgPSB0aGlzLl9nZXRfYm9vbGVhbigncHJlc2VydmVfbmV3bGluZXMnLCB0cnVlKTtcbiAgdGhpcy5tYXhfcHJlc2VydmVfbmV3bGluZXMgPSB0aGlzLl9nZXRfbnVtYmVyKCdtYXhfcHJlc2VydmVfbmV3bGluZXMnLCAzMjc4Nik7XG4gIGlmICghdGhpcy5wcmVzZXJ2ZV9uZXdsaW5lcykge1xuICAgIHRoaXMubWF4X3ByZXNlcnZlX25ld2xpbmVzID0gMDtcbiAgfVxuXG4gIHRoaXMuaW5kZW50X3dpdGhfdGFicyA9IHRoaXMuX2dldF9ib29sZWFuKCdpbmRlbnRfd2l0aF90YWJzJywgdGhpcy5pbmRlbnRfY2hhciA9PT0gJ1xcdCcpO1xuICBpZiAodGhpcy5pbmRlbnRfd2l0aF90YWJzKSB7XG4gICAgdGhpcy5pbmRlbnRfY2hhciA9ICdcXHQnO1xuXG4gICAgLy8gaW5kZW50X3NpemUgYmVoYXZpb3IgY2hhbmdlZCBhZnRlciAxLjguNlxuICAgIC8vIEl0IHVzZWQgdG8gYmUgdGhhdCBpbmRlbnRfc2l6ZSB3b3VsZCBiZVxuICAgIC8vIHNldCB0byAxIGZvciBpbmRlbnRfd2l0aF90YWJzLiBUaGF0IGlzIG5vIGxvbmdlciBuZWVkZWQgYW5kXG4gICAgLy8gYWN0dWFsbHkgZG9lc24ndCBtYWtlIHNlbnNlIC0gd2h5IG5vdCB1c2Ugc3BhY2VzPyBGdXJ0aGVyLFxuICAgIC8vIHRoYXQgbWlnaHQgcHJvZHVjZSB1bmV4cGVjdGVkIGJlaGF2aW9yIC0gdGFicyBiZWluZyB1c2VkXG4gICAgLy8gZm9yIHNpbmdsZS1jb2x1bW4gYWxpZ25tZW50LiBTbywgd2hlbiBpbmRlbnRfd2l0aF90YWJzIGlzIHRydWVcbiAgICAvLyBhbmQgaW5kZW50X3NpemUgaXMgMSwgcmVzZXQgaW5kZW50X3NpemUgdG8gNC5cbiAgICBpZiAodGhpcy5pbmRlbnRfc2l6ZSA9PT0gMSkge1xuICAgICAgdGhpcy5pbmRlbnRfc2l6ZSA9IDQ7XG4gICAgfVxuICB9XG5cbiAgLy8gQmFja3dhcmRzIGNvbXBhdCB3aXRoIDEuMy54XG4gIHRoaXMud3JhcF9saW5lX2xlbmd0aCA9IHRoaXMuX2dldF9udW1iZXIoJ3dyYXBfbGluZV9sZW5ndGgnLCB0aGlzLl9nZXRfbnVtYmVyKCdtYXhfY2hhcicpKTtcblxuICB0aGlzLmluZGVudF9lbXB0eV9saW5lcyA9IHRoaXMuX2dldF9ib29sZWFuKCdpbmRlbnRfZW1wdHlfbGluZXMnKTtcblxuICAvLyB2YWxpZCB0ZW1wbGF0aW5nIGxhbmd1YWdlcyBbJ2RqYW5nbycsICdlcmInLCAnaGFuZGxlYmFycycsICdwaHAnLCAnc21hcnR5JywgJ2FuZ3VsYXInXVxuICAvLyBGb3Igbm93LCAnYXV0bycgPSBhbGwgb2ZmIGZvciBqYXZhc2NyaXB0LCBhbGwgZXhjZXB0IGFuZ3VsYXIgb24gZm9yIGh0bWwgKGFuZCBpbmxpbmUgamF2YXNjcmlwdC9jc3MpLlxuICAvLyBvdGhlciB2YWx1ZXMgaWdub3JlZFxuICB0aGlzLnRlbXBsYXRpbmcgPSB0aGlzLl9nZXRfc2VsZWN0aW9uX2xpc3QoJ3RlbXBsYXRpbmcnLCBbJ2F1dG8nLCAnbm9uZScsICdhbmd1bGFyJywgJ2RqYW5nbycsICdlcmInLCAnaGFuZGxlYmFycycsICdwaHAnLCAnc21hcnR5J10sIFsnYXV0byddKTtcbn1cblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9hcnJheSA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIHZhciByZXN1bHQgPSBkZWZhdWx0X3ZhbHVlIHx8IFtdO1xuICBpZiAodHlwZW9mIG9wdGlvbl92YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAob3B0aW9uX3ZhbHVlICE9PSBudWxsICYmIHR5cGVvZiBvcHRpb25fdmFsdWUuY29uY2F0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXN1bHQgPSBvcHRpb25fdmFsdWUuY29uY2F0KCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25fdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlLnNwbGl0KC9bXmEtekEtWjAtOV9cXC9cXC1dKy8pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X2Jvb2xlYW4gPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICB2YXIgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlID09PSB1bmRlZmluZWQgPyAhIWRlZmF1bHRfdmFsdWUgOiAhIW9wdGlvbl92YWx1ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfY2hhcmFjdGVycyA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIHZhciByZXN1bHQgPSBkZWZhdWx0X3ZhbHVlIHx8ICcnO1xuICBpZiAodHlwZW9mIG9wdGlvbl92YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXN1bHQgPSBvcHRpb25fdmFsdWUucmVwbGFjZSgvXFxcXHIvLCAnXFxyJykucmVwbGFjZSgvXFxcXG4vLCAnXFxuJykucmVwbGFjZSgvXFxcXHQvLCAnXFx0Jyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfbnVtYmVyID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgb3B0aW9uX3ZhbHVlID0gdGhpcy5yYXdfb3B0aW9uc1tuYW1lXTtcbiAgZGVmYXVsdF92YWx1ZSA9IHBhcnNlSW50KGRlZmF1bHRfdmFsdWUsIDEwKTtcbiAgaWYgKGlzTmFOKGRlZmF1bHRfdmFsdWUpKSB7XG4gICAgZGVmYXVsdF92YWx1ZSA9IDA7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KG9wdGlvbl92YWx1ZSwgMTApO1xuICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IGRlZmF1bHRfdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfc2VsZWN0aW9uID0gZnVuY3Rpb24obmFtZSwgc2VsZWN0aW9uX2xpc3QsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2dldF9zZWxlY3Rpb25fbGlzdChuYW1lLCBzZWxlY3Rpb25fbGlzdCwgZGVmYXVsdF92YWx1ZSk7XG4gIGlmIChyZXN1bHQubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJbnZhbGlkIE9wdGlvbiBWYWx1ZTogVGhlIG9wdGlvbiAnXCIgKyBuYW1lICsgXCInIGNhbiBvbmx5IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlczpcXG5cIiArXG4gICAgICBzZWxlY3Rpb25fbGlzdCArIFwiXFxuWW91IHBhc3NlZCBpbjogJ1wiICsgdGhpcy5yYXdfb3B0aW9uc1tuYW1lXSArIFwiJ1wiKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRbMF07XG59O1xuXG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfc2VsZWN0aW9uX2xpc3QgPSBmdW5jdGlvbihuYW1lLCBzZWxlY3Rpb25fbGlzdCwgZGVmYXVsdF92YWx1ZSkge1xuICBpZiAoIXNlbGVjdGlvbl9saXN0IHx8IHNlbGVjdGlvbl9saXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNlbGVjdGlvbiBsaXN0IGNhbm5vdCBiZSBlbXB0eS5cIik7XG4gIH1cblxuICBkZWZhdWx0X3ZhbHVlID0gZGVmYXVsdF92YWx1ZSB8fCBbc2VsZWN0aW9uX2xpc3RbMF1dO1xuICBpZiAoIXRoaXMuX2lzX3ZhbGlkX3NlbGVjdGlvbihkZWZhdWx0X3ZhbHVlLCBzZWxlY3Rpb25fbGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIERlZmF1bHQgVmFsdWUhXCIpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2dldF9hcnJheShuYW1lLCBkZWZhdWx0X3ZhbHVlKTtcbiAgaWYgKCF0aGlzLl9pc192YWxpZF9zZWxlY3Rpb24ocmVzdWx0LCBzZWxlY3Rpb25fbGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludmFsaWQgT3B0aW9uIFZhbHVlOiBUaGUgb3B0aW9uICdcIiArIG5hbWUgKyBcIicgY2FuIGNvbnRhaW4gb25seSB0aGUgZm9sbG93aW5nIHZhbHVlczpcXG5cIiArXG4gICAgICBzZWxlY3Rpb25fbGlzdCArIFwiXFxuWW91IHBhc3NlZCBpbjogJ1wiICsgdGhpcy5yYXdfb3B0aW9uc1tuYW1lXSArIFwiJ1wiKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5faXNfdmFsaWRfc2VsZWN0aW9uID0gZnVuY3Rpb24ocmVzdWx0LCBzZWxlY3Rpb25fbGlzdCkge1xuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCAmJiBzZWxlY3Rpb25fbGlzdC5sZW5ndGggJiZcbiAgICAhcmVzdWx0LnNvbWUoZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gc2VsZWN0aW9uX2xpc3QuaW5kZXhPZihpdGVtKSA9PT0gLTE7IH0pO1xufTtcblxuXG4vLyBtZXJnZXMgY2hpbGQgb3B0aW9ucyB1cCB3aXRoIHRoZSBwYXJlbnQgb3B0aW9ucyBvYmplY3Rcbi8vIEV4YW1wbGU6IG9iaiA9IHthOiAxLCBiOiB7YTogMn19XG4vLyAgICAgICAgICBtZXJnZU9wdHMob2JqLCAnYicpXG4vL1xuLy8gICAgICAgICAgUmV0dXJuczoge2E6IDJ9XG5mdW5jdGlvbiBfbWVyZ2VPcHRzKGFsbE9wdGlvbnMsIGNoaWxkRmllbGROYW1lKSB7XG4gIHZhciBmaW5hbE9wdHMgPSB7fTtcbiAgYWxsT3B0aW9ucyA9IF9ub3JtYWxpemVPcHRzKGFsbE9wdGlvbnMpO1xuICB2YXIgbmFtZTtcblxuICBmb3IgKG5hbWUgaW4gYWxsT3B0aW9ucykge1xuICAgIGlmIChuYW1lICE9PSBjaGlsZEZpZWxkTmFtZSkge1xuICAgICAgZmluYWxPcHRzW25hbWVdID0gYWxsT3B0aW9uc1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICAvL21lcmdlIGluIHRoZSBwZXIgdHlwZSBzZXR0aW5ncyBmb3IgdGhlIGNoaWxkRmllbGROYW1lXG4gIGlmIChjaGlsZEZpZWxkTmFtZSAmJiBhbGxPcHRpb25zW2NoaWxkRmllbGROYW1lXSkge1xuICAgIGZvciAobmFtZSBpbiBhbGxPcHRpb25zW2NoaWxkRmllbGROYW1lXSkge1xuICAgICAgZmluYWxPcHRzW25hbWVdID0gYWxsT3B0aW9uc1tjaGlsZEZpZWxkTmFtZV1bbmFtZV07XG4gICAgfVxuICB9XG4gIHJldHVybiBmaW5hbE9wdHM7XG59XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVPcHRzKG9wdGlvbnMpIHtcbiAgdmFyIGNvbnZlcnRlZE9wdHMgPSB7fTtcbiAgdmFyIGtleTtcblxuICBmb3IgKGtleSBpbiBvcHRpb25zKSB7XG4gICAgdmFyIG5ld0tleSA9IGtleS5yZXBsYWNlKC8tL2csIFwiX1wiKTtcbiAgICBjb252ZXJ0ZWRPcHRzW25ld0tleV0gPSBvcHRpb25zW2tleV07XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRlZE9wdHM7XG59XG5cbm1vZHVsZS5leHBvcnRzLk9wdGlvbnMgPSBPcHRpb25zO1xubW9kdWxlLmV4cG9ydHMubm9ybWFsaXplT3B0cyA9IF9ub3JtYWxpemVPcHRzO1xubW9kdWxlLmV4cG9ydHMubWVyZ2VPcHRzID0gX21lcmdlT3B0cztcblxuXG4vKioqLyB9KSxcbi8qIDcgKi8sXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIHJlZ2V4cF9oYXNfc3RpY2t5ID0gUmVnRXhwLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnc3RpY2t5Jyk7XG5cbmZ1bmN0aW9uIElucHV0U2Nhbm5lcihpbnB1dF9zdHJpbmcpIHtcbiAgdGhpcy5fX2lucHV0ID0gaW5wdXRfc3RyaW5nIHx8ICcnO1xuICB0aGlzLl9faW5wdXRfbGVuZ3RoID0gdGhpcy5fX2lucHV0Lmxlbmd0aDtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gMDtcbn1cblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZXN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX19wb3NpdGlvbiA9IDA7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX19wb3NpdGlvbiA+IDApIHtcbiAgICB0aGlzLl9fcG9zaXRpb24gLT0gMTtcbiAgfVxufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fcG9zaXRpb24gPCB0aGlzLl9faW5wdXRfbGVuZ3RoO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB2YWwgPSBudWxsO1xuICBpZiAodGhpcy5oYXNOZXh0KCkpIHtcbiAgICB2YWwgPSB0aGlzLl9faW5wdXQuY2hhckF0KHRoaXMuX19wb3NpdGlvbik7XG4gICAgdGhpcy5fX3Bvc2l0aW9uICs9IDE7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciB2YWwgPSBudWxsO1xuICBpbmRleCA9IGluZGV4IHx8IDA7XG4gIGluZGV4ICs9IHRoaXMuX19wb3NpdGlvbjtcbiAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9faW5wdXRfbGVuZ3RoKSB7XG4gICAgdmFsID0gdGhpcy5fX2lucHV0LmNoYXJBdChpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8vIFRoaXMgaXMgYSBKYXZhU2NyaXB0IG9ubHkgaGVscGVyIGZ1bmN0aW9uIChub3QgaW4gcHl0aG9uKVxuLy8gSmF2YXNjcmlwdCBkb2Vzbid0IGhhdmUgYSBtYXRjaCBtZXRob2Rcbi8vIGFuZCBub3QgYWxsIGltcGxlbWVudGF0aW9uIHN1cHBvcnQgXCJzdGlja3lcIiBmbGFnLlxuLy8gSWYgdGhleSBkbyBub3Qgc3VwcG9ydCBzdGlja3kgdGhlbiBib3RoIHRoaXMubWF0Y2goKSBhbmQgdGhpcy50ZXN0KCkgbWV0aG9kXG4vLyBtdXN0IGdldCB0aGUgbWF0Y2ggYW5kIGNoZWNrIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2guXG4vLyBJZiBzdGlja3kgaXMgc3VwcG9ydGVkIGFuZCBzZXQsIHRoaXMgbWV0aG9kIHdpbGwgdXNlIGl0LlxuLy8gT3RoZXJ3aXNlIGl0IHdpbGwgY2hlY2sgdGhhdCBnbG9iYWwgaXMgc2V0LCBhbmQgZmFsbCBiYWNrIHRvIHRoZSBzbG93ZXIgbWV0aG9kLlxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5fX21hdGNoID0gZnVuY3Rpb24ocGF0dGVybiwgaW5kZXgpIHtcbiAgcGF0dGVybi5sYXN0SW5kZXggPSBpbmRleDtcbiAgdmFyIHBhdHRlcm5fbWF0Y2ggPSBwYXR0ZXJuLmV4ZWModGhpcy5fX2lucHV0KTtcblxuICBpZiAocGF0dGVybl9tYXRjaCAmJiAhKHJlZ2V4cF9oYXNfc3RpY2t5ICYmIHBhdHRlcm4uc3RpY2t5KSkge1xuICAgIGlmIChwYXR0ZXJuX21hdGNoLmluZGV4ICE9PSBpbmRleCkge1xuICAgICAgcGF0dGVybl9tYXRjaCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhdHRlcm5fbWF0Y2g7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbihwYXR0ZXJuLCBpbmRleCkge1xuICBpbmRleCA9IGluZGV4IHx8IDA7XG4gIGluZGV4ICs9IHRoaXMuX19wb3NpdGlvbjtcblxuICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX19pbnB1dF9sZW5ndGgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9fbWF0Y2gocGF0dGVybiwgaW5kZXgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS50ZXN0Q2hhciA9IGZ1bmN0aW9uKHBhdHRlcm4sIGluZGV4KSB7XG4gIC8vIHRlc3Qgb25lIGNoYXJhY3RlciByZWdleCBtYXRjaFxuICB2YXIgdmFsID0gdGhpcy5wZWVrKGluZGV4KTtcbiAgcGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHBhdHRlcm4udGVzdCh2YWwpO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHBhdHRlcm5fbWF0Y2ggPSB0aGlzLl9fbWF0Y2gocGF0dGVybiwgdGhpcy5fX3Bvc2l0aW9uKTtcbiAgaWYgKHBhdHRlcm5fbWF0Y2gpIHtcbiAgICB0aGlzLl9fcG9zaXRpb24gKz0gcGF0dGVybl9tYXRjaFswXS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgcGF0dGVybl9tYXRjaCA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHBhdHRlcm5fbWF0Y2g7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihzdGFydGluZ19wYXR0ZXJuLCB1bnRpbF9wYXR0ZXJuLCB1bnRpbF9hZnRlcikge1xuICB2YXIgdmFsID0gJyc7XG4gIHZhciBtYXRjaDtcbiAgaWYgKHN0YXJ0aW5nX3BhdHRlcm4pIHtcbiAgICBtYXRjaCA9IHRoaXMubWF0Y2goc3RhcnRpbmdfcGF0dGVybik7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YWwgKz0gbWF0Y2hbMF07XG4gICAgfVxuICB9XG4gIGlmICh1bnRpbF9wYXR0ZXJuICYmIChtYXRjaCB8fCAhc3RhcnRpbmdfcGF0dGVybikpIHtcbiAgICB2YWwgKz0gdGhpcy5yZWFkVW50aWwodW50aWxfcGF0dGVybiwgdW50aWxfYWZ0ZXIpO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnJlYWRVbnRpbCA9IGZ1bmN0aW9uKHBhdHRlcm4sIHVudGlsX2FmdGVyKSB7XG4gIHZhciB2YWwgPSAnJztcbiAgdmFyIG1hdGNoX2luZGV4ID0gdGhpcy5fX3Bvc2l0aW9uO1xuICBwYXR0ZXJuLmxhc3RJbmRleCA9IHRoaXMuX19wb3NpdGlvbjtcbiAgdmFyIHBhdHRlcm5fbWF0Y2ggPSBwYXR0ZXJuLmV4ZWModGhpcy5fX2lucHV0KTtcbiAgaWYgKHBhdHRlcm5fbWF0Y2gpIHtcbiAgICBtYXRjaF9pbmRleCA9IHBhdHRlcm5fbWF0Y2guaW5kZXg7XG4gICAgaWYgKHVudGlsX2FmdGVyKSB7XG4gICAgICBtYXRjaF9pbmRleCArPSBwYXR0ZXJuX21hdGNoWzBdLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWF0Y2hfaW5kZXggPSB0aGlzLl9faW5wdXRfbGVuZ3RoO1xuICB9XG5cbiAgdmFsID0gdGhpcy5fX2lucHV0LnN1YnN0cmluZyh0aGlzLl9fcG9zaXRpb24sIG1hdGNoX2luZGV4KTtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gbWF0Y2hfaW5kZXg7XG4gIHJldHVybiB2YWw7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnJlYWRVbnRpbEFmdGVyID0gZnVuY3Rpb24ocGF0dGVybikge1xuICByZXR1cm4gdGhpcy5yZWFkVW50aWwocGF0dGVybiwgdHJ1ZSk7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmdldF9yZWdleHAgPSBmdW5jdGlvbihwYXR0ZXJuLCBtYXRjaF9mcm9tKSB7XG4gIHZhciByZXN1bHQgPSBudWxsO1xuICB2YXIgZmxhZ3MgPSAnZyc7XG4gIGlmIChtYXRjaF9mcm9tICYmIHJlZ2V4cF9oYXNfc3RpY2t5KSB7XG4gICAgZmxhZ3MgPSAneSc7XG4gIH1cbiAgLy8gc3RyaW5ncyBhcmUgY29udmVydGVkIHRvIHJlZ2V4cFxuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwic3RyaW5nXCIgJiYgcGF0dGVybiAhPT0gJycpIHtcbiAgICAvLyByZXN1bHQgPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyksIGZsYWdzKTtcbiAgICByZXN1bHQgPSBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgfSBlbHNlIGlmIChwYXR0ZXJuKSB7XG4gICAgcmVzdWx0ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgZmxhZ3MpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmdldF9saXRlcmFsX3JlZ2V4cCA9IGZ1bmN0aW9uKGxpdGVyYWxfc3RyaW5nKSB7XG4gIHJldHVybiBSZWdFeHAobGl0ZXJhbF9zdHJpbmcucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJykpO1xufTtcblxuLyogY3NzIGJlYXV0aWZpZXIgbGVnYWN5IGhlbHBlcnMgKi9cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucGVla1VudGlsQWZ0ZXIgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciBzdGFydCA9IHRoaXMuX19wb3NpdGlvbjtcbiAgdmFyIHZhbCA9IHRoaXMucmVhZFVudGlsQWZ0ZXIocGF0dGVybik7XG4gIHRoaXMuX19wb3NpdGlvbiA9IHN0YXJ0O1xuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5sb29rQmFjayA9IGZ1bmN0aW9uKHRlc3RWYWwpIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5fX3Bvc2l0aW9uIC0gMTtcbiAgcmV0dXJuIHN0YXJ0ID49IHRlc3RWYWwubGVuZ3RoICYmIHRoaXMuX19pbnB1dC5zdWJzdHJpbmcoc3RhcnQgLSB0ZXN0VmFsLmxlbmd0aCwgc3RhcnQpXG4gICAgLnRvTG93ZXJDYXNlKCkgPT09IHRlc3RWYWw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5JbnB1dFNjYW5uZXIgPSBJbnB1dFNjYW5uZXI7XG5cblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgSW5wdXRTY2FubmVyID0gKF9fd2VicGFja19yZXF1aXJlX18oOCkuSW5wdXRTY2FubmVyKTtcbnZhciBUb2tlbiA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpLlRva2VuKTtcbnZhciBUb2tlblN0cmVhbSA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKS5Ub2tlblN0cmVhbSk7XG52YXIgV2hpdGVzcGFjZVBhdHRlcm4gPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxMSkuV2hpdGVzcGFjZVBhdHRlcm4pO1xuXG52YXIgVE9LRU4gPSB7XG4gIFNUQVJUOiAnVEtfU1RBUlQnLFxuICBSQVc6ICdUS19SQVcnLFxuICBFT0Y6ICdUS19FT0YnXG59O1xuXG52YXIgVG9rZW5pemVyID0gZnVuY3Rpb24oaW5wdXRfc3RyaW5nLCBvcHRpb25zKSB7XG4gIHRoaXMuX2lucHV0ID0gbmV3IElucHV0U2Nhbm5lcihpbnB1dF9zdHJpbmcpO1xuICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5fX3Rva2VucyA9IG51bGw7XG5cbiAgdGhpcy5fcGF0dGVybnMgPSB7fTtcbiAgdGhpcy5fcGF0dGVybnMud2hpdGVzcGFjZSA9IG5ldyBXaGl0ZXNwYWNlUGF0dGVybih0aGlzLl9pbnB1dCk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2lucHV0LnJlc3RhcnQoKTtcbiAgdGhpcy5fX3Rva2VucyA9IG5ldyBUb2tlblN0cmVhbSgpO1xuXG4gIHRoaXMuX3Jlc2V0KCk7XG5cbiAgdmFyIGN1cnJlbnQ7XG4gIHZhciBwcmV2aW91cyA9IG5ldyBUb2tlbihUT0tFTi5TVEFSVCwgJycpO1xuICB2YXIgb3Blbl90b2tlbiA9IG51bGw7XG4gIHZhciBvcGVuX3N0YWNrID0gW107XG4gIHZhciBjb21tZW50cyA9IG5ldyBUb2tlblN0cmVhbSgpO1xuXG4gIHdoaWxlIChwcmV2aW91cy50eXBlICE9PSBUT0tFTi5FT0YpIHtcbiAgICBjdXJyZW50ID0gdGhpcy5fZ2V0X25leHRfdG9rZW4ocHJldmlvdXMsIG9wZW5fdG9rZW4pO1xuICAgIHdoaWxlICh0aGlzLl9pc19jb21tZW50KGN1cnJlbnQpKSB7XG4gICAgICBjb21tZW50cy5hZGQoY3VycmVudCk7XG4gICAgICBjdXJyZW50ID0gdGhpcy5fZ2V0X25leHRfdG9rZW4ocHJldmlvdXMsIG9wZW5fdG9rZW4pO1xuICAgIH1cblxuICAgIGlmICghY29tbWVudHMuaXNFbXB0eSgpKSB7XG4gICAgICBjdXJyZW50LmNvbW1lbnRzX2JlZm9yZSA9IGNvbW1lbnRzO1xuICAgICAgY29tbWVudHMgPSBuZXcgVG9rZW5TdHJlYW0oKTtcbiAgICB9XG5cbiAgICBjdXJyZW50LnBhcmVudCA9IG9wZW5fdG9rZW47XG5cbiAgICBpZiAodGhpcy5faXNfb3BlbmluZyhjdXJyZW50KSkge1xuICAgICAgb3Blbl9zdGFjay5wdXNoKG9wZW5fdG9rZW4pO1xuICAgICAgb3Blbl90b2tlbiA9IGN1cnJlbnQ7XG4gICAgfSBlbHNlIGlmIChvcGVuX3Rva2VuICYmIHRoaXMuX2lzX2Nsb3NpbmcoY3VycmVudCwgb3Blbl90b2tlbikpIHtcbiAgICAgIGN1cnJlbnQub3BlbmVkID0gb3Blbl90b2tlbjtcbiAgICAgIG9wZW5fdG9rZW4uY2xvc2VkID0gY3VycmVudDtcbiAgICAgIG9wZW5fdG9rZW4gPSBvcGVuX3N0YWNrLnBvcCgpO1xuICAgICAgY3VycmVudC5wYXJlbnQgPSBvcGVuX3Rva2VuO1xuICAgIH1cblxuICAgIGN1cnJlbnQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICBwcmV2aW91cy5uZXh0ID0gY3VycmVudDtcblxuICAgIHRoaXMuX190b2tlbnMuYWRkKGN1cnJlbnQpO1xuICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9fdG9rZW5zO1xufTtcblxuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19maXJzdF90b2tlbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3Rva2Vucy5pc0VtcHR5KCk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uKCkge307XG5cblRva2VuaXplci5wcm90b3R5cGUuX2dldF9uZXh0X3Rva2VuID0gZnVuY3Rpb24ocHJldmlvdXNfdG9rZW4sIG9wZW5fdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX2lucHV0LnJlYWQoLy4rL2cpO1xuICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uUkFXLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkVPRiwgJycpO1xuICB9XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19jb21tZW50ID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHJldHVybiBmYWxzZTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX29wZW5pbmcgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfY2xvc2luZyA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4sIG9wZW5fdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9jcmVhdGVfdG9rZW4gPSBmdW5jdGlvbih0eXBlLCB0ZXh0KSB7XG4gIHZhciB0b2tlbiA9IG5ldyBUb2tlbih0eXBlLCB0ZXh0LFxuICAgIHRoaXMuX3BhdHRlcm5zLndoaXRlc3BhY2UubmV3bGluZV9jb3VudCxcbiAgICB0aGlzLl9wYXR0ZXJucy53aGl0ZXNwYWNlLndoaXRlc3BhY2VfYmVmb3JlX3Rva2VuKTtcbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZFdoaXRlc3BhY2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3BhdHRlcm5zLndoaXRlc3BhY2UucmVhZCgpO1xufTtcblxuXG5cbm1vZHVsZS5leHBvcnRzLlRva2VuaXplciA9IFRva2VuaXplcjtcbm1vZHVsZS5leHBvcnRzLlRPS0VOID0gVE9LRU47XG5cblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIFRva2VuU3RyZWFtKHBhcmVudF90b2tlbikge1xuICAvLyBwcml2YXRlXG4gIHRoaXMuX190b2tlbnMgPSBbXTtcbiAgdGhpcy5fX3Rva2Vuc19sZW5ndGggPSB0aGlzLl9fdG9rZW5zLmxlbmd0aDtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gMDtcbiAgdGhpcy5fX3BhcmVudF90b2tlbiA9IHBhcmVudF90b2tlbjtcbn1cblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gMDtcbn07XG5cblRva2VuU3RyZWFtLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fdG9rZW5zX2xlbmd0aCA9PT0gMDtcbn07XG5cblRva2VuU3RyZWFtLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fcG9zaXRpb24gPCB0aGlzLl9fdG9rZW5zX2xlbmd0aDtcbn07XG5cblRva2VuU3RyZWFtLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB2YWwgPSBudWxsO1xuICBpZiAodGhpcy5oYXNOZXh0KCkpIHtcbiAgICB2YWwgPSB0aGlzLl9fdG9rZW5zW3RoaXMuX19wb3NpdGlvbl07XG4gICAgdGhpcy5fX3Bvc2l0aW9uICs9IDE7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cblRva2VuU3RyZWFtLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgdmFyIHZhbCA9IG51bGw7XG4gIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgaW5kZXggKz0gdGhpcy5fX3Bvc2l0aW9uO1xuICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX190b2tlbnNfbGVuZ3RoKSB7XG4gICAgdmFsID0gdGhpcy5fX3Rva2Vuc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cblRva2VuU3RyZWFtLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbih0b2tlbikge1xuICBpZiAodGhpcy5fX3BhcmVudF90b2tlbikge1xuICAgIHRva2VuLnBhcmVudCA9IHRoaXMuX19wYXJlbnRfdG9rZW47XG4gIH1cbiAgdGhpcy5fX3Rva2Vucy5wdXNoKHRva2VuKTtcbiAgdGhpcy5fX3Rva2Vuc19sZW5ndGggKz0gMTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLlRva2VuU3RyZWFtID0gVG9rZW5TdHJlYW07XG5cblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIFBhdHRlcm4gPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxMikuUGF0dGVybik7XG5cbmZ1bmN0aW9uIFdoaXRlc3BhY2VQYXR0ZXJuKGlucHV0X3NjYW5uZXIsIHBhcmVudCkge1xuICBQYXR0ZXJuLmNhbGwodGhpcywgaW5wdXRfc2Nhbm5lciwgcGFyZW50KTtcbiAgaWYgKHBhcmVudCkge1xuICAgIHRoaXMuX2xpbmVfcmVnZXhwID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXJlbnQuX2xpbmVfcmVnZXhwKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9fc2V0X3doaXRlc3BhY2VfcGF0dGVybnMoJycsICcnKTtcbiAgfVxuXG4gIHRoaXMubmV3bGluZV9jb3VudCA9IDA7XG4gIHRoaXMud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4gPSAnJztcbn1cbldoaXRlc3BhY2VQYXR0ZXJuLnByb3RvdHlwZSA9IG5ldyBQYXR0ZXJuKCk7XG5cbldoaXRlc3BhY2VQYXR0ZXJuLnByb3RvdHlwZS5fX3NldF93aGl0ZXNwYWNlX3BhdHRlcm5zID0gZnVuY3Rpb24od2hpdGVzcGFjZV9jaGFycywgbmV3bGluZV9jaGFycykge1xuICB3aGl0ZXNwYWNlX2NoYXJzICs9ICdcXFxcdCAnO1xuICBuZXdsaW5lX2NoYXJzICs9ICdcXFxcblxcXFxyJztcblxuICB0aGlzLl9tYXRjaF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChcbiAgICAnWycgKyB3aGl0ZXNwYWNlX2NoYXJzICsgbmV3bGluZV9jaGFycyArICddKycsIHRydWUpO1xuICB0aGlzLl9uZXdsaW5lX3JlZ2V4cCA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAoXG4gICAgJ1xcXFxyXFxcXG58WycgKyBuZXdsaW5lX2NoYXJzICsgJ10nKTtcbn07XG5cbldoaXRlc3BhY2VQYXR0ZXJuLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubmV3bGluZV9jb3VudCA9IDA7XG4gIHRoaXMud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4gPSAnJztcblxuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fbWF0Y2hfcGF0dGVybik7XG4gIGlmIChyZXN1bHRpbmdfc3RyaW5nID09PSAnICcpIHtcbiAgICB0aGlzLndoaXRlc3BhY2VfYmVmb3JlX3Rva2VuID0gJyAnO1xuICB9IGVsc2UgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IHRoaXMuX19zcGxpdCh0aGlzLl9uZXdsaW5lX3JlZ2V4cCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgdGhpcy5uZXdsaW5lX2NvdW50ID0gbWF0Y2hlcy5sZW5ndGggLSAxO1xuICAgIHRoaXMud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4gPSBtYXRjaGVzW3RoaXMubmV3bGluZV9jb3VudF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0aW5nX3N0cmluZztcbn07XG5cbldoaXRlc3BhY2VQYXR0ZXJuLnByb3RvdHlwZS5tYXRjaGluZyA9IGZ1bmN0aW9uKHdoaXRlc3BhY2VfY2hhcnMsIG5ld2xpbmVfY2hhcnMpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZSgpO1xuICByZXN1bHQuX19zZXRfd2hpdGVzcGFjZV9wYXR0ZXJucyh3aGl0ZXNwYWNlX2NoYXJzLCBuZXdsaW5lX2NoYXJzKTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbldoaXRlc3BhY2VQYXR0ZXJuLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgV2hpdGVzcGFjZVBhdHRlcm4odGhpcy5faW5wdXQsIHRoaXMpO1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLl9fc3BsaXQgPSBmdW5jdGlvbihyZWdleHAsIGlucHV0X3N0cmluZykge1xuICByZWdleHAubGFzdEluZGV4ID0gMDtcbiAgdmFyIHN0YXJ0X2luZGV4ID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgbmV4dF9tYXRjaCA9IHJlZ2V4cC5leGVjKGlucHV0X3N0cmluZyk7XG4gIHdoaWxlIChuZXh0X21hdGNoKSB7XG4gICAgcmVzdWx0LnB1c2goaW5wdXRfc3RyaW5nLnN1YnN0cmluZyhzdGFydF9pbmRleCwgbmV4dF9tYXRjaC5pbmRleCkpO1xuICAgIHN0YXJ0X2luZGV4ID0gbmV4dF9tYXRjaC5pbmRleCArIG5leHRfbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIG5leHRfbWF0Y2ggPSByZWdleHAuZXhlYyhpbnB1dF9zdHJpbmcpO1xuICB9XG5cbiAgaWYgKHN0YXJ0X2luZGV4IDwgaW5wdXRfc3RyaW5nLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wdXNoKGlucHV0X3N0cmluZy5zdWJzdHJpbmcoc3RhcnRfaW5kZXgsIGlucHV0X3N0cmluZy5sZW5ndGgpKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbm1vZHVsZS5leHBvcnRzLldoaXRlc3BhY2VQYXR0ZXJuID0gV2hpdGVzcGFjZVBhdHRlcm47XG5cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIFBhdHRlcm4oaW5wdXRfc2Nhbm5lciwgcGFyZW50KSB7XG4gIHRoaXMuX2lucHV0ID0gaW5wdXRfc2Nhbm5lcjtcbiAgdGhpcy5fc3RhcnRpbmdfcGF0dGVybiA9IG51bGw7XG4gIHRoaXMuX21hdGNoX3BhdHRlcm4gPSBudWxsO1xuICB0aGlzLl91bnRpbF9wYXR0ZXJuID0gbnVsbDtcbiAgdGhpcy5fdW50aWxfYWZ0ZXIgPSBmYWxzZTtcblxuICBpZiAocGFyZW50KSB7XG4gICAgdGhpcy5fc3RhcnRpbmdfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGFyZW50Ll9zdGFydGluZ19wYXR0ZXJuLCB0cnVlKTtcbiAgICB0aGlzLl9tYXRjaF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXJlbnQuX21hdGNoX3BhdHRlcm4sIHRydWUpO1xuICAgIHRoaXMuX3VudGlsX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fdW50aWxfcGF0dGVybik7XG4gICAgdGhpcy5fdW50aWxfYWZ0ZXIgPSBwYXJlbnQuX3VudGlsX2FmdGVyO1xuICB9XG59XG5cblBhdHRlcm4ucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fc3RhcnRpbmdfcGF0dGVybik7XG4gIGlmICghdGhpcy5fc3RhcnRpbmdfcGF0dGVybiB8fCByZXN1bHQpIHtcbiAgICByZXN1bHQgKz0gdGhpcy5faW5wdXQucmVhZCh0aGlzLl9tYXRjaF9wYXR0ZXJuLCB0aGlzLl91bnRpbF9wYXR0ZXJuLCB0aGlzLl91bnRpbF9hZnRlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLnJlYWRfbWF0Y2ggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2lucHV0Lm1hdGNoKHRoaXMuX21hdGNoX3BhdHRlcm4pO1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUudW50aWxfYWZ0ZXIgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll91bnRpbF9hZnRlciA9IHRydWU7XG4gIHJlc3VsdC5fdW50aWxfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGF0dGVybik7XG4gIHJlc3VsdC5fdXBkYXRlKCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS51bnRpbCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZSgpO1xuICByZXN1bHQuX3VudGlsX2FmdGVyID0gZmFsc2U7XG4gIHJlc3VsdC5fdW50aWxfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGF0dGVybik7XG4gIHJlc3VsdC5fdXBkYXRlKCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS5zdGFydGluZ193aXRoID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fc3RhcnRpbmdfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGF0dGVybiwgdHJ1ZSk7XG4gIHJlc3VsdC5fdXBkYXRlKCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS5tYXRjaGluZyA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZSgpO1xuICByZXN1bHQuX21hdGNoX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhdHRlcm4sIHRydWUpO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFBhdHRlcm4odGhpcy5faW5wdXQsIHRoaXMpO1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKCkge307XG5cbm1vZHVsZS5leHBvcnRzLlBhdHRlcm4gPSBQYXR0ZXJuO1xuXG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBEaXJlY3RpdmVzKHN0YXJ0X2Jsb2NrX3BhdHRlcm4sIGVuZF9ibG9ja19wYXR0ZXJuKSB7XG4gIHN0YXJ0X2Jsb2NrX3BhdHRlcm4gPSB0eXBlb2Ygc3RhcnRfYmxvY2tfcGF0dGVybiA9PT0gJ3N0cmluZycgPyBzdGFydF9ibG9ja19wYXR0ZXJuIDogc3RhcnRfYmxvY2tfcGF0dGVybi5zb3VyY2U7XG4gIGVuZF9ibG9ja19wYXR0ZXJuID0gdHlwZW9mIGVuZF9ibG9ja19wYXR0ZXJuID09PSAnc3RyaW5nJyA/IGVuZF9ibG9ja19wYXR0ZXJuIDogZW5kX2Jsb2NrX3BhdHRlcm4uc291cmNlO1xuICB0aGlzLl9fZGlyZWN0aXZlc19ibG9ja19wYXR0ZXJuID0gbmV3IFJlZ0V4cChzdGFydF9ibG9ja19wYXR0ZXJuICsgLyBiZWF1dGlmeSggXFx3K1s6XVxcdyspKyAvLnNvdXJjZSArIGVuZF9ibG9ja19wYXR0ZXJuLCAnZycpO1xuICB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4gPSAvIChcXHcrKVs6XShcXHcrKS9nO1xuXG4gIHRoaXMuX19kaXJlY3RpdmVzX2VuZF9pZ25vcmVfcGF0dGVybiA9IG5ldyBSZWdFeHAoc3RhcnRfYmxvY2tfcGF0dGVybiArIC9cXHNiZWF1dGlmeVxcc2lnbm9yZTplbmRcXHMvLnNvdXJjZSArIGVuZF9ibG9ja19wYXR0ZXJuLCAnZycpO1xufVxuXG5EaXJlY3RpdmVzLnByb3RvdHlwZS5nZXRfZGlyZWN0aXZlcyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgaWYgKCF0ZXh0Lm1hdGNoKHRoaXMuX19kaXJlY3RpdmVzX2Jsb2NrX3BhdHRlcm4pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZGlyZWN0aXZlcyA9IHt9O1xuICB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgdmFyIGRpcmVjdGl2ZV9tYXRjaCA9IHRoaXMuX19kaXJlY3RpdmVfcGF0dGVybi5leGVjKHRleHQpO1xuXG4gIHdoaWxlIChkaXJlY3RpdmVfbWF0Y2gpIHtcbiAgICBkaXJlY3RpdmVzW2RpcmVjdGl2ZV9tYXRjaFsxXV0gPSBkaXJlY3RpdmVfbWF0Y2hbMl07XG4gICAgZGlyZWN0aXZlX21hdGNoID0gdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuLmV4ZWModGV4dCk7XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aXZlcztcbn07XG5cbkRpcmVjdGl2ZXMucHJvdG90eXBlLnJlYWRJZ25vcmVkID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0LnJlYWRVbnRpbEFmdGVyKHRoaXMuX19kaXJlY3RpdmVzX2VuZF9pZ25vcmVfcGF0dGVybik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLkRpcmVjdGl2ZXMgPSBEaXJlY3RpdmVzO1xuXG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBQYXR0ZXJuID0gKF9fd2VicGFja19yZXF1aXJlX18oMTIpLlBhdHRlcm4pO1xuXG5cbnZhciB0ZW1wbGF0ZV9uYW1lcyA9IHtcbiAgZGphbmdvOiBmYWxzZSxcbiAgZXJiOiBmYWxzZSxcbiAgaGFuZGxlYmFyczogZmFsc2UsXG4gIHBocDogZmFsc2UsXG4gIHNtYXJ0eTogZmFsc2UsXG4gIGFuZ3VsYXI6IGZhbHNlXG59O1xuXG4vLyBUaGlzIGxldHMgdGVtcGxhdGVzIGFwcGVhciBhbnl3aGVyZSB3ZSB3b3VsZCBkbyBhIHJlYWRVbnRpbFxuLy8gVGhlIGNvc3QgaXMgaGlnaGVyIGJ1dCBpdCBpcyBwYXkgdG8gcGxheS5cbmZ1bmN0aW9uIFRlbXBsYXRhYmxlUGF0dGVybihpbnB1dF9zY2FubmVyLCBwYXJlbnQpIHtcbiAgUGF0dGVybi5jYWxsKHRoaXMsIGlucHV0X3NjYW5uZXIsIHBhcmVudCk7XG4gIHRoaXMuX190ZW1wbGF0ZV9wYXR0ZXJuID0gbnVsbDtcbiAgdGhpcy5fZGlzYWJsZWQgPSBPYmplY3QuYXNzaWduKHt9LCB0ZW1wbGF0ZV9uYW1lcyk7XG4gIHRoaXMuX2V4Y2x1ZGVkID0gT2JqZWN0LmFzc2lnbih7fSwgdGVtcGxhdGVfbmFtZXMpO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICB0aGlzLl9fdGVtcGxhdGVfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGFyZW50Ll9fdGVtcGxhdGVfcGF0dGVybik7XG4gICAgdGhpcy5fZXhjbHVkZWQgPSBPYmplY3QuYXNzaWduKHRoaXMuX2V4Y2x1ZGVkLCBwYXJlbnQuX2V4Y2x1ZGVkKTtcbiAgICB0aGlzLl9kaXNhYmxlZCA9IE9iamVjdC5hc3NpZ24odGhpcy5fZGlzYWJsZWQsIHBhcmVudC5fZGlzYWJsZWQpO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gbmV3IFBhdHRlcm4oaW5wdXRfc2Nhbm5lcik7XG4gIHRoaXMuX19wYXR0ZXJucyA9IHtcbiAgICBoYW5kbGViYXJzX2NvbW1lbnQ6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgve3shLS0vKS51bnRpbF9hZnRlcigvLS19fS8pLFxuICAgIGhhbmRsZWJhcnNfdW5lc2NhcGVkOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3t7ey8pLnVudGlsX2FmdGVyKC99fX0vKSxcbiAgICBoYW5kbGViYXJzOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3t7LykudW50aWxfYWZ0ZXIoL319LyksXG4gICAgcGhwOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoLzxcXD8oPzpbPSBdfHBocCkvKS51bnRpbF9hZnRlcigvXFw/Pi8pLFxuICAgIGVyYjogcGF0dGVybi5zdGFydGluZ193aXRoKC88JVteJV0vKS51bnRpbF9hZnRlcigvW14lXSU+LyksXG4gICAgLy8gZGphbmdvIGNvZmxpY3RzIHdpdGggaGFuZGxlYmFycyBhIGJpdC5cbiAgICBkamFuZ286IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgveyUvKS51bnRpbF9hZnRlcigvJX0vKSxcbiAgICBkamFuZ29fdmFsdWU6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgve3svKS51bnRpbF9hZnRlcigvfX0vKSxcbiAgICBkamFuZ29fY29tbWVudDogcGF0dGVybi5zdGFydGluZ193aXRoKC97Iy8pLnVudGlsX2FmdGVyKC8jfS8pLFxuICAgIHNtYXJ0eTogcGF0dGVybi5zdGFydGluZ193aXRoKC97KD89W159e1xcc1xcbl0pLykudW50aWxfYWZ0ZXIoL1teXFxzXFxuXX0vKSxcbiAgICBzbWFydHlfY29tbWVudDogcGF0dGVybi5zdGFydGluZ193aXRoKC97XFwqLykudW50aWxfYWZ0ZXIoL1xcKn0vKSxcbiAgICBzbWFydHlfbGl0ZXJhbDogcGF0dGVybi5zdGFydGluZ193aXRoKC97bGl0ZXJhbH0vKS51bnRpbF9hZnRlcigve1xcL2xpdGVyYWx9LylcbiAgfTtcbn1cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUgPSBuZXcgUGF0dGVybigpO1xuXG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUZW1wbGF0YWJsZVBhdHRlcm4odGhpcy5faW5wdXQsIHRoaXMpO1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX19zZXRfdGVtcGxhdGVkX3BhdHRlcm4oKTtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKGxhbmd1YWdlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9kaXNhYmxlZFtsYW5ndWFnZV0gPSB0cnVlO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5yZWFkX29wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgZm9yICh2YXIgbGFuZ3VhZ2UgaW4gdGVtcGxhdGVfbmFtZXMpIHtcbiAgICByZXN1bHQuX2Rpc2FibGVkW2xhbmd1YWdlXSA9IG9wdGlvbnMudGVtcGxhdGluZy5pbmRleE9mKGxhbmd1YWdlKSA9PT0gLTE7XG4gIH1cbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuZXhjbHVkZSA9IGZ1bmN0aW9uKGxhbmd1YWdlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9leGNsdWRlZFtsYW5ndWFnZV0gPSB0cnVlO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoaXMuX21hdGNoX3BhdHRlcm4pIHtcbiAgICByZXN1bHQgPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4pO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fc3RhcnRpbmdfcGF0dGVybiwgdGhpcy5fX3RlbXBsYXRlX3BhdHRlcm4pO1xuICB9XG4gIHZhciBuZXh0ID0gdGhpcy5fcmVhZF90ZW1wbGF0ZSgpO1xuICB3aGlsZSAobmV4dCkge1xuICAgIGlmICh0aGlzLl9tYXRjaF9wYXR0ZXJuKSB7XG4gICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fbWF0Y2hfcGF0dGVybik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQucmVhZFVudGlsKHRoaXMuX190ZW1wbGF0ZV9wYXR0ZXJuKTtcbiAgICB9XG4gICAgcmVzdWx0ICs9IG5leHQ7XG4gICAgbmV4dCA9IHRoaXMuX3JlYWRfdGVtcGxhdGUoKTtcbiAgfVxuXG4gIGlmICh0aGlzLl91bnRpbF9hZnRlcikge1xuICAgIHJlc3VsdCArPSB0aGlzLl9pbnB1dC5yZWFkVW50aWxBZnRlcih0aGlzLl91bnRpbF9wYXR0ZXJuKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5fX3NldF90ZW1wbGF0ZWRfcGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXTtcblxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLnBocCkge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLnBocC5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICB9XG4gIGlmICghdGhpcy5fZGlzYWJsZWQuaGFuZGxlYmFycykge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnMuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLmVyYikge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLmVyYi5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICB9XG4gIGlmICghdGhpcy5fZGlzYWJsZWQuZGphbmdvKSB7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuZGphbmdvLl9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gICAgLy8gVGhlIHN0YXJ0aW5nIHBhdHRlcm4gZm9yIGRqYW5nbyBpcyBtb3JlIGNvbXBsZXggYmVjYXVzZSBpdCBoYXMgZGlmZmVyZW50XG4gICAgLy8gcGF0dGVybnMgZm9yIHZhbHVlLCBjb21tZW50LCBhbmQgb3RoZXIgc2VjdGlvbnNcbiAgICBpdGVtcy5wdXNoKHRoaXMuX19wYXR0ZXJucy5kamFuZ29fdmFsdWUuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgICBpdGVtcy5wdXNoKHRoaXMuX19wYXR0ZXJucy5kamFuZ29fY29tbWVudC5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICB9XG4gIGlmICghdGhpcy5fZGlzYWJsZWQuc21hcnR5KSB7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuc21hcnR5Ll9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gIH1cblxuICBpZiAodGhpcy5fdW50aWxfcGF0dGVybikge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fdW50aWxfcGF0dGVybi5zb3VyY2UpO1xuICB9XG4gIHRoaXMuX190ZW1wbGF0ZV9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cCgnKD86JyArIGl0ZW1zLmpvaW4oJ3wnKSArICcpJyk7XG59O1xuXG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlLl9yZWFkX3RlbXBsYXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gJyc7XG4gIHZhciBjID0gdGhpcy5faW5wdXQucGVlaygpO1xuICBpZiAoYyA9PT0gJzwnKSB7XG4gICAgdmFyIHBlZWsxID0gdGhpcy5faW5wdXQucGVlaygxKTtcbiAgICAvL2lmIHdlJ3JlIGluIGEgY29tbWVudCwgZG8gc29tZXRoaW5nIHNwZWNpYWxcbiAgICAvLyBXZSB0cmVhdCBhbGwgY29tbWVudHMgYXMgbGl0ZXJhbHMsIGV2ZW4gbW9yZSB0aGFuIHByZWZvcm1hdHRlZCB0YWdzXG4gICAgLy8gd2UganVzdCBsb29rIGZvciB0aGUgYXBwcm9wcmlhdGUgY2xvc2UgdGFnXG4gICAgaWYgKCF0aGlzLl9kaXNhYmxlZC5waHAgJiYgIXRoaXMuX2V4Y2x1ZGVkLnBocCAmJiBwZWVrMSA9PT0gJz8nKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICB0aGlzLl9fcGF0dGVybnMucGhwLnJlYWQoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kaXNhYmxlZC5lcmIgJiYgIXRoaXMuX2V4Y2x1ZGVkLmVyYiAmJiBwZWVrMSA9PT0gJyUnKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICB0aGlzLl9fcGF0dGVybnMuZXJiLnJlYWQoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYyA9PT0gJ3snKSB7XG4gICAgaWYgKCF0aGlzLl9kaXNhYmxlZC5oYW5kbGViYXJzICYmICF0aGlzLl9leGNsdWRlZC5oYW5kbGViYXJzKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICB0aGlzLl9fcGF0dGVybnMuaGFuZGxlYmFyc19jb21tZW50LnJlYWQoKTtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzX3VuZXNjYXBlZC5yZWFkKCk7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICB0aGlzLl9fcGF0dGVybnMuaGFuZGxlYmFycy5yZWFkKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fZGlzYWJsZWQuZGphbmdvKSB7XG4gICAgICAvLyBkamFuZ28gY29mbGljdHMgd2l0aCBoYW5kbGViYXJzIGEgYml0LlxuICAgICAgaWYgKCF0aGlzLl9leGNsdWRlZC5kamFuZ28gJiYgIXRoaXMuX2V4Y2x1ZGVkLmhhbmRsZWJhcnMpIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgICB0aGlzLl9fcGF0dGVybnMuZGphbmdvX3ZhbHVlLnJlYWQoKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fZXhjbHVkZWQuZGphbmdvKSB7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmRqYW5nb19jb21tZW50LnJlYWQoKTtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgICB0aGlzLl9fcGF0dGVybnMuZGphbmdvLnJlYWQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kaXNhYmxlZC5zbWFydHkpIHtcbiAgICAgIC8vIHNtYXJ0eSBjYW5ub3QgYmUgZW5hYmxlZCB3aXRoIGRqYW5nbyBvciBoYW5kbGViYXJzIGVuYWJsZWRcbiAgICAgIGlmICh0aGlzLl9kaXNhYmxlZC5kamFuZ28gJiYgdGhpcy5fZGlzYWJsZWQuaGFuZGxlYmFycykge1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICAgIHRoaXMuX19wYXR0ZXJucy5zbWFydHlfY29tbWVudC5yZWFkKCk7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgICAgdGhpcy5fX3BhdHRlcm5zLnNtYXJ0eV9saXRlcmFsLnJlYWQoKTtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgICB0aGlzLl9fcGF0dGVybnMuc21hcnR5LnJlYWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdGluZ19zdHJpbmc7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLlRlbXBsYXRhYmxlUGF0dGVybiA9IFRlbXBsYXRhYmxlUGF0dGVybjtcblxuXG4vKioqLyB9KSxcbi8qIDE1ICovLFxuLyogMTYgKi8sXG4vKiAxNyAqLyxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgQmVhdXRpZmllciA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KS5CZWF1dGlmaWVyKSxcbiAgT3B0aW9ucyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKS5PcHRpb25zKTtcblxuZnVuY3Rpb24gc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucywganNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSkge1xuICB2YXIgYmVhdXRpZmllciA9IG5ldyBCZWF1dGlmaWVyKGh0bWxfc291cmNlLCBvcHRpb25zLCBqc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5KTtcbiAgcmV0dXJuIGJlYXV0aWZpZXIuYmVhdXRpZnkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHlsZV9odG1sO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBPcHRpb25zKCk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBPcHRpb25zID0gKF9fd2VicGFja19yZXF1aXJlX18oMjApLk9wdGlvbnMpO1xudmFyIE91dHB1dCA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLk91dHB1dCk7XG52YXIgVG9rZW5pemVyID0gKF9fd2VicGFja19yZXF1aXJlX18oMjEpLlRva2VuaXplcik7XG52YXIgVE9LRU4gPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyMSkuVE9LRU4pO1xuXG52YXIgbGluZUJyZWFrID0gL1xcclxcbnxbXFxyXFxuXS87XG52YXIgYWxsTGluZUJyZWFrcyA9IC9cXHJcXG58W1xcclxcbl0vZztcblxudmFyIFByaW50ZXIgPSBmdW5jdGlvbihvcHRpb25zLCBiYXNlX2luZGVudF9zdHJpbmcpIHsgLy9oYW5kbGVzIGlucHV0L291dHB1dCBhbmQgc29tZSBvdGhlciBwcmludGluZyBmdW5jdGlvbnNcblxuICB0aGlzLmluZGVudF9sZXZlbCA9IDA7XG4gIHRoaXMuYWxpZ25tZW50X3NpemUgPSAwO1xuICB0aGlzLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyA9IG9wdGlvbnMubWF4X3ByZXNlcnZlX25ld2xpbmVzO1xuICB0aGlzLnByZXNlcnZlX25ld2xpbmVzID0gb3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcztcblxuICB0aGlzLl9vdXRwdXQgPSBuZXcgT3V0cHV0KG9wdGlvbnMsIGJhc2VfaW5kZW50X3N0cmluZyk7XG5cbn07XG5cblByaW50ZXIucHJvdG90eXBlLmN1cnJlbnRfbGluZV9oYXNfbWF0Y2ggPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHJldHVybiB0aGlzLl9vdXRwdXQuY3VycmVudF9saW5lLmhhc19tYXRjaChwYXR0ZXJuKTtcbn07XG5cblByaW50ZXIucHJvdG90eXBlLnNldF9zcGFjZV9iZWZvcmVfdG9rZW4gPSBmdW5jdGlvbih2YWx1ZSwgbm9uX2JyZWFraW5nKSB7XG4gIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB2YWx1ZTtcbiAgdGhpcy5fb3V0cHV0Lm5vbl9icmVha2luZ19zcGFjZSA9IG5vbl9icmVha2luZztcbn07XG5cblByaW50ZXIucHJvdG90eXBlLnNldF93cmFwX3BvaW50ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX291dHB1dC5zZXRfaW5kZW50KHRoaXMuaW5kZW50X2xldmVsLCB0aGlzLmFsaWdubWVudF9zaXplKTtcbiAgdGhpcy5fb3V0cHV0LnNldF93cmFwX3BvaW50KCk7XG59O1xuXG5cblByaW50ZXIucHJvdG90eXBlLmFkZF9yYXdfdG9rZW4gPSBmdW5jdGlvbih0b2tlbikge1xuICB0aGlzLl9vdXRwdXQuYWRkX3Jhd190b2tlbih0b2tlbik7XG59O1xuXG5QcmludGVyLnByb3RvdHlwZS5wcmludF9wcmVzZXJ2ZWRfbmV3bGluZXMgPSBmdW5jdGlvbihyYXdfdG9rZW4pIHtcbiAgdmFyIG5ld2xpbmVzID0gMDtcbiAgaWYgKHJhd190b2tlbi50eXBlICE9PSBUT0tFTi5URVhUICYmIHJhd190b2tlbi5wcmV2aW91cy50eXBlICE9PSBUT0tFTi5URVhUKSB7XG4gICAgbmV3bGluZXMgPSByYXdfdG9rZW4ubmV3bGluZXMgPyAxIDogMDtcbiAgfVxuXG4gIGlmICh0aGlzLnByZXNlcnZlX25ld2xpbmVzKSB7XG4gICAgbmV3bGluZXMgPSByYXdfdG9rZW4ubmV3bGluZXMgPCB0aGlzLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyArIDEgPyByYXdfdG9rZW4ubmV3bGluZXMgOiB0aGlzLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyArIDE7XG4gIH1cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBuZXdsaW5lczsgbisrKSB7XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKG4gPiAwKTtcbiAgfVxuXG4gIHJldHVybiBuZXdsaW5lcyAhPT0gMDtcbn07XG5cblByaW50ZXIucHJvdG90eXBlLnRyYXZlcnNlX3doaXRlc3BhY2UgPSBmdW5jdGlvbihyYXdfdG9rZW4pIHtcbiAgaWYgKHJhd190b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSB8fCByYXdfdG9rZW4ubmV3bGluZXMpIHtcbiAgICBpZiAoIXRoaXMucHJpbnRfcHJlc2VydmVkX25ld2xpbmVzKHJhd190b2tlbikpIHtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5QcmludGVyLnByb3RvdHlwZS5wcmV2aW91c190b2tlbl93cmFwcGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9vdXRwdXQucHJldmlvdXNfdG9rZW5fd3JhcHBlZDtcbn07XG5cblByaW50ZXIucHJvdG90eXBlLnByaW50X25ld2xpbmUgPSBmdW5jdGlvbihmb3JjZSkge1xuICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKGZvcmNlKTtcbn07XG5cblByaW50ZXIucHJvdG90eXBlLnByaW50X3Rva2VuID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgaWYgKHRva2VuLnRleHQpIHtcbiAgICB0aGlzLl9vdXRwdXQuc2V0X2luZGVudCh0aGlzLmluZGVudF9sZXZlbCwgdGhpcy5hbGlnbm1lbnRfc2l6ZSk7XG4gICAgdGhpcy5fb3V0cHV0LmFkZF90b2tlbih0b2tlbi50ZXh0KTtcbiAgfVxufTtcblxuUHJpbnRlci5wcm90b3R5cGUuaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaW5kZW50X2xldmVsKys7XG59O1xuXG5QcmludGVyLnByb3RvdHlwZS5kZWluZGVudCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pbmRlbnRfbGV2ZWwgPiAwKSB7XG4gICAgdGhpcy5pbmRlbnRfbGV2ZWwtLTtcbiAgICB0aGlzLl9vdXRwdXQuc2V0X2luZGVudCh0aGlzLmluZGVudF9sZXZlbCwgdGhpcy5hbGlnbm1lbnRfc2l6ZSk7XG4gIH1cbn07XG5cblByaW50ZXIucHJvdG90eXBlLmdldF9mdWxsX2luZGVudCA9IGZ1bmN0aW9uKGxldmVsKSB7XG4gIGxldmVsID0gdGhpcy5pbmRlbnRfbGV2ZWwgKyAobGV2ZWwgfHwgMCk7XG4gIGlmIChsZXZlbCA8IDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fb3V0cHV0LmdldF9pbmRlbnRfc3RyaW5nKGxldmVsKTtcbn07XG5cbnZhciBnZXRfdHlwZV9hdHRyaWJ1dGUgPSBmdW5jdGlvbihzdGFydF90b2tlbikge1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgdmFyIHJhd190b2tlbiA9IHN0YXJ0X3Rva2VuLm5leHQ7XG5cbiAgLy8gU2VhcmNoIGF0dHJpYnV0ZXMgZm9yIGEgdHlwZSBhdHRyaWJ1dGVcbiAgd2hpbGUgKHJhd190b2tlbi50eXBlICE9PSBUT0tFTi5FT0YgJiYgc3RhcnRfdG9rZW4uY2xvc2VkICE9PSByYXdfdG9rZW4pIHtcbiAgICBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLkFUVFJJQlVURSAmJiByYXdfdG9rZW4udGV4dCA9PT0gJ3R5cGUnKSB7XG4gICAgICBpZiAocmF3X3Rva2VuLm5leHQgJiYgcmF3X3Rva2VuLm5leHQudHlwZSA9PT0gVE9LRU4uRVFVQUxTICYmXG4gICAgICAgIHJhd190b2tlbi5uZXh0Lm5leHQgJiYgcmF3X3Rva2VuLm5leHQubmV4dC50eXBlID09PSBUT0tFTi5WQUxVRSkge1xuICAgICAgICByZXN1bHQgPSByYXdfdG9rZW4ubmV4dC5uZXh0LnRleHQ7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmF3X3Rva2VuID0gcmF3X3Rva2VuLm5leHQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGdldF9jdXN0b21fYmVhdXRpZmllcl9uYW1lID0gZnVuY3Rpb24odGFnX2NoZWNrLCByYXdfdG9rZW4pIHtcbiAgdmFyIHR5cGVBdHRyaWJ1dGUgPSBudWxsO1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICBpZiAoIXJhd190b2tlbi5jbG9zZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0YWdfY2hlY2sgPT09ICdzY3JpcHQnKSB7XG4gICAgdHlwZUF0dHJpYnV0ZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICB9IGVsc2UgaWYgKHRhZ19jaGVjayA9PT0gJ3N0eWxlJykge1xuICAgIHR5cGVBdHRyaWJ1dGUgPSAndGV4dC9jc3MnO1xuICB9XG5cbiAgdHlwZUF0dHJpYnV0ZSA9IGdldF90eXBlX2F0dHJpYnV0ZShyYXdfdG9rZW4pIHx8IHR5cGVBdHRyaWJ1dGU7XG5cbiAgLy8gRm9yIHNjcmlwdCBhbmQgc3R5bGUgdGFncyB0aGF0IGhhdmUgYSB0eXBlIGF0dHJpYnV0ZSwgb25seSBlbmFibGUgY3VzdG9tIGJlYXV0aWZpZXJzIGZvciBtYXRjaGluZyB2YWx1ZXNcbiAgLy8gRm9yIHRob3NlIHdpdGhvdXQgYSB0eXBlIGF0dHJpYnV0ZSB1c2UgZGVmYXVsdDtcbiAgaWYgKHR5cGVBdHRyaWJ1dGUuc2VhcmNoKCd0ZXh0L2NzcycpID4gLTEpIHtcbiAgICByZXN1bHQgPSAnY3NzJztcbiAgfSBlbHNlIGlmICh0eXBlQXR0cmlidXRlLnNlYXJjaCgvbW9kdWxlfCgodGV4dHxhcHBsaWNhdGlvbnxkb2pvKVxcLyh4LSk/KGphdmFzY3JpcHR8ZWNtYXNjcmlwdHxqc2NyaXB0fGxpdmVzY3JpcHR8KGxkXFwrKT9qc29ufG1ldGhvZHxhc3BlY3QpKS8pID4gLTEpIHtcbiAgICByZXN1bHQgPSAnamF2YXNjcmlwdCc7XG4gIH0gZWxzZSBpZiAodHlwZUF0dHJpYnV0ZS5zZWFyY2goLyh0ZXh0fGFwcGxpY2F0aW9ufGRvam8pXFwvKHgtKT8oaHRtbCkvKSA+IC0xKSB7XG4gICAgcmVzdWx0ID0gJ2h0bWwnO1xuICB9IGVsc2UgaWYgKHR5cGVBdHRyaWJ1dGUuc2VhcmNoKC90ZXN0XFwvbnVsbC8pID4gLTEpIHtcbiAgICAvLyBUZXN0IG9ubHkgbWltZS10eXBlIGZvciB0ZXN0aW5nIHRoZSBiZWF1dGlmaWVyIHdoZW4gbnVsbCBpcyBwYXNzZWQgYXMgYmVhdXRpZmluZyBmdW5jdGlvblxuICAgIHJlc3VsdCA9ICdudWxsJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBpbl9hcnJheSh3aGF0LCBhcnIpIHtcbiAgcmV0dXJuIGFyci5pbmRleE9mKHdoYXQpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gVGFnRnJhbWUocGFyZW50LCBwYXJzZXJfdG9rZW4sIGluZGVudF9sZXZlbCkge1xuICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuICB0aGlzLnRhZyA9IHBhcnNlcl90b2tlbiA/IHBhcnNlcl90b2tlbi50YWdfbmFtZSA6ICcnO1xuICB0aGlzLmluZGVudF9sZXZlbCA9IGluZGVudF9sZXZlbCB8fCAwO1xuICB0aGlzLnBhcnNlcl90b2tlbiA9IHBhcnNlcl90b2tlbiB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiBUYWdTdGFjayhwcmludGVyKSB7XG4gIHRoaXMuX3ByaW50ZXIgPSBwcmludGVyO1xuICB0aGlzLl9jdXJyZW50X2ZyYW1lID0gbnVsbDtcbn1cblxuVGFnU3RhY2sucHJvdG90eXBlLmdldF9wYXJzZXJfdG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2N1cnJlbnRfZnJhbWUgPyB0aGlzLl9jdXJyZW50X2ZyYW1lLnBhcnNlcl90b2tlbiA6IG51bGw7XG59O1xuXG5UYWdTdGFjay5wcm90b3R5cGUucmVjb3JkX3RhZyA9IGZ1bmN0aW9uKHBhcnNlcl90b2tlbikgeyAvL2Z1bmN0aW9uIHRvIHJlY29yZCBhIHRhZyBhbmQgaXRzIHBhcmVudCBpbiB0aGlzLnRhZ3MgT2JqZWN0XG4gIHZhciBuZXdfZnJhbWUgPSBuZXcgVGFnRnJhbWUodGhpcy5fY3VycmVudF9mcmFtZSwgcGFyc2VyX3Rva2VuLCB0aGlzLl9wcmludGVyLmluZGVudF9sZXZlbCk7XG4gIHRoaXMuX2N1cnJlbnRfZnJhbWUgPSBuZXdfZnJhbWU7XG59O1xuXG5UYWdTdGFjay5wcm90b3R5cGUuX3RyeV9wb3BfZnJhbWUgPSBmdW5jdGlvbihmcmFtZSkgeyAvL2Z1bmN0aW9uIHRvIHJldHJpZXZlIHRoZSBvcGVuaW5nIHRhZyB0byB0aGUgY29ycmVzcG9uZGluZyBjbG9zZXJcbiAgdmFyIHBhcnNlcl90b2tlbiA9IG51bGw7XG5cbiAgaWYgKGZyYW1lKSB7XG4gICAgcGFyc2VyX3Rva2VuID0gZnJhbWUucGFyc2VyX3Rva2VuO1xuICAgIHRoaXMuX3ByaW50ZXIuaW5kZW50X2xldmVsID0gZnJhbWUuaW5kZW50X2xldmVsO1xuICAgIHRoaXMuX2N1cnJlbnRfZnJhbWUgPSBmcmFtZS5wYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gcGFyc2VyX3Rva2VuO1xufTtcblxuVGFnU3RhY2sucHJvdG90eXBlLl9nZXRfZnJhbWUgPSBmdW5jdGlvbih0YWdfbGlzdCwgc3RvcF9saXN0KSB7IC8vZnVuY3Rpb24gdG8gcmV0cmlldmUgdGhlIG9wZW5pbmcgdGFnIHRvIHRoZSBjb3JyZXNwb25kaW5nIGNsb3NlclxuICB2YXIgZnJhbWUgPSB0aGlzLl9jdXJyZW50X2ZyYW1lO1xuXG4gIHdoaWxlIChmcmFtZSkgeyAvL3RpbGwgd2UgcmVhY2ggJycgKHRoZSBpbml0aWFsIHZhbHVlKTtcbiAgICBpZiAodGFnX2xpc3QuaW5kZXhPZihmcmFtZS50YWcpICE9PSAtMSkgeyAvL2lmIHRoaXMgaXMgaXQgdXNlIGl0XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKHN0b3BfbGlzdCAmJiBzdG9wX2xpc3QuaW5kZXhPZihmcmFtZS50YWcpICE9PSAtMSkge1xuICAgICAgZnJhbWUgPSBudWxsO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZyYW1lID0gZnJhbWUucGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIGZyYW1lO1xufTtcblxuVGFnU3RhY2sucHJvdG90eXBlLnRyeV9wb3AgPSBmdW5jdGlvbih0YWcsIHN0b3BfbGlzdCkgeyAvL2Z1bmN0aW9uIHRvIHJldHJpZXZlIHRoZSBvcGVuaW5nIHRhZyB0byB0aGUgY29ycmVzcG9uZGluZyBjbG9zZXJcbiAgdmFyIGZyYW1lID0gdGhpcy5fZ2V0X2ZyYW1lKFt0YWddLCBzdG9wX2xpc3QpO1xuICByZXR1cm4gdGhpcy5fdHJ5X3BvcF9mcmFtZShmcmFtZSk7XG59O1xuXG5UYWdTdGFjay5wcm90b3R5cGUuaW5kZW50X3RvX3RhZyA9IGZ1bmN0aW9uKHRhZ19saXN0KSB7XG4gIHZhciBmcmFtZSA9IHRoaXMuX2dldF9mcmFtZSh0YWdfbGlzdCk7XG4gIGlmIChmcmFtZSkge1xuICAgIHRoaXMuX3ByaW50ZXIuaW5kZW50X2xldmVsID0gZnJhbWUuaW5kZW50X2xldmVsO1xuICB9XG59O1xuXG5mdW5jdGlvbiBCZWF1dGlmaWVyKHNvdXJjZV90ZXh0LCBvcHRpb25zLCBqc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5KSB7XG4gIC8vV3JhcHBlciBmdW5jdGlvbiB0byBpbnZva2UgYWxsIHRoZSBuZWNlc3NhcnkgY29uc3RydWN0b3JzIGFuZCBkZWFsIHdpdGggdGhlIG91dHB1dC5cbiAgdGhpcy5fc291cmNlX3RleHQgPSBzb3VyY2VfdGV4dCB8fCAnJztcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX2pzX2JlYXV0aWZ5ID0ganNfYmVhdXRpZnk7XG4gIHRoaXMuX2Nzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeTtcbiAgdGhpcy5fdGFnX3N0YWNrID0gbnVsbDtcblxuICAvLyBBbGxvdyB0aGUgc2V0dGluZyBvZiBsYW5ndWFnZS9maWxlLXR5cGUgc3BlY2lmaWMgb3B0aW9uc1xuICAvLyB3aXRoIGluaGVyaXRhbmNlIG9mIG92ZXJhbGwgc2V0dGluZ3NcbiAgdmFyIG9wdGlvbkh0bWwgPSBuZXcgT3B0aW9ucyhvcHRpb25zLCAnaHRtbCcpO1xuXG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25IdG1sO1xuXG4gIHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19mb3JjZSA9IHRoaXMuX29wdGlvbnMud3JhcF9hdHRyaWJ1dGVzLnN1YnN0cigwLCAnZm9yY2UnLmxlbmd0aCkgPT09ICdmb3JjZSc7XG4gIHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19mb3JjZV9leHBhbmRfbXVsdGlsaW5lID0gKHRoaXMuX29wdGlvbnMud3JhcF9hdHRyaWJ1dGVzID09PSAnZm9yY2UtZXhwYW5kLW11bHRpbGluZScpO1xuICB0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfYWxpZ25lZCA9ICh0aGlzLl9vcHRpb25zLndyYXBfYXR0cmlidXRlcyA9PT0gJ2ZvcmNlLWFsaWduZWQnKTtcbiAgdGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX2FsaWduZWRfbXVsdGlwbGUgPSAodGhpcy5fb3B0aW9ucy53cmFwX2F0dHJpYnV0ZXMgPT09ICdhbGlnbmVkLW11bHRpcGxlJyk7XG4gIHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19wcmVzZXJ2ZSA9IHRoaXMuX29wdGlvbnMud3JhcF9hdHRyaWJ1dGVzLnN1YnN0cigwLCAncHJlc2VydmUnLmxlbmd0aCkgPT09ICdwcmVzZXJ2ZSc7XG4gIHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19wcmVzZXJ2ZV9hbGlnbmVkID0gKHRoaXMuX29wdGlvbnMud3JhcF9hdHRyaWJ1dGVzID09PSAncHJlc2VydmUtYWxpZ25lZCcpO1xufVxuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5iZWF1dGlmeSA9IGZ1bmN0aW9uKCkge1xuXG4gIC8vIGlmIGRpc2FibGVkLCByZXR1cm4gdGhlIGlucHV0IHVuY2hhbmdlZC5cbiAgaWYgKHRoaXMuX29wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlX3RleHQ7XG4gIH1cblxuICB2YXIgc291cmNlX3RleHQgPSB0aGlzLl9zb3VyY2VfdGV4dDtcbiAgdmFyIGVvbCA9IHRoaXMuX29wdGlvbnMuZW9sO1xuICBpZiAodGhpcy5fb3B0aW9ucy5lb2wgPT09ICdhdXRvJykge1xuICAgIGVvbCA9ICdcXG4nO1xuICAgIGlmIChzb3VyY2VfdGV4dCAmJiBsaW5lQnJlYWsudGVzdChzb3VyY2VfdGV4dCkpIHtcbiAgICAgIGVvbCA9IHNvdXJjZV90ZXh0Lm1hdGNoKGxpbmVCcmVhaylbMF07XG4gICAgfVxuICB9XG5cbiAgLy8gSEFDSzogbmV3bGluZSBwYXJzaW5nIGluY29uc2lzdGVudC4gVGhpcyBicnV0ZSBmb3JjZSBub3JtYWxpemVzIHRoZSBpbnB1dC5cbiAgc291cmNlX3RleHQgPSBzb3VyY2VfdGV4dC5yZXBsYWNlKGFsbExpbmVCcmVha3MsICdcXG4nKTtcblxuICB2YXIgYmFzZUluZGVudFN0cmluZyA9IHNvdXJjZV90ZXh0Lm1hdGNoKC9eW1xcdCBdKi8pWzBdO1xuXG4gIHZhciBsYXN0X3Rva2VuID0ge1xuICAgIHRleHQ6ICcnLFxuICAgIHR5cGU6ICcnXG4gIH07XG5cbiAgdmFyIGxhc3RfdGFnX3Rva2VuID0gbmV3IFRhZ09wZW5QYXJzZXJUb2tlbigpO1xuXG4gIHZhciBwcmludGVyID0gbmV3IFByaW50ZXIodGhpcy5fb3B0aW9ucywgYmFzZUluZGVudFN0cmluZyk7XG4gIHZhciB0b2tlbnMgPSBuZXcgVG9rZW5pemVyKHNvdXJjZV90ZXh0LCB0aGlzLl9vcHRpb25zKS50b2tlbml6ZSgpO1xuXG4gIHRoaXMuX3RhZ19zdGFjayA9IG5ldyBUYWdTdGFjayhwcmludGVyKTtcblxuICB2YXIgcGFyc2VyX3Rva2VuID0gbnVsbDtcbiAgdmFyIHJhd190b2tlbiA9IHRva2Vucy5uZXh0KCk7XG4gIHdoaWxlIChyYXdfdG9rZW4udHlwZSAhPT0gVE9LRU4uRU9GKSB7XG5cbiAgICBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLlRBR19PUEVOIHx8IHJhd190b2tlbi50eXBlID09PSBUT0tFTi5DT01NRU5UKSB7XG4gICAgICBwYXJzZXJfdG9rZW4gPSB0aGlzLl9oYW5kbGVfdGFnX29wZW4ocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbiwgbGFzdF90b2tlbiwgdG9rZW5zKTtcbiAgICAgIGxhc3RfdGFnX3Rva2VuID0gcGFyc2VyX3Rva2VuO1xuICAgIH0gZWxzZSBpZiAoKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5BVFRSSUJVVEUgfHwgcmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVRVUFMUyB8fCByYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uVkFMVUUpIHx8XG4gICAgICAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLlRFWFQgJiYgIWxhc3RfdGFnX3Rva2VuLnRhZ19jb21wbGV0ZSkpIHtcbiAgICAgIHBhcnNlcl90b2tlbiA9IHRoaXMuX2hhbmRsZV9pbnNpZGVfdGFnKHByaW50ZXIsIHJhd190b2tlbiwgbGFzdF90YWdfdG9rZW4sIGxhc3RfdG9rZW4pO1xuICAgIH0gZWxzZSBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLlRBR19DTE9TRSkge1xuICAgICAgcGFyc2VyX3Rva2VuID0gdGhpcy5faGFuZGxlX3RhZ19jbG9zZShwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuKTtcbiAgICB9IGVsc2UgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5URVhUKSB7XG4gICAgICBwYXJzZXJfdG9rZW4gPSB0aGlzLl9oYW5kbGVfdGV4dChwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuKTtcbiAgICB9IGVsc2UgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5DT05UUk9MX0ZMT1dfT1BFTikge1xuICAgICAgcGFyc2VyX3Rva2VuID0gdGhpcy5faGFuZGxlX2NvbnRyb2xfZmxvd19vcGVuKHByaW50ZXIsIHJhd190b2tlbik7XG4gICAgfSBlbHNlIGlmIChyYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09OVFJPTF9GTE9XX0NMT1NFKSB7XG4gICAgICBwYXJzZXJfdG9rZW4gPSB0aGlzLl9oYW5kbGVfY29udHJvbF9mbG93X2Nsb3NlKHByaW50ZXIsIHJhd190b2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IGlmIGl0IGRvZXMuIFByaW50IHRoZSByYXcgdG9rZW5cbiAgICAgIHByaW50ZXIuYWRkX3Jhd190b2tlbihyYXdfdG9rZW4pO1xuICAgIH1cblxuICAgIGxhc3RfdG9rZW4gPSBwYXJzZXJfdG9rZW47XG5cbiAgICByYXdfdG9rZW4gPSB0b2tlbnMubmV4dCgpO1xuICB9XG4gIHZhciBzd2VldF9jb2RlID0gcHJpbnRlci5fb3V0cHV0LmdldF9jb2RlKGVvbCk7XG5cbiAgcmV0dXJuIHN3ZWV0X2NvZGU7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5faGFuZGxlX2NvbnRyb2xfZmxvd19vcGVuID0gZnVuY3Rpb24ocHJpbnRlciwgcmF3X3Rva2VuKSB7XG4gIHZhciBwYXJzZXJfdG9rZW4gPSB7XG4gICAgdGV4dDogcmF3X3Rva2VuLnRleHQsXG4gICAgdHlwZTogcmF3X3Rva2VuLnR5cGVcbiAgfTtcbiAgcHJpbnRlci5zZXRfc3BhY2VfYmVmb3JlX3Rva2VuKHJhd190b2tlbi5uZXdsaW5lcyB8fCByYXdfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUgIT09ICcnLCB0cnVlKTtcbiAgaWYgKHJhd190b2tlbi5uZXdsaW5lcykge1xuICAgIHByaW50ZXIucHJpbnRfcHJlc2VydmVkX25ld2xpbmVzKHJhd190b2tlbik7XG4gIH0gZWxzZSB7XG4gICAgcHJpbnRlci5zZXRfc3BhY2VfYmVmb3JlX3Rva2VuKHJhd190b2tlbi5uZXdsaW5lcyB8fCByYXdfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUgIT09ICcnLCB0cnVlKTtcbiAgfVxuICBwcmludGVyLnByaW50X3Rva2VuKHJhd190b2tlbik7XG4gIHByaW50ZXIuaW5kZW50KCk7XG4gIHJldHVybiBwYXJzZXJfdG9rZW47XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5faGFuZGxlX2NvbnRyb2xfZmxvd19jbG9zZSA9IGZ1bmN0aW9uKHByaW50ZXIsIHJhd190b2tlbikge1xuICB2YXIgcGFyc2VyX3Rva2VuID0ge1xuICAgIHRleHQ6IHJhd190b2tlbi50ZXh0LFxuICAgIHR5cGU6IHJhd190b2tlbi50eXBlXG4gIH07XG5cbiAgcHJpbnRlci5kZWluZGVudCgpO1xuICBpZiAocmF3X3Rva2VuLm5ld2xpbmVzKSB7XG4gICAgcHJpbnRlci5wcmludF9wcmVzZXJ2ZWRfbmV3bGluZXMocmF3X3Rva2VuKTtcbiAgfSBlbHNlIHtcbiAgICBwcmludGVyLnNldF9zcGFjZV9iZWZvcmVfdG9rZW4ocmF3X3Rva2VuLm5ld2xpbmVzIHx8IHJhd190b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSAhPT0gJycsIHRydWUpO1xuICB9XG4gIHByaW50ZXIucHJpbnRfdG9rZW4ocmF3X3Rva2VuKTtcbiAgcmV0dXJuIHBhcnNlcl90b2tlbjtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLl9oYW5kbGVfdGFnX2Nsb3NlID0gZnVuY3Rpb24ocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbikge1xuICB2YXIgcGFyc2VyX3Rva2VuID0ge1xuICAgIHRleHQ6IHJhd190b2tlbi50ZXh0LFxuICAgIHR5cGU6IHJhd190b2tlbi50eXBlXG4gIH07XG4gIHByaW50ZXIuYWxpZ25tZW50X3NpemUgPSAwO1xuICBsYXN0X3RhZ190b2tlbi50YWdfY29tcGxldGUgPSB0cnVlO1xuXG4gIHByaW50ZXIuc2V0X3NwYWNlX2JlZm9yZV90b2tlbihyYXdfdG9rZW4ubmV3bGluZXMgfHwgcmF3X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlICE9PSAnJywgdHJ1ZSk7XG4gIGlmIChsYXN0X3RhZ190b2tlbi5pc191bmZvcm1hdHRlZCkge1xuICAgIHByaW50ZXIuYWRkX3Jhd190b2tlbihyYXdfdG9rZW4pO1xuICB9IGVsc2Uge1xuICAgIGlmIChsYXN0X3RhZ190b2tlbi50YWdfc3RhcnRfY2hhciA9PT0gJzwnKSB7XG4gICAgICBwcmludGVyLnNldF9zcGFjZV9iZWZvcmVfdG9rZW4ocmF3X3Rva2VuLnRleHRbMF0gPT09ICcvJywgdHJ1ZSk7IC8vIHNwYWNlIGJlZm9yZSAvPiwgbm8gc3BhY2UgYmVmb3JlID5cbiAgICAgIGlmICh0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfZXhwYW5kX211bHRpbGluZSAmJiBsYXN0X3RhZ190b2tlbi5oYXNfd3JhcHBlZF9hdHRycykge1xuICAgICAgICBwcmludGVyLnByaW50X25ld2xpbmUoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBwcmludGVyLnByaW50X3Rva2VuKHJhd190b2tlbik7XG5cbiAgfVxuXG4gIGlmIChsYXN0X3RhZ190b2tlbi5pbmRlbnRfY29udGVudCAmJlxuICAgICEobGFzdF90YWdfdG9rZW4uaXNfdW5mb3JtYXR0ZWQgfHwgbGFzdF90YWdfdG9rZW4uaXNfY29udGVudF91bmZvcm1hdHRlZCkpIHtcbiAgICBwcmludGVyLmluZGVudCgpO1xuXG4gICAgLy8gb25seSBpbmRlbnQgb25jZSBwZXIgb3BlbmVkIHRhZ1xuICAgIGxhc3RfdGFnX3Rva2VuLmluZGVudF9jb250ZW50ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoIWxhc3RfdGFnX3Rva2VuLmlzX2lubGluZV9lbGVtZW50ICYmXG4gICAgIShsYXN0X3RhZ190b2tlbi5pc191bmZvcm1hdHRlZCB8fCBsYXN0X3RhZ190b2tlbi5pc19jb250ZW50X3VuZm9ybWF0dGVkKSkge1xuICAgIHByaW50ZXIuc2V0X3dyYXBfcG9pbnQoKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZXJfdG9rZW47XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5faGFuZGxlX2luc2lkZV90YWcgPSBmdW5jdGlvbihwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuLCBsYXN0X3Rva2VuKSB7XG4gIHZhciB3cmFwcGVkID0gbGFzdF90YWdfdG9rZW4uaGFzX3dyYXBwZWRfYXR0cnM7XG4gIHZhciBwYXJzZXJfdG9rZW4gPSB7XG4gICAgdGV4dDogcmF3X3Rva2VuLnRleHQsXG4gICAgdHlwZTogcmF3X3Rva2VuLnR5cGVcbiAgfTtcblxuICBwcmludGVyLnNldF9zcGFjZV9iZWZvcmVfdG9rZW4ocmF3X3Rva2VuLm5ld2xpbmVzIHx8IHJhd190b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSAhPT0gJycsIHRydWUpO1xuICBpZiAobGFzdF90YWdfdG9rZW4uaXNfdW5mb3JtYXR0ZWQpIHtcbiAgICBwcmludGVyLmFkZF9yYXdfdG9rZW4ocmF3X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChsYXN0X3RhZ190b2tlbi50YWdfc3RhcnRfY2hhciA9PT0gJ3snICYmIHJhd190b2tlbi50eXBlID09PSBUT0tFTi5URVhUKSB7XG4gICAgLy8gRm9yIHRoZSBpbnNpZGVzIG9mIGhhbmRsZWJhcnMgYWxsb3cgbmV3bGluZXMgb3IgYSBzaW5nbGUgc3BhY2UgYmV0d2VlbiBvcGVuIGFuZCBjb250ZW50c1xuICAgIGlmIChwcmludGVyLnByaW50X3ByZXNlcnZlZF9uZXdsaW5lcyhyYXdfdG9rZW4pKSB7XG4gICAgICByYXdfdG9rZW4ubmV3bGluZXMgPSAwO1xuICAgICAgcHJpbnRlci5hZGRfcmF3X3Rva2VuKHJhd190b2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByaW50ZXIucHJpbnRfdG9rZW4ocmF3X3Rva2VuKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5BVFRSSUJVVEUpIHtcbiAgICAgIHByaW50ZXIuc2V0X3NwYWNlX2JlZm9yZV90b2tlbih0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5FUVVBTFMpIHsgLy9ubyBzcGFjZSBiZWZvcmUgPVxuICAgICAgcHJpbnRlci5zZXRfc3BhY2VfYmVmb3JlX3Rva2VuKGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5WQUxVRSAmJiByYXdfdG9rZW4ucHJldmlvdXMudHlwZSA9PT0gVE9LRU4uRVFVQUxTKSB7IC8vbm8gc3BhY2UgYmVmb3JlIHZhbHVlXG4gICAgICBwcmludGVyLnNldF9zcGFjZV9iZWZvcmVfdG9rZW4oZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChyYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uQVRUUklCVVRFICYmIGxhc3RfdGFnX3Rva2VuLnRhZ19zdGFydF9jaGFyID09PSAnPCcpIHtcbiAgICAgIGlmICh0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfcHJlc2VydmUgfHwgdGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX3ByZXNlcnZlX2FsaWduZWQpIHtcbiAgICAgICAgcHJpbnRlci50cmF2ZXJzZV93aGl0ZXNwYWNlKHJhd190b2tlbik7XG4gICAgICAgIHdyYXBwZWQgPSB3cmFwcGVkIHx8IHJhd190b2tlbi5uZXdsaW5lcyAhPT0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gV3JhcCBmb3IgJ2ZvcmNlJyBvcHRpb25zLCBhbmQgaWYgdGhlIG51bWJlciBvZiBhdHRyaWJ1dGVzIGlzIGF0IGxlYXN0IHRoYXQgc3BlY2lmaWVkIGluICd3cmFwX2F0dHJpYnV0ZXNfbWluX2F0dHJzJzpcbiAgICAgIC8vIDEuIGFsd2F5cyB3cmFwIHRoZSBzZWNvbmQgYW5kIGJleW9uZCBhdHRyaWJ1dGVzXG4gICAgICAvLyAyLiB3cmFwIHRoZSBmaXJzdCBhdHRyaWJ1dGUgb25seSBpZiAnZm9yY2UtZXhwYW5kLW11bHRpbGluZScgaXMgc3BlY2lmaWVkXG4gICAgICBpZiAodGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlICYmXG4gICAgICAgIGxhc3RfdGFnX3Rva2VuLmF0dHJfY291bnQgPj0gdGhpcy5fb3B0aW9ucy53cmFwX2F0dHJpYnV0ZXNfbWluX2F0dHJzICYmXG4gICAgICAgIChsYXN0X3Rva2VuLnR5cGUgIT09IFRPS0VOLlRBR19PUEVOIHx8IC8vIGllLiBzZWNvbmQgYXR0cmlidXRlIGFuZCBiZXlvbmRcbiAgICAgICAgICB0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfZXhwYW5kX211bHRpbGluZSkpIHtcbiAgICAgICAgcHJpbnRlci5wcmludF9uZXdsaW5lKGZhbHNlKTtcbiAgICAgICAgd3JhcHBlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHByaW50ZXIucHJpbnRfdG9rZW4ocmF3X3Rva2VuKTtcbiAgICB3cmFwcGVkID0gd3JhcHBlZCB8fCBwcmludGVyLnByZXZpb3VzX3Rva2VuX3dyYXBwZWQoKTtcbiAgICBsYXN0X3RhZ190b2tlbi5oYXNfd3JhcHBlZF9hdHRycyA9IHdyYXBwZWQ7XG4gIH1cbiAgcmV0dXJuIHBhcnNlcl90b2tlbjtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLl9oYW5kbGVfdGV4dCA9IGZ1bmN0aW9uKHByaW50ZXIsIHJhd190b2tlbiwgbGFzdF90YWdfdG9rZW4pIHtcbiAgdmFyIHBhcnNlcl90b2tlbiA9IHtcbiAgICB0ZXh0OiByYXdfdG9rZW4udGV4dCxcbiAgICB0eXBlOiAnVEtfQ09OVEVOVCdcbiAgfTtcbiAgaWYgKGxhc3RfdGFnX3Rva2VuLmN1c3RvbV9iZWF1dGlmaWVyX25hbWUpIHsgLy9jaGVjayBpZiB3ZSBuZWVkIHRvIGZvcm1hdCBqYXZhc2NyaXB0XG4gICAgdGhpcy5fcHJpbnRfY3VzdG9tX2JlYXRpZmllcl90ZXh0KHByaW50ZXIsIHJhd190b2tlbiwgbGFzdF90YWdfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGxhc3RfdGFnX3Rva2VuLmlzX3VuZm9ybWF0dGVkIHx8IGxhc3RfdGFnX3Rva2VuLmlzX2NvbnRlbnRfdW5mb3JtYXR0ZWQpIHtcbiAgICBwcmludGVyLmFkZF9yYXdfdG9rZW4ocmF3X3Rva2VuKTtcbiAgfSBlbHNlIHtcbiAgICBwcmludGVyLnRyYXZlcnNlX3doaXRlc3BhY2UocmF3X3Rva2VuKTtcbiAgICBwcmludGVyLnByaW50X3Rva2VuKHJhd190b2tlbik7XG4gIH1cbiAgcmV0dXJuIHBhcnNlcl90b2tlbjtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLl9wcmludF9jdXN0b21fYmVhdGlmaWVyX3RleHQgPSBmdW5jdGlvbihwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuKSB7XG4gIHZhciBsb2NhbCA9IHRoaXM7XG4gIGlmIChyYXdfdG9rZW4udGV4dCAhPT0gJycpIHtcblxuICAgIHZhciB0ZXh0ID0gcmF3X3Rva2VuLnRleHQsXG4gICAgICBfYmVhdXRpZmllcixcbiAgICAgIHNjcmlwdF9pbmRlbnRfbGV2ZWwgPSAxLFxuICAgICAgcHJlID0gJycsXG4gICAgICBwb3N0ID0gJyc7XG4gICAgaWYgKGxhc3RfdGFnX3Rva2VuLmN1c3RvbV9iZWF1dGlmaWVyX25hbWUgPT09ICdqYXZhc2NyaXB0JyAmJiB0eXBlb2YgdGhpcy5fanNfYmVhdXRpZnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIF9iZWF1dGlmaWVyID0gdGhpcy5fanNfYmVhdXRpZnk7XG4gICAgfSBlbHNlIGlmIChsYXN0X3RhZ190b2tlbi5jdXN0b21fYmVhdXRpZmllcl9uYW1lID09PSAnY3NzJyAmJiB0eXBlb2YgdGhpcy5fY3NzX2JlYXV0aWZ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBfYmVhdXRpZmllciA9IHRoaXMuX2Nzc19iZWF1dGlmeTtcbiAgICB9IGVsc2UgaWYgKGxhc3RfdGFnX3Rva2VuLmN1c3RvbV9iZWF1dGlmaWVyX25hbWUgPT09ICdodG1sJykge1xuICAgICAgX2JlYXV0aWZpZXIgPSBmdW5jdGlvbihodG1sX3NvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgYmVhdXRpZmllciA9IG5ldyBCZWF1dGlmaWVyKGh0bWxfc291cmNlLCBvcHRpb25zLCBsb2NhbC5fanNfYmVhdXRpZnksIGxvY2FsLl9jc3NfYmVhdXRpZnkpO1xuICAgICAgICByZXR1cm4gYmVhdXRpZmllci5iZWF1dGlmeSgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5pbmRlbnRfc2NyaXB0cyA9PT0gXCJrZWVwXCIpIHtcbiAgICAgIHNjcmlwdF9pbmRlbnRfbGV2ZWwgPSAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5pbmRlbnRfc2NyaXB0cyA9PT0gXCJzZXBhcmF0ZVwiKSB7XG4gICAgICBzY3JpcHRfaW5kZW50X2xldmVsID0gLXByaW50ZXIuaW5kZW50X2xldmVsO1xuICAgIH1cblxuICAgIHZhciBpbmRlbnRhdGlvbiA9IHByaW50ZXIuZ2V0X2Z1bGxfaW5kZW50KHNjcmlwdF9pbmRlbnRfbGV2ZWwpO1xuXG4gICAgLy8gaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGVtcHR5IGxpbmUgYXQgdGhlIGVuZCBvZiB0aGlzIHRleHQsIHN0cmlwIGl0XG4gICAgLy8gd2UnbGwgYmUgYWRkaW5nIG9uZSBiYWNrIGFmdGVyIHRoZSB0ZXh0IGJ1dCBiZWZvcmUgdGhlIGNvbnRhaW5pbmcgdGFnLlxuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcblsgXFx0XSokLywgJycpO1xuXG4gICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIGNvbnRlbnQgaXMgd3JhcHBlZCBpbiBhIGNvbW1lbnQgb3IgY2RhdGEuXG4gICAgaWYgKGxhc3RfdGFnX3Rva2VuLmN1c3RvbV9iZWF1dGlmaWVyX25hbWUgIT09ICdodG1sJyAmJlxuICAgICAgdGV4dFswXSA9PT0gJzwnICYmIHRleHQubWF0Y2goL14oPCEtLXw8IVxcW0NEQVRBXFxbKS8pKSB7XG4gICAgICB2YXIgbWF0Y2hlZCA9IC9eKDwhLS1bXlxcbl0qfDwhXFxbQ0RBVEFcXFspKFxcbj8pKFsgXFx0XFxuXSopKFtcXHNcXFNdKikoLS0+fF1dPikkLy5leGVjKHRleHQpO1xuXG4gICAgICAvLyBpZiB3ZSBzdGFydCB0byB3cmFwIGJ1dCBkb24ndCBmaW5pc2gsIHByaW50IHJhd1xuICAgICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICAgIHByaW50ZXIuYWRkX3Jhd190b2tlbihyYXdfdG9rZW4pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHByZSA9IGluZGVudGF0aW9uICsgbWF0Y2hlZFsxXSArICdcXG4nO1xuICAgICAgdGV4dCA9IG1hdGNoZWRbNF07XG4gICAgICBpZiAobWF0Y2hlZFs1XSkge1xuICAgICAgICBwb3N0ID0gaW5kZW50YXRpb24gKyBtYXRjaGVkWzVdO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgZW1wdHkgbGluZSBhdCB0aGUgZW5kIG9mIHRoaXMgdGV4dCwgc3RyaXAgaXRcbiAgICAgIC8vIHdlJ2xsIGJlIGFkZGluZyBvbmUgYmFjayBhZnRlciB0aGUgdGV4dCBidXQgYmVmb3JlIHRoZSBjb250YWluaW5nIHRhZy5cbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcblsgXFx0XSokLywgJycpO1xuXG4gICAgICBpZiAobWF0Y2hlZFsyXSB8fCBtYXRjaGVkWzNdLmluZGV4T2YoJ1xcbicpICE9PSAtMSkge1xuICAgICAgICAvLyBpZiB0aGUgZmlyc3QgbGluZSBvZiB0aGUgbm9uLWNvbW1lbnQgdGV4dCBoYXMgc3BhY2VzXG4gICAgICAgIC8vIHVzZSB0aGF0IGFzIHRoZSBiYXNpcyBmb3IgaW5kZW50aW5nIGluIG51bGwgY2FzZS5cbiAgICAgICAgbWF0Y2hlZCA9IG1hdGNoZWRbM10ubWF0Y2goL1sgXFx0XSskLyk7XG4gICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgcmF3X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlID0gbWF0Y2hlZFswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0ZXh0KSB7XG4gICAgICBpZiAoX2JlYXV0aWZpZXIpIHtcblxuICAgICAgICAvLyBjYWxsIHRoZSBCZWF1dGlmaWVyIGlmIGF2YWxpYWJsZVxuICAgICAgICB2YXIgQ2hpbGRfb3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuZW9sID0gJ1xcbic7XG4gICAgICAgIH07XG4gICAgICAgIENoaWxkX29wdGlvbnMucHJvdG90eXBlID0gdGhpcy5fb3B0aW9ucy5yYXdfb3B0aW9ucztcbiAgICAgICAgdmFyIGNoaWxkX29wdGlvbnMgPSBuZXcgQ2hpbGRfb3B0aW9ucygpO1xuICAgICAgICB0ZXh0ID0gX2JlYXV0aWZpZXIoaW5kZW50YXRpb24gKyB0ZXh0LCBjaGlsZF9vcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNpbXBseSBpbmRlbnQgdGhlIHN0cmluZyBvdGhlcndpc2VcbiAgICAgICAgdmFyIHdoaXRlID0gcmF3X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlO1xuICAgICAgICBpZiAod2hpdGUpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcbignICsgd2hpdGUgKyAnKT8nLCAnZycpLCAnXFxuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0ID0gaW5kZW50YXRpb24gKyB0ZXh0LnJlcGxhY2UoL1xcbi9nLCAnXFxuJyArIGluZGVudGF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJlKSB7XG4gICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgdGV4dCA9IHByZSArIHBvc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gcHJlICsgdGV4dCArICdcXG4nICsgcG9zdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcmludGVyLnByaW50X25ld2xpbmUoZmFsc2UpO1xuICAgIGlmICh0ZXh0KSB7XG4gICAgICByYXdfdG9rZW4udGV4dCA9IHRleHQ7XG4gICAgICByYXdfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUgPSAnJztcbiAgICAgIHJhd190b2tlbi5uZXdsaW5lcyA9IDA7XG4gICAgICBwcmludGVyLmFkZF9yYXdfdG9rZW4ocmF3X3Rva2VuKTtcbiAgICAgIHByaW50ZXIucHJpbnRfbmV3bGluZSh0cnVlKTtcbiAgICB9XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLl9oYW5kbGVfdGFnX29wZW4gPSBmdW5jdGlvbihwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuLCBsYXN0X3Rva2VuLCB0b2tlbnMpIHtcbiAgdmFyIHBhcnNlcl90b2tlbiA9IHRoaXMuX2dldF90YWdfb3Blbl90b2tlbihyYXdfdG9rZW4pO1xuXG4gIGlmICgobGFzdF90YWdfdG9rZW4uaXNfdW5mb3JtYXR0ZWQgfHwgbGFzdF90YWdfdG9rZW4uaXNfY29udGVudF91bmZvcm1hdHRlZCkgJiZcbiAgICAhbGFzdF90YWdfdG9rZW4uaXNfZW1wdHlfZWxlbWVudCAmJlxuICAgIHJhd190b2tlbi50eXBlID09PSBUT0tFTi5UQUdfT1BFTiAmJiAhcGFyc2VyX3Rva2VuLmlzX3N0YXJ0X3RhZykge1xuICAgIC8vIEVuZCBlbGVtZW50IHRhZ3MgZm9yIHVuZm9ybWF0dGVkIG9yIGNvbnRlbnRfdW5mb3JtYXR0ZWQgZWxlbWVudHNcbiAgICAvLyBhcmUgcHJpbnRlZCByYXcgdG8ga2VlcCBhbnkgbmV3bGluZXMgaW5zaWRlIHRoZW0gZXhhY3RseSB0aGUgc2FtZS5cbiAgICBwcmludGVyLmFkZF9yYXdfdG9rZW4ocmF3X3Rva2VuKTtcbiAgICBwYXJzZXJfdG9rZW4uc3RhcnRfdGFnX3Rva2VuID0gdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AocGFyc2VyX3Rva2VuLnRhZ19uYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBwcmludGVyLnRyYXZlcnNlX3doaXRlc3BhY2UocmF3X3Rva2VuKTtcbiAgICB0aGlzLl9zZXRfdGFnX3Bvc2l0aW9uKHByaW50ZXIsIHJhd190b2tlbiwgcGFyc2VyX3Rva2VuLCBsYXN0X3RhZ190b2tlbiwgbGFzdF90b2tlbik7XG4gICAgaWYgKCFwYXJzZXJfdG9rZW4uaXNfaW5saW5lX2VsZW1lbnQpIHtcbiAgICAgIHByaW50ZXIuc2V0X3dyYXBfcG9pbnQoKTtcbiAgICB9XG4gICAgcHJpbnRlci5wcmludF90b2tlbihyYXdfdG9rZW4pO1xuICB9XG5cbiAgLy8gY291bnQgdGhlIG51bWJlciBvZiBhdHRyaWJ1dGVzXG4gIGlmIChwYXJzZXJfdG9rZW4uaXNfc3RhcnRfdGFnICYmIHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19mb3JjZSkge1xuICAgIHZhciBwZWVrX2luZGV4ID0gMDtcbiAgICB2YXIgcGVla190b2tlbjtcbiAgICBkbyB7XG4gICAgICBwZWVrX3Rva2VuID0gdG9rZW5zLnBlZWsocGVla19pbmRleCk7XG4gICAgICBpZiAocGVla190b2tlbi50eXBlID09PSBUT0tFTi5BVFRSSUJVVEUpIHtcbiAgICAgICAgcGFyc2VyX3Rva2VuLmF0dHJfY291bnQgKz0gMTtcbiAgICAgIH1cbiAgICAgIHBlZWtfaW5kZXggKz0gMTtcbiAgICB9IHdoaWxlIChwZWVrX3Rva2VuLnR5cGUgIT09IFRPS0VOLkVPRiAmJiBwZWVrX3Rva2VuLnR5cGUgIT09IFRPS0VOLlRBR19DTE9TRSk7XG4gIH1cblxuICAvL2luZGVudCBhdHRyaWJ1dGVzIGFuIGF1dG8sIGZvcmNlZCwgYWxpZ25lZCBvciBmb3JjZWQtYWxpZ24gbGluZS13cmFwXG4gIGlmICh0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfYWxpZ25lZCB8fCB0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfYWxpZ25lZF9tdWx0aXBsZSB8fCB0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfcHJlc2VydmVfYWxpZ25lZCkge1xuICAgIHBhcnNlcl90b2tlbi5hbGlnbm1lbnRfc2l6ZSA9IHJhd190b2tlbi50ZXh0Lmxlbmd0aCArIDE7XG4gIH1cblxuICBpZiAoIXBhcnNlcl90b2tlbi50YWdfY29tcGxldGUgJiYgIXBhcnNlcl90b2tlbi5pc191bmZvcm1hdHRlZCkge1xuICAgIHByaW50ZXIuYWxpZ25tZW50X3NpemUgPSBwYXJzZXJfdG9rZW4uYWxpZ25tZW50X3NpemU7XG4gIH1cblxuICByZXR1cm4gcGFyc2VyX3Rva2VuO1xufTtcblxudmFyIFRhZ09wZW5QYXJzZXJUb2tlbiA9IGZ1bmN0aW9uKHBhcmVudCwgcmF3X3Rva2VuKSB7XG4gIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gIHRoaXMudGV4dCA9ICcnO1xuICB0aGlzLnR5cGUgPSAnVEtfVEFHX09QRU4nO1xuICB0aGlzLnRhZ19uYW1lID0gJyc7XG4gIHRoaXMuaXNfaW5saW5lX2VsZW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc191bmZvcm1hdHRlZCA9IGZhbHNlO1xuICB0aGlzLmlzX2NvbnRlbnRfdW5mb3JtYXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5pc19lbXB0eV9lbGVtZW50ID0gZmFsc2U7XG4gIHRoaXMuaXNfc3RhcnRfdGFnID0gZmFsc2U7XG4gIHRoaXMuaXNfZW5kX3RhZyA9IGZhbHNlO1xuICB0aGlzLmluZGVudF9jb250ZW50ID0gZmFsc2U7XG4gIHRoaXMubXVsdGlsaW5lX2NvbnRlbnQgPSBmYWxzZTtcbiAgdGhpcy5jdXN0b21fYmVhdXRpZmllcl9uYW1lID0gbnVsbDtcbiAgdGhpcy5zdGFydF90YWdfdG9rZW4gPSBudWxsO1xuICB0aGlzLmF0dHJfY291bnQgPSAwO1xuICB0aGlzLmhhc193cmFwcGVkX2F0dHJzID0gZmFsc2U7XG4gIHRoaXMuYWxpZ25tZW50X3NpemUgPSAwO1xuICB0aGlzLnRhZ19jb21wbGV0ZSA9IGZhbHNlO1xuICB0aGlzLnRhZ19zdGFydF9jaGFyID0gJyc7XG4gIHRoaXMudGFnX2NoZWNrID0gJyc7XG5cbiAgaWYgKCFyYXdfdG9rZW4pIHtcbiAgICB0aGlzLnRhZ19jb21wbGV0ZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZ19jaGVja19tYXRjaDtcblxuICAgIHRoaXMudGFnX3N0YXJ0X2NoYXIgPSByYXdfdG9rZW4udGV4dFswXTtcbiAgICB0aGlzLnRleHQgPSByYXdfdG9rZW4udGV4dDtcblxuICAgIGlmICh0aGlzLnRhZ19zdGFydF9jaGFyID09PSAnPCcpIHtcbiAgICAgIHRhZ19jaGVja19tYXRjaCA9IHJhd190b2tlbi50ZXh0Lm1hdGNoKC9ePChbXlxccz5dKikvKTtcbiAgICAgIHRoaXMudGFnX2NoZWNrID0gdGFnX2NoZWNrX21hdGNoID8gdGFnX2NoZWNrX21hdGNoWzFdIDogJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ19jaGVja19tYXRjaCA9IHJhd190b2tlbi50ZXh0Lm1hdGNoKC9ee3t+Pyg/OltcXF5dfCNcXCo/KT8oW15cXHN9XSspLyk7XG4gICAgICB0aGlzLnRhZ19jaGVjayA9IHRhZ19jaGVja19tYXRjaCA/IHRhZ19jaGVja19tYXRjaFsxXSA6ICcnO1xuXG4gICAgICAvLyBoYW5kbGUgXCJ7eyM+IG15UGFydGlhbH19XCIgb3IgXCJ7e34jPiBteVBhcnRpYWx9fVwiXG4gICAgICBpZiAoKHJhd190b2tlbi50ZXh0LnN0YXJ0c1dpdGgoJ3t7Iz4nKSB8fCByYXdfdG9rZW4udGV4dC5zdGFydHNXaXRoKCd7e34jPicpKSAmJiB0aGlzLnRhZ19jaGVja1swXSA9PT0gJz4nKSB7XG4gICAgICAgIGlmICh0aGlzLnRhZ19jaGVjayA9PT0gJz4nICYmIHJhd190b2tlbi5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy50YWdfY2hlY2sgPSByYXdfdG9rZW4ubmV4dC50ZXh0LnNwbGl0KCcgJylbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50YWdfY2hlY2sgPSByYXdfdG9rZW4udGV4dC5zcGxpdCgnPicpWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50YWdfY2hlY2sgPSB0aGlzLnRhZ19jaGVjay50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5DT01NRU5UKSB7XG4gICAgICB0aGlzLnRhZ19jb21wbGV0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc19zdGFydF90YWcgPSB0aGlzLnRhZ19jaGVjay5jaGFyQXQoMCkgIT09ICcvJztcbiAgICB0aGlzLnRhZ19uYW1lID0gIXRoaXMuaXNfc3RhcnRfdGFnID8gdGhpcy50YWdfY2hlY2suc3Vic3RyKDEpIDogdGhpcy50YWdfY2hlY2s7XG4gICAgdGhpcy5pc19lbmRfdGFnID0gIXRoaXMuaXNfc3RhcnRfdGFnIHx8XG4gICAgICAocmF3X3Rva2VuLmNsb3NlZCAmJiByYXdfdG9rZW4uY2xvc2VkLnRleHQgPT09ICcvPicpO1xuXG4gICAgLy8gaWYgd2hpdGVzcGFjZSBoYW5kbGVyIH4gaW5jbHVkZWQgKGkuZS4ge3t+I2lmIHRydWV9fSksIGhhbmRsZWJhcnMgdGFncyBzdGFydCBhdCBwb3MgMyBub3QgcG9zIDJcbiAgICB2YXIgaGFuZGxlYmFyX3N0YXJ0cyA9IDI7XG4gICAgaWYgKHRoaXMudGFnX3N0YXJ0X2NoYXIgPT09ICd7JyAmJiB0aGlzLnRleHQubGVuZ3RoID49IDMpIHtcbiAgICAgIGlmICh0aGlzLnRleHQuY2hhckF0KDIpID09PSAnficpIHtcbiAgICAgICAgaGFuZGxlYmFyX3N0YXJ0cyA9IDM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlYmFycyB0YWdzIHRoYXQgZG9uJ3Qgc3RhcnQgd2l0aCAjIG9yIF4gYXJlIHNpbmdsZV90YWdzLCBhbmQgc28gYWxzbyBzdGFydCBhbmQgZW5kLlxuICAgIHRoaXMuaXNfZW5kX3RhZyA9IHRoaXMuaXNfZW5kX3RhZyB8fFxuICAgICAgKHRoaXMudGFnX3N0YXJ0X2NoYXIgPT09ICd7JyAmJiAodGhpcy50ZXh0Lmxlbmd0aCA8IDMgfHwgKC9bXiNcXF5dLy50ZXN0KHRoaXMudGV4dC5jaGFyQXQoaGFuZGxlYmFyX3N0YXJ0cykpKSkpO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5fZ2V0X3RhZ19vcGVuX3Rva2VuID0gZnVuY3Rpb24ocmF3X3Rva2VuKSB7IC8vZnVuY3Rpb24gdG8gZ2V0IGEgZnVsbCB0YWcgYW5kIHBhcnNlIGl0cyB0eXBlXG4gIHZhciBwYXJzZXJfdG9rZW4gPSBuZXcgVGFnT3BlblBhcnNlclRva2VuKHRoaXMuX3RhZ19zdGFjay5nZXRfcGFyc2VyX3Rva2VuKCksIHJhd190b2tlbik7XG5cbiAgcGFyc2VyX3Rva2VuLmFsaWdubWVudF9zaXplID0gdGhpcy5fb3B0aW9ucy53cmFwX2F0dHJpYnV0ZXNfaW5kZW50X3NpemU7XG5cbiAgcGFyc2VyX3Rva2VuLmlzX2VuZF90YWcgPSBwYXJzZXJfdG9rZW4uaXNfZW5kX3RhZyB8fFxuICAgIGluX2FycmF5KHBhcnNlcl90b2tlbi50YWdfY2hlY2ssIHRoaXMuX29wdGlvbnMudm9pZF9lbGVtZW50cyk7XG5cbiAgcGFyc2VyX3Rva2VuLmlzX2VtcHR5X2VsZW1lbnQgPSBwYXJzZXJfdG9rZW4udGFnX2NvbXBsZXRlIHx8XG4gICAgKHBhcnNlcl90b2tlbi5pc19zdGFydF90YWcgJiYgcGFyc2VyX3Rva2VuLmlzX2VuZF90YWcpO1xuXG4gIHBhcnNlcl90b2tlbi5pc191bmZvcm1hdHRlZCA9ICFwYXJzZXJfdG9rZW4udGFnX2NvbXBsZXRlICYmIGluX2FycmF5KHBhcnNlcl90b2tlbi50YWdfY2hlY2ssIHRoaXMuX29wdGlvbnMudW5mb3JtYXR0ZWQpO1xuICBwYXJzZXJfdG9rZW4uaXNfY29udGVudF91bmZvcm1hdHRlZCA9ICFwYXJzZXJfdG9rZW4uaXNfZW1wdHlfZWxlbWVudCAmJiBpbl9hcnJheShwYXJzZXJfdG9rZW4udGFnX2NoZWNrLCB0aGlzLl9vcHRpb25zLmNvbnRlbnRfdW5mb3JtYXR0ZWQpO1xuICBwYXJzZXJfdG9rZW4uaXNfaW5saW5lX2VsZW1lbnQgPSBpbl9hcnJheShwYXJzZXJfdG9rZW4udGFnX25hbWUsIHRoaXMuX29wdGlvbnMuaW5saW5lKSB8fCAodGhpcy5fb3B0aW9ucy5pbmxpbmVfY3VzdG9tX2VsZW1lbnRzICYmIHBhcnNlcl90b2tlbi50YWdfbmFtZS5pbmNsdWRlcyhcIi1cIikpIHx8IHBhcnNlcl90b2tlbi50YWdfc3RhcnRfY2hhciA9PT0gJ3snO1xuXG4gIHJldHVybiBwYXJzZXJfdG9rZW47XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5fc2V0X3RhZ19wb3NpdGlvbiA9IGZ1bmN0aW9uKHByaW50ZXIsIHJhd190b2tlbiwgcGFyc2VyX3Rva2VuLCBsYXN0X3RhZ190b2tlbiwgbGFzdF90b2tlbikge1xuXG4gIGlmICghcGFyc2VyX3Rva2VuLmlzX2VtcHR5X2VsZW1lbnQpIHtcbiAgICBpZiAocGFyc2VyX3Rva2VuLmlzX2VuZF90YWcpIHsgLy90aGlzIHRhZyBpcyBhIGRvdWJsZSB0YWcgc28gY2hlY2sgZm9yIHRhZy1lbmRpbmdcbiAgICAgIHBhcnNlcl90b2tlbi5zdGFydF90YWdfdG9rZW4gPSB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcChwYXJzZXJfdG9rZW4udGFnX25hbWUpOyAvL3JlbW92ZSBpdCBhbmQgYWxsIGFuY2VzdG9yc1xuICAgIH0gZWxzZSB7IC8vIGl0J3MgYSBzdGFydC10YWdcbiAgICAgIC8vIGNoZWNrIGlmIHRoaXMgdGFnIGlzIHN0YXJ0aW5nIGFuIGVsZW1lbnQgdGhhdCBoYXMgb3B0aW9uYWwgZW5kIGVsZW1lbnRcbiAgICAgIC8vIGFuZCBkbyBhbiBlbmRpbmcgbmVlZGVkXG4gICAgICBpZiAodGhpcy5fZG9fb3B0aW9uYWxfZW5kX2VsZW1lbnQocGFyc2VyX3Rva2VuKSkge1xuICAgICAgICBpZiAoIXBhcnNlcl90b2tlbi5pc19pbmxpbmVfZWxlbWVudCkge1xuICAgICAgICAgIHByaW50ZXIucHJpbnRfbmV3bGluZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fdGFnX3N0YWNrLnJlY29yZF90YWcocGFyc2VyX3Rva2VuKTsgLy9wdXNoIGl0IG9uIHRoZSB0YWcgc3RhY2tcblxuICAgICAgaWYgKChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdzY3JpcHQnIHx8IHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3N0eWxlJykgJiZcbiAgICAgICAgIShwYXJzZXJfdG9rZW4uaXNfdW5mb3JtYXR0ZWQgfHwgcGFyc2VyX3Rva2VuLmlzX2NvbnRlbnRfdW5mb3JtYXR0ZWQpKSB7XG4gICAgICAgIHBhcnNlcl90b2tlbi5jdXN0b21fYmVhdXRpZmllcl9uYW1lID0gZ2V0X2N1c3RvbV9iZWF1dGlmaWVyX25hbWUocGFyc2VyX3Rva2VuLnRhZ19jaGVjaywgcmF3X3Rva2VuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW5fYXJyYXkocGFyc2VyX3Rva2VuLnRhZ19jaGVjaywgdGhpcy5fb3B0aW9ucy5leHRyYV9saW5lcnMpKSB7IC8vY2hlY2sgaWYgdGhpcyBkb3VibGUgbmVlZHMgYW4gZXh0cmEgbGluZVxuICAgIHByaW50ZXIucHJpbnRfbmV3bGluZShmYWxzZSk7XG4gICAgaWYgKCFwcmludGVyLl9vdXRwdXQuanVzdF9hZGRlZF9ibGFua2xpbmUoKSkge1xuICAgICAgcHJpbnRlci5wcmludF9uZXdsaW5lKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXJzZXJfdG9rZW4uaXNfZW1wdHlfZWxlbWVudCkgeyAvL2lmIHRoaXMgdGFnIG5hbWUgaXMgYSBzaW5nbGUgdGFnIHR5cGUgKGVpdGhlciBpbiB0aGUgbGlzdCBvciBoYXMgYSBjbG9zaW5nIC8pXG5cbiAgICAvLyBpZiB5b3UgaGl0IGFuIGVsc2UgY2FzZSwgcmVzZXQgdGhlIGluZGVudCBsZXZlbCBpZiB5b3UgYXJlIGluc2lkZSBhbjpcbiAgICAvLyAnaWYnLCAndW5sZXNzJywgb3IgJ2VhY2gnIGJsb2NrLlxuICAgIGlmIChwYXJzZXJfdG9rZW4udGFnX3N0YXJ0X2NoYXIgPT09ICd7JyAmJiBwYXJzZXJfdG9rZW4udGFnX2NoZWNrID09PSAnZWxzZScpIHtcbiAgICAgIHRoaXMuX3RhZ19zdGFjay5pbmRlbnRfdG9fdGFnKFsnaWYnLCAndW5sZXNzJywgJ2VhY2gnXSk7XG4gICAgICBwYXJzZXJfdG9rZW4uaW5kZW50X2NvbnRlbnQgPSB0cnVlO1xuICAgICAgLy8gRG9uJ3QgYWRkIGEgbmV3bGluZSBpZiBvcGVuaW5nIHt7I2lmfX0gdGFnIGlzIG9uIHRoZSBjdXJyZW50IGxpbmVcbiAgICAgIHZhciBmb3VuZElmT25DdXJyZW50TGluZSA9IHByaW50ZXIuY3VycmVudF9saW5lX2hhc19tYXRjaCgve3sjaWYvKTtcbiAgICAgIGlmICghZm91bmRJZk9uQ3VycmVudExpbmUpIHtcbiAgICAgICAgcHJpbnRlci5wcmludF9uZXdsaW5lKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEb24ndCBhZGQgYSBuZXdsaW5lIGJlZm9yZSBlbGVtZW50cyB0aGF0IHNob3VsZCByZW1haW4gd2hlcmUgdGhleSBhcmUuXG4gICAgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJyEtLScgJiYgbGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5UQUdfQ0xPU0UgJiZcbiAgICAgIGxhc3RfdGFnX3Rva2VuLmlzX2VuZF90YWcgJiYgcGFyc2VyX3Rva2VuLnRleHQuaW5kZXhPZignXFxuJykgPT09IC0xKSB7XG4gICAgICAvL0RvIG5vdGhpbmcuIExlYXZlIGNvbW1lbnRzIG9uIHNhbWUgbGluZS5cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEocGFyc2VyX3Rva2VuLmlzX2lubGluZV9lbGVtZW50IHx8IHBhcnNlcl90b2tlbi5pc191bmZvcm1hdHRlZCkpIHtcbiAgICAgICAgcHJpbnRlci5wcmludF9uZXdsaW5lKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhbGNsdWF0ZV9wYXJlbnRfbXVsdGlsaW5lKHByaW50ZXIsIHBhcnNlcl90b2tlbik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi5pc19lbmRfdGFnKSB7IC8vdGhpcyB0YWcgaXMgYSBkb3VibGUgdGFnIHNvIGNoZWNrIGZvciB0YWctZW5kaW5nXG4gICAgdmFyIGRvX2VuZF9leHBhbmQgPSBmYWxzZTtcblxuICAgIC8vIGRlY2lkaW5nIHdoZXRoZXIgYSBibG9jayBpcyBtdWx0aWxpbmUgc2hvdWxkIG5vdCBiZSB0aGlzIGhhcmRcbiAgICBkb19lbmRfZXhwYW5kID0gcGFyc2VyX3Rva2VuLnN0YXJ0X3RhZ190b2tlbiAmJiBwYXJzZXJfdG9rZW4uc3RhcnRfdGFnX3Rva2VuLm11bHRpbGluZV9jb250ZW50O1xuICAgIGRvX2VuZF9leHBhbmQgPSBkb19lbmRfZXhwYW5kIHx8ICghcGFyc2VyX3Rva2VuLmlzX2lubGluZV9lbGVtZW50ICYmXG4gICAgICAhKGxhc3RfdGFnX3Rva2VuLmlzX2lubGluZV9lbGVtZW50IHx8IGxhc3RfdGFnX3Rva2VuLmlzX3VuZm9ybWF0dGVkKSAmJlxuICAgICAgIShsYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlRBR19DTE9TRSAmJiBwYXJzZXJfdG9rZW4uc3RhcnRfdGFnX3Rva2VuID09PSBsYXN0X3RhZ190b2tlbikgJiZcbiAgICAgIGxhc3RfdG9rZW4udHlwZSAhPT0gJ1RLX0NPTlRFTlQnXG4gICAgKTtcblxuICAgIGlmIChwYXJzZXJfdG9rZW4uaXNfY29udGVudF91bmZvcm1hdHRlZCB8fCBwYXJzZXJfdG9rZW4uaXNfdW5mb3JtYXR0ZWQpIHtcbiAgICAgIGRvX2VuZF9leHBhbmQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZG9fZW5kX2V4cGFuZCkge1xuICAgICAgcHJpbnRlci5wcmludF9uZXdsaW5lKGZhbHNlKTtcbiAgICB9XG4gIH0gZWxzZSB7IC8vIGl0J3MgYSBzdGFydC10YWdcbiAgICBwYXJzZXJfdG9rZW4uaW5kZW50X2NvbnRlbnQgPSAhcGFyc2VyX3Rva2VuLmN1c3RvbV9iZWF1dGlmaWVyX25hbWU7XG5cbiAgICBpZiAocGFyc2VyX3Rva2VuLnRhZ19zdGFydF9jaGFyID09PSAnPCcpIHtcbiAgICAgIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdodG1sJykge1xuICAgICAgICBwYXJzZXJfdG9rZW4uaW5kZW50X2NvbnRlbnQgPSB0aGlzLl9vcHRpb25zLmluZGVudF9pbm5lcl9odG1sO1xuICAgICAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdoZWFkJykge1xuICAgICAgICBwYXJzZXJfdG9rZW4uaW5kZW50X2NvbnRlbnQgPSB0aGlzLl9vcHRpb25zLmluZGVudF9oZWFkX2lubmVyX2h0bWw7XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ2JvZHknKSB7XG4gICAgICAgIHBhcnNlcl90b2tlbi5pbmRlbnRfY29udGVudCA9IHRoaXMuX29wdGlvbnMuaW5kZW50X2JvZHlfaW5uZXJfaHRtbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIShwYXJzZXJfdG9rZW4uaXNfaW5saW5lX2VsZW1lbnQgfHwgcGFyc2VyX3Rva2VuLmlzX3VuZm9ybWF0dGVkKSAmJlxuICAgICAgKGxhc3RfdG9rZW4udHlwZSAhPT0gJ1RLX0NPTlRFTlQnIHx8IHBhcnNlcl90b2tlbi5pc19jb250ZW50X3VuZm9ybWF0dGVkKSkge1xuICAgICAgcHJpbnRlci5wcmludF9uZXdsaW5lKGZhbHNlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jYWxjbHVhdGVfcGFyZW50X211bHRpbGluZShwcmludGVyLCBwYXJzZXJfdG9rZW4pO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5fY2FsY2x1YXRlX3BhcmVudF9tdWx0aWxpbmUgPSBmdW5jdGlvbihwcmludGVyLCBwYXJzZXJfdG9rZW4pIHtcbiAgaWYgKHBhcnNlcl90b2tlbi5wYXJlbnQgJiYgcHJpbnRlci5fb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpICYmXG4gICAgISgocGFyc2VyX3Rva2VuLmlzX2lubGluZV9lbGVtZW50IHx8IHBhcnNlcl90b2tlbi5pc191bmZvcm1hdHRlZCkgJiYgcGFyc2VyX3Rva2VuLnBhcmVudC5pc19pbmxpbmVfZWxlbWVudCkpIHtcbiAgICBwYXJzZXJfdG9rZW4ucGFyZW50Lm11bHRpbGluZV9jb250ZW50ID0gdHJ1ZTtcbiAgfVxufTtcblxuLy9UbyBiZSB1c2VkIGZvciA8cD4gdGFnIHNwZWNpYWwgY2FzZTpcbnZhciBwX2Nsb3NlcnMgPSBbJ2FkZHJlc3MnLCAnYXJ0aWNsZScsICdhc2lkZScsICdibG9ja3F1b3RlJywgJ2RldGFpbHMnLCAnZGl2JywgJ2RsJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWRlcicsICdocicsICdtYWluJywgJ21lbnUnLCAnbmF2JywgJ29sJywgJ3AnLCAncHJlJywgJ3NlY3Rpb24nLCAndGFibGUnLCAndWwnXTtcbnZhciBwX3BhcmVudF9leGNsdWRlcyA9IFsnYScsICdhdWRpbycsICdkZWwnLCAnaW5zJywgJ21hcCcsICdub3NjcmlwdCcsICd2aWRlbyddO1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5fZG9fb3B0aW9uYWxfZW5kX2VsZW1lbnQgPSBmdW5jdGlvbihwYXJzZXJfdG9rZW4pIHtcbiAgdmFyIHJlc3VsdCA9IG51bGw7XG4gIC8vIE5PVEU6IGNhc2VzIG9mIFwiaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudFwiXG4gIC8vIGFyZSBoYW5kbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIGJlYXV0aWZpZXIuXG4gIC8vIEl0IGFzc3VtZXMgcGFyZW50IG9yIGFuY2VzdG9yIGNsb3NlIHRhZyBjbG9zZXMgYWxsIGNoaWxkcmVuLlxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjb3B0aW9uYWwtdGFnc1xuICBpZiAocGFyc2VyX3Rva2VuLmlzX2VtcHR5X2VsZW1lbnQgfHwgIXBhcnNlcl90b2tlbi5pc19zdGFydF90YWcgfHwgIXBhcnNlcl90b2tlbi5wYXJlbnQpIHtcbiAgICByZXR1cm47XG5cbiAgfVxuXG4gIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdib2R5Jykge1xuICAgIC8vIEEgaGVhZCBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBoZWFkIGVsZW1lbnQgaXMgbm90IGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEgc3BhY2UgY2hhcmFjdGVyIG9yIGEgY29tbWVudC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2hlYWQnKTtcblxuICAgIC8vfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdib2R5Jykge1xuICAgIC8vIERPTkU6IEEgYm9keSBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBib2R5IGVsZW1lbnQgaXMgbm90IGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEgY29tbWVudC5cblxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ2xpJykge1xuICAgIC8vIEFuIGxpIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGxpIGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW5vdGhlciBsaSBlbGVtZW50IG9yIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdsaScsIFsnb2wnLCAndWwnLCAnbWVudSddKTtcblxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ2RkJyB8fCBwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdkdCcpIHtcbiAgICAvLyBBIGRkIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGRkIGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW5vdGhlciBkZCBlbGVtZW50IG9yIGEgZHQgZWxlbWVudCwgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICAvLyBBIGR0IGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGR0IGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW5vdGhlciBkdCBlbGVtZW50IG9yIGEgZGQgZWxlbWVudC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2R0JywgWydkbCddKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2RkJywgWydkbCddKTtcblxuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnBhcmVudC50YWdfbmFtZSA9PT0gJ3AnICYmIHBfY2xvc2Vycy5pbmRleE9mKHBhcnNlcl90b2tlbi50YWdfbmFtZSkgIT09IC0xKSB7XG4gICAgLy8gSU1QT1JUQU5UOiB0aGlzIGVsc2UtaWYgd29ya3MgYmVjYXVzZSBwX2Nsb3NlcnMgaGFzIG5vIG92ZXJsYXAgd2l0aCBhbnkgb3RoZXIgZWxlbWVudCB3ZSBsb29rIGZvciBpbiB0aGlzIG1ldGhvZFxuICAgIC8vIGNoZWNrIGZvciB0aGUgcGFyZW50IGVsZW1lbnQgaXMgYW4gSFRNTCBlbGVtZW50IHRoYXQgaXMgbm90IGFuIDxhPiwgPGF1ZGlvPiwgPGRlbD4sIDxpbnM+LCA8bWFwPiwgPG5vc2NyaXB0Piwgb3IgPHZpZGVvPiBlbGVtZW50LCAgb3IgYW4gYXV0b25vbW91cyBjdXN0b20gZWxlbWVudC5cbiAgICAvLyBUbyBkbyB0aGlzIHJpZ2h0LCB0aGlzIG5lZWRzIHRvIGJlIGNvZGVkIGFzIGFuIGluY2x1c2lvbiBvZiB0aGUgaW52ZXJzZSBvZiB0aGUgZXhjbHVzaW9uIGFib3ZlLlxuICAgIC8vIEJ1dCB0byBzdGFydCB3aXRoIChpZiB3ZSBpZ25vcmUgXCJhdXRvbm9tb3VzIGN1c3RvbSBlbGVtZW50c1wiKSB0aGUgZXhjbHVzaW9uIHdvdWxkIGJlIGZpbmUuXG4gICAgdmFyIHBfcGFyZW50ID0gcGFyc2VyX3Rva2VuLnBhcmVudC5wYXJlbnQ7XG4gICAgaWYgKCFwX3BhcmVudCB8fCBwX3BhcmVudF9leGNsdWRlcy5pbmRleE9mKHBfcGFyZW50LnRhZ19uYW1lKSA9PT0gLTEpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgncCcpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdycCcgfHwgcGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAncnQnKSB7XG4gICAgLy8gQW4gcnQgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgcnQgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbiBydCBvciBycCBlbGVtZW50LCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIC8vIEFuIHJwIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIHJwIGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW4gcnQgb3IgcnAgZWxlbWVudCwgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ3J0JywgWydydWJ5JywgJ3J0YyddKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ3JwJywgWydydWJ5JywgJ3J0YyddKTtcblxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ29wdGdyb3VwJykge1xuICAgIC8vIEFuIG9wdGdyb3VwIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIG9wdGdyb3VwIGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW5vdGhlciBvcHRncm91cCBlbGVtZW50LCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIC8vIEFuIG9wdGlvbiBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBvcHRpb24gZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbm90aGVyIG9wdGlvbiBlbGVtZW50LCBvciBpZiBpdCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbiBvcHRncm91cCBlbGVtZW50LCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnb3B0Z3JvdXAnLCBbJ3NlbGVjdCddKTtcbiAgICAvL3Jlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnb3B0aW9uJywgWydzZWxlY3QnXSk7XG5cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdvcHRpb24nKSB7XG4gICAgLy8gQW4gb3B0aW9uIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIG9wdGlvbiBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFub3RoZXIgb3B0aW9uIGVsZW1lbnQsIG9yIGlmIGl0IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFuIG9wdGdyb3VwIGVsZW1lbnQsIG9yIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdvcHRpb24nLCBbJ3NlbGVjdCcsICdkYXRhbGlzdCcsICdvcHRncm91cCddKTtcblxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ2NvbGdyb3VwJykge1xuICAgIC8vIERPTkU6IEEgY29sZ3JvdXAgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgY29sZ3JvdXAgZWxlbWVudCBpcyBub3QgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSBzcGFjZSBjaGFyYWN0ZXIgb3IgYSBjb21tZW50LlxuICAgIC8vIEEgY2FwdGlvbiBlbGVtZW50J3MgZW5kIHRhZyBtYXkgYmUgb21taXR0ZWQgaWYgYSBjb2xncm91cCwgdGhlYWQsIHRmb290LCB0Ym9keSwgb3IgdHIgZWxlbWVudCBpcyBzdGFydGVkLlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnY2FwdGlvbicsIFsndGFibGUnXSk7XG5cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICd0aGVhZCcpIHtcbiAgICAvLyBBIGNvbGdyb3VwIGVsZW1lbnQncyBlbmQgdGFnIG1heSBiZSBvbW1pdHRlZCBpZiBhIHRoZWFkLCB0Zm9vdCwgdGJvZHksIG9yIHRyIGVsZW1lbnQgaXMgc3RhcnRlZC5cbiAgICAvLyBBIGNhcHRpb24gZWxlbWVudCdzIGVuZCB0YWcgbWF5IGJlIG9tbWl0dGVkIGlmIGEgY29sZ3JvdXAsIHRoZWFkLCB0Zm9vdCwgdGJvZHksIG9yIHRyIGVsZW1lbnQgaXMgc3RhcnRlZC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2NhcHRpb24nLCBbJ3RhYmxlJ10pO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnY29sZ3JvdXAnLCBbJ3RhYmxlJ10pO1xuXG4gICAgLy99IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ2NhcHRpb24nKSB7XG4gICAgLy8gRE9ORTogQSBjYXB0aW9uIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGNhcHRpb24gZWxlbWVudCBpcyBub3QgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSBzcGFjZSBjaGFyYWN0ZXIgb3IgYSBjb21tZW50LlxuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAndGJvZHknIHx8IHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3Rmb290Jykge1xuICAgIC8vIEEgdGhlYWQgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgdGhlYWQgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhIHRib2R5IG9yIHRmb290IGVsZW1lbnQuXG4gICAgLy8gQSB0Ym9keSBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSB0Ym9keSBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEgdGJvZHkgb3IgdGZvb3QgZWxlbWVudCwgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICAvLyBBIGNvbGdyb3VwIGVsZW1lbnQncyBlbmQgdGFnIG1heSBiZSBvbW1pdHRlZCBpZiBhIHRoZWFkLCB0Zm9vdCwgdGJvZHksIG9yIHRyIGVsZW1lbnQgaXMgc3RhcnRlZC5cbiAgICAvLyBBIGNhcHRpb24gZWxlbWVudCdzIGVuZCB0YWcgbWF5IGJlIG9tbWl0dGVkIGlmIGEgY29sZ3JvdXAsIHRoZWFkLCB0Zm9vdCwgdGJvZHksIG9yIHRyIGVsZW1lbnQgaXMgc3RhcnRlZC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2NhcHRpb24nLCBbJ3RhYmxlJ10pO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnY29sZ3JvdXAnLCBbJ3RhYmxlJ10pO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgndGhlYWQnLCBbJ3RhYmxlJ10pO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgndGJvZHknLCBbJ3RhYmxlJ10pO1xuXG4gICAgLy99IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3Rmb290Jykge1xuICAgIC8vIERPTkU6IEEgdGZvb3QgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAndHInKSB7XG4gICAgLy8gQSB0ciBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSB0ciBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFub3RoZXIgdHIgZWxlbWVudCwgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICAvLyBBIGNvbGdyb3VwIGVsZW1lbnQncyBlbmQgdGFnIG1heSBiZSBvbW1pdHRlZCBpZiBhIHRoZWFkLCB0Zm9vdCwgdGJvZHksIG9yIHRyIGVsZW1lbnQgaXMgc3RhcnRlZC5cbiAgICAvLyBBIGNhcHRpb24gZWxlbWVudCdzIGVuZCB0YWcgbWF5IGJlIG9tbWl0dGVkIGlmIGEgY29sZ3JvdXAsIHRoZWFkLCB0Zm9vdCwgdGJvZHksIG9yIHRyIGVsZW1lbnQgaXMgc3RhcnRlZC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2NhcHRpb24nLCBbJ3RhYmxlJ10pO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnY29sZ3JvdXAnLCBbJ3RhYmxlJ10pO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgndHInLCBbJ3RhYmxlJywgJ3RoZWFkJywgJ3Rib2R5JywgJ3Rmb290J10pO1xuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAndGgnIHx8IHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3RkJykge1xuICAgIC8vIEEgdGQgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgdGQgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhIHRkIG9yIHRoIGVsZW1lbnQsIG9yIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgLy8gQSB0aCBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSB0aCBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEgdGQgb3IgdGggZWxlbWVudCwgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ3RkJywgWyd0YWJsZScsICd0aGVhZCcsICd0Ym9keScsICd0Zm9vdCcsICd0ciddKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ3RoJywgWyd0YWJsZScsICd0aGVhZCcsICd0Ym9keScsICd0Zm9vdCcsICd0ciddKTtcbiAgfVxuXG4gIC8vIFN0YXJ0IGVsZW1lbnQgb21pc3Npb24gbm90IGhhbmRsZWQgY3VycmVudGx5XG4gIC8vIEEgaGVhZCBlbGVtZW504oCZcyBzdGFydCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGVsZW1lbnQgaXMgZW1wdHksIG9yIGlmIHRoZSBmaXJzdCB0aGluZyBpbnNpZGUgdGhlIGhlYWQgZWxlbWVudCBpcyBhbiBlbGVtZW50LlxuICAvLyBBIHRib2R5IGVsZW1lbnTigJlzIHN0YXJ0IHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgZmlyc3QgdGhpbmcgaW5zaWRlIHRoZSB0Ym9keSBlbGVtZW50IGlzIGEgdHIgZWxlbWVudCwgYW5kIGlmIHRoZSBlbGVtZW50IGlzIG5vdCBpbW1lZGlhdGVseSBwcmVjZWRlZCBieSBhIHRib2R5LCB0aGVhZCwgb3IgdGZvb3QgZWxlbWVudCB3aG9zZSBlbmQgdGFnIGhhcyBiZWVuIG9taXR0ZWQuIChJdCBjYW7igJl0IGJlIG9taXR0ZWQgaWYgdGhlIGVsZW1lbnQgaXMgZW1wdHkuKVxuICAvLyBBIGNvbGdyb3VwIGVsZW1lbnTigJlzIHN0YXJ0IHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgZmlyc3QgdGhpbmcgaW5zaWRlIHRoZSBjb2xncm91cCBlbGVtZW50IGlzIGEgY29sIGVsZW1lbnQsIGFuZCBpZiB0aGUgZWxlbWVudCBpcyBub3QgaW1tZWRpYXRlbHkgcHJlY2VkZWQgYnkgYW5vdGhlciBjb2xncm91cCBlbGVtZW50IHdob3NlIGVuZCB0YWcgaGFzIGJlZW4gb21pdHRlZC4gKEl0IGNhbuKAmXQgYmUgb21pdHRlZCBpZiB0aGUgZWxlbWVudCBpcyBlbXB0eS4pXG5cbiAgLy8gRml4IHVwIHRoZSBwYXJlbnQgb2YgdGhlIHBhcnNlciB0b2tlblxuICBwYXJzZXJfdG9rZW4ucGFyZW50ID0gdGhpcy5fdGFnX3N0YWNrLmdldF9wYXJzZXJfdG9rZW4oKTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMuQmVhdXRpZmllciA9IEJlYXV0aWZpZXI7XG5cblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIEJhc2VPcHRpb25zID0gKF9fd2VicGFja19yZXF1aXJlX18oNikuT3B0aW9ucyk7XG5cbmZ1bmN0aW9uIE9wdGlvbnMob3B0aW9ucykge1xuICBCYXNlT3B0aW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMsICdodG1sJyk7XG4gIGlmICh0aGlzLnRlbXBsYXRpbmcubGVuZ3RoID09PSAxICYmIHRoaXMudGVtcGxhdGluZ1swXSA9PT0gJ2F1dG8nKSB7XG4gICAgdGhpcy50ZW1wbGF0aW5nID0gWydkamFuZ28nLCAnZXJiJywgJ2hhbmRsZWJhcnMnLCAncGhwJ107XG4gIH1cblxuICB0aGlzLmluZGVudF9pbm5lcl9odG1sID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2luZGVudF9pbm5lcl9odG1sJyk7XG4gIHRoaXMuaW5kZW50X2JvZHlfaW5uZXJfaHRtbCA9IHRoaXMuX2dldF9ib29sZWFuKCdpbmRlbnRfYm9keV9pbm5lcl9odG1sJywgdHJ1ZSk7XG4gIHRoaXMuaW5kZW50X2hlYWRfaW5uZXJfaHRtbCA9IHRoaXMuX2dldF9ib29sZWFuKCdpbmRlbnRfaGVhZF9pbm5lcl9odG1sJywgdHJ1ZSk7XG5cbiAgdGhpcy5pbmRlbnRfaGFuZGxlYmFycyA9IHRoaXMuX2dldF9ib29sZWFuKCdpbmRlbnRfaGFuZGxlYmFycycsIHRydWUpO1xuICB0aGlzLndyYXBfYXR0cmlidXRlcyA9IHRoaXMuX2dldF9zZWxlY3Rpb24oJ3dyYXBfYXR0cmlidXRlcycsXG4gICAgWydhdXRvJywgJ2ZvcmNlJywgJ2ZvcmNlLWFsaWduZWQnLCAnZm9yY2UtZXhwYW5kLW11bHRpbGluZScsICdhbGlnbmVkLW11bHRpcGxlJywgJ3ByZXNlcnZlJywgJ3ByZXNlcnZlLWFsaWduZWQnXSk7XG4gIHRoaXMud3JhcF9hdHRyaWJ1dGVzX21pbl9hdHRycyA9IHRoaXMuX2dldF9udW1iZXIoJ3dyYXBfYXR0cmlidXRlc19taW5fYXR0cnMnLCAyKTtcbiAgdGhpcy53cmFwX2F0dHJpYnV0ZXNfaW5kZW50X3NpemUgPSB0aGlzLl9nZXRfbnVtYmVyKCd3cmFwX2F0dHJpYnV0ZXNfaW5kZW50X3NpemUnLCB0aGlzLmluZGVudF9zaXplKTtcbiAgdGhpcy5leHRyYV9saW5lcnMgPSB0aGlzLl9nZXRfYXJyYXkoJ2V4dHJhX2xpbmVycycsIFsnaGVhZCcsICdib2R5JywgJy9odG1sJ10pO1xuXG4gIC8vIEJsb2NrIHZzIGlubGluZSBlbGVtZW50c1xuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0Jsb2NrLWxldmVsX2VsZW1lbnRzXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvSW5saW5lX2VsZW1lbnRzXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG4gIHRoaXMuaW5saW5lID0gdGhpcy5fZ2V0X2FycmF5KCdpbmxpbmUnLCBbXG4gICAgJ2EnLCAnYWJicicsICdhcmVhJywgJ2F1ZGlvJywgJ2InLCAnYmRpJywgJ2JkbycsICdicicsICdidXR0b24nLCAnY2FudmFzJywgJ2NpdGUnLFxuICAgICdjb2RlJywgJ2RhdGEnLCAnZGF0YWxpc3QnLCAnZGVsJywgJ2RmbicsICdlbScsICdlbWJlZCcsICdpJywgJ2lmcmFtZScsICdpbWcnLFxuICAgICdpbnB1dCcsICdpbnMnLCAna2JkJywgJ2tleWdlbicsICdsYWJlbCcsICdtYXAnLCAnbWFyaycsICdtYXRoJywgJ21ldGVyJywgJ25vc2NyaXB0JyxcbiAgICAnb2JqZWN0JywgJ291dHB1dCcsICdwcm9ncmVzcycsICdxJywgJ3J1YnknLCAncycsICdzYW1wJywgLyogJ3NjcmlwdCcsICovICdzZWxlY3QnLCAnc21hbGwnLFxuICAgICdzcGFuJywgJ3N0cm9uZycsICdzdWInLCAnc3VwJywgJ3N2ZycsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0aW1lJywgJ3UnLCAndmFyJyxcbiAgICAndmlkZW8nLCAnd2JyJywgJ3RleHQnLFxuICAgIC8vIG9ic29sZXRlIGlubGluZSB0YWdzXG4gICAgJ2Fjcm9ueW0nLCAnYmlnJywgJ3N0cmlrZScsICd0dCdcbiAgXSk7XG4gIHRoaXMuaW5saW5lX2N1c3RvbV9lbGVtZW50cyA9IHRoaXMuX2dldF9ib29sZWFuKCdpbmxpbmVfY3VzdG9tX2VsZW1lbnRzJywgdHJ1ZSk7XG4gIHRoaXMudm9pZF9lbGVtZW50cyA9IHRoaXMuX2dldF9hcnJheSgndm9pZF9lbGVtZW50cycsIFtcbiAgICAvLyBIVExNIHZvaWQgZWxlbWVudHMgLSBha2Egc2VsZi1jbG9zaW5nIHRhZ3MgLSBha2Egc2luZ2xldG9uc1xuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9odG1sL3dnL2RyYWZ0cy9odG1sL21hc3Rlci9zeW50YXguaHRtbCN2b2lkLWVsZW1lbnRzXG4gICAgJ2FyZWEnLCAnYmFzZScsICdicicsICdjb2wnLCAnZW1iZWQnLCAnaHInLCAnaW1nJywgJ2lucHV0JywgJ2tleWdlbicsXG4gICAgJ2xpbmsnLCAnbWVudWl0ZW0nLCAnbWV0YScsICdwYXJhbScsICdzb3VyY2UnLCAndHJhY2snLCAnd2JyJyxcbiAgICAvLyBOT1RFOiBPcHRpb25hbCB0YWdzIGFyZSB0b28gY29tcGxleCBmb3IgYSBzaW1wbGUgbGlzdFxuICAgIC8vIHRoZXkgYXJlIGhhcmQgY29kZWQgaW4gX2RvX29wdGlvbmFsX2VuZF9lbGVtZW50XG5cbiAgICAvLyBEb2N0eXBlIGFuZCB4bWwgZWxlbWVudHNcbiAgICAnIWRvY3R5cGUnLCAnP3htbCcsXG5cbiAgICAvLyBvYnNvbGV0ZSB0YWdzXG4gICAgLy8gYmFzZWZvbnQ6IGh0dHBzOi8vd3d3LmNvbXB1dGVyaG9wZS5jb20vamFyZ29uL2gvaHRtbC1iYXNlZm9udC10YWcuaHRtXG4gICAgLy8gaXNuZGV4OiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaXNpbmRleFxuICAgICdiYXNlZm9udCcsICdpc2luZGV4J1xuICBdKTtcbiAgdGhpcy51bmZvcm1hdHRlZCA9IHRoaXMuX2dldF9hcnJheSgndW5mb3JtYXR0ZWQnLCBbXSk7XG4gIHRoaXMuY29udGVudF91bmZvcm1hdHRlZCA9IHRoaXMuX2dldF9hcnJheSgnY29udGVudF91bmZvcm1hdHRlZCcsIFtcbiAgICAncHJlJywgJ3RleHRhcmVhJ1xuICBdKTtcbiAgdGhpcy51bmZvcm1hdHRlZF9jb250ZW50X2RlbGltaXRlciA9IHRoaXMuX2dldF9jaGFyYWN0ZXJzKCd1bmZvcm1hdHRlZF9jb250ZW50X2RlbGltaXRlcicpO1xuICB0aGlzLmluZGVudF9zY3JpcHRzID0gdGhpcy5fZ2V0X3NlbGVjdGlvbignaW5kZW50X3NjcmlwdHMnLCBbJ25vcm1hbCcsICdrZWVwJywgJ3NlcGFyYXRlJ10pO1xuXG59XG5PcHRpb25zLnByb3RvdHlwZSA9IG5ldyBCYXNlT3B0aW9ucygpO1xuXG5cblxubW9kdWxlLmV4cG9ydHMuT3B0aW9ucyA9IE9wdGlvbnM7XG5cblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIEJhc2VUb2tlbml6ZXIgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg5KS5Ub2tlbml6ZXIpO1xudmFyIEJBU0VUT0tFTiA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDkpLlRPS0VOKTtcbnZhciBEaXJlY3RpdmVzID0gKF9fd2VicGFja19yZXF1aXJlX18oMTMpLkRpcmVjdGl2ZXMpO1xudmFyIFRlbXBsYXRhYmxlUGF0dGVybiA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KS5UZW1wbGF0YWJsZVBhdHRlcm4pO1xudmFyIFBhdHRlcm4gPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxMikuUGF0dGVybik7XG5cbnZhciBUT0tFTiA9IHtcbiAgVEFHX09QRU46ICdUS19UQUdfT1BFTicsXG4gIFRBR19DTE9TRTogJ1RLX1RBR19DTE9TRScsXG4gIENPTlRST0xfRkxPV19PUEVOOiAnVEtfQ09OVFJPTF9GTE9XX09QRU4nLFxuICBDT05UUk9MX0ZMT1dfQ0xPU0U6ICdUS19DT05UUk9MX0ZMT1dfQ0xPU0UnLFxuICBBVFRSSUJVVEU6ICdUS19BVFRSSUJVVEUnLFxuICBFUVVBTFM6ICdUS19FUVVBTFMnLFxuICBWQUxVRTogJ1RLX1ZBTFVFJyxcbiAgQ09NTUVOVDogJ1RLX0NPTU1FTlQnLFxuICBURVhUOiAnVEtfVEVYVCcsXG4gIFVOS05PV046ICdUS19VTktOT1dOJyxcbiAgU1RBUlQ6IEJBU0VUT0tFTi5TVEFSVCxcbiAgUkFXOiBCQVNFVE9LRU4uUkFXLFxuICBFT0Y6IEJBU0VUT0tFTi5FT0Zcbn07XG5cbnZhciBkaXJlY3RpdmVzX2NvcmUgPSBuZXcgRGlyZWN0aXZlcygvPFxcIS0tLywgLy0tPi8pO1xuXG52YXIgVG9rZW5pemVyID0gZnVuY3Rpb24oaW5wdXRfc3RyaW5nLCBvcHRpb25zKSB7XG4gIEJhc2VUb2tlbml6ZXIuY2FsbCh0aGlzLCBpbnB1dF9zdHJpbmcsIG9wdGlvbnMpO1xuICB0aGlzLl9jdXJyZW50X3RhZ19uYW1lID0gJyc7XG5cbiAgLy8gV29yZHMgZW5kIGF0IHdoaXRlc3BhY2Ugb3Igd2hlbiBhIHRhZyBzdGFydHNcbiAgLy8gaWYgd2UgYXJlIGluZGVudGluZyBoYW5kbGViYXJzLCB0aGV5IGFyZSBjb25zaWRlcmVkIHRhZ3NcbiAgdmFyIHRlbXBsYXRhYmxlX3JlYWRlciA9IG5ldyBUZW1wbGF0YWJsZVBhdHRlcm4odGhpcy5faW5wdXQpLnJlYWRfb3B0aW9ucyh0aGlzLl9vcHRpb25zKTtcbiAgdmFyIHBhdHRlcm5fcmVhZGVyID0gbmV3IFBhdHRlcm4odGhpcy5faW5wdXQpO1xuXG4gIHRoaXMuX19wYXR0ZXJucyA9IHtcbiAgICB3b3JkOiB0ZW1wbGF0YWJsZV9yZWFkZXIudW50aWwoL1tcXG5cXHJcXHQgPF0vKSxcbiAgICB3b3JkX2NvbnRyb2xfZmxvd19jbG9zZV9leGNsdWRlZDogdGVtcGxhdGFibGVfcmVhZGVyLnVudGlsKC9bXFxuXFxyXFx0IDx9XS8pLFxuICAgIHNpbmdsZV9xdW90ZTogdGVtcGxhdGFibGVfcmVhZGVyLnVudGlsX2FmdGVyKC8nLyksXG4gICAgZG91YmxlX3F1b3RlOiB0ZW1wbGF0YWJsZV9yZWFkZXIudW50aWxfYWZ0ZXIoL1wiLyksXG4gICAgYXR0cmlidXRlOiB0ZW1wbGF0YWJsZV9yZWFkZXIudW50aWwoL1tcXG5cXHJcXHQgPT5dfFxcLz4vKSxcbiAgICBlbGVtZW50X25hbWU6IHRlbXBsYXRhYmxlX3JlYWRlci51bnRpbCgvW1xcblxcclxcdCA+XFwvXS8pLFxuXG4gICAgYW5ndWxhcl9jb250cm9sX2Zsb3dfc3RhcnQ6IHBhdHRlcm5fcmVhZGVyLm1hdGNoaW5nKC9cXEBbYS16QS1aXStbXih7XSpbKHtdLyksXG4gICAgaGFuZGxlYmFyc19jb21tZW50OiBwYXR0ZXJuX3JlYWRlci5zdGFydGluZ193aXRoKC97eyEtLS8pLnVudGlsX2FmdGVyKC8tLX19LyksXG4gICAgaGFuZGxlYmFyczogcGF0dGVybl9yZWFkZXIuc3RhcnRpbmdfd2l0aCgve3svKS51bnRpbF9hZnRlcigvfX0vKSxcbiAgICBoYW5kbGViYXJzX29wZW46IHBhdHRlcm5fcmVhZGVyLnVudGlsKC9bXFxuXFxyXFx0IH1dLyksXG4gICAgaGFuZGxlYmFyc19yYXdfY2xvc2U6IHBhdHRlcm5fcmVhZGVyLnVudGlsKC99fS8pLFxuICAgIGNvbW1lbnQ6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoLzwhLS0vKS51bnRpbF9hZnRlcigvLS0+LyksXG4gICAgY2RhdGE6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoLzwhXFxbQ0RBVEFcXFsvKS51bnRpbF9hZnRlcigvXV0+LyksXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudFxuICAgIGNvbmRpdGlvbmFsX2NvbW1lbnQ6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoLzwhXFxbLykudW50aWxfYWZ0ZXIoL10+LyksXG4gICAgcHJvY2Vzc2luZzogcGF0dGVybl9yZWFkZXIuc3RhcnRpbmdfd2l0aCgvPFxcPy8pLnVudGlsX2FmdGVyKC9cXD8+LylcbiAgfTtcblxuICBpZiAodGhpcy5fb3B0aW9ucy5pbmRlbnRfaGFuZGxlYmFycykge1xuICAgIHRoaXMuX19wYXR0ZXJucy53b3JkID0gdGhpcy5fX3BhdHRlcm5zLndvcmQuZXhjbHVkZSgnaGFuZGxlYmFycycpO1xuICAgIHRoaXMuX19wYXR0ZXJucy53b3JkX2NvbnRyb2xfZmxvd19jbG9zZV9leGNsdWRlZCA9IHRoaXMuX19wYXR0ZXJucy53b3JkX2NvbnRyb2xfZmxvd19jbG9zZV9leGNsdWRlZC5leGNsdWRlKCdoYW5kbGViYXJzJyk7XG4gIH1cblxuICB0aGlzLl91bmZvcm1hdHRlZF9jb250ZW50X2RlbGltaXRlciA9IG51bGw7XG5cbiAgaWYgKHRoaXMuX29wdGlvbnMudW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXIpIHtcbiAgICB2YXIgbGl0ZXJhbF9yZWdleHAgPSB0aGlzLl9pbnB1dC5nZXRfbGl0ZXJhbF9yZWdleHAodGhpcy5fb3B0aW9ucy51bmZvcm1hdHRlZF9jb250ZW50X2RlbGltaXRlcik7XG4gICAgdGhpcy5fX3BhdHRlcm5zLnVuZm9ybWF0dGVkX2NvbnRlbnRfZGVsaW1pdGVyID1cbiAgICAgIHBhdHRlcm5fcmVhZGVyLm1hdGNoaW5nKGxpdGVyYWxfcmVnZXhwKVxuICAgICAgLnVudGlsX2FmdGVyKGxpdGVyYWxfcmVnZXhwKTtcbiAgfVxufTtcblRva2VuaXplci5wcm90b3R5cGUgPSBuZXcgQmFzZVRva2VuaXplcigpO1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19jb21tZW50ID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHJldHVybiBmYWxzZTsgLy9jdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1FTlQgfHwgY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5VTktOT1dOO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfb3BlbmluZyA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgcmV0dXJuIGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uVEFHX09QRU4gfHwgY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5DT05UUk9MX0ZMT1dfT1BFTjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2Nsb3NpbmcgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuLCBvcGVuX3Rva2VuKSB7XG4gIHJldHVybiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5UQUdfQ0xPU0UgJiZcbiAgICAob3Blbl90b2tlbiAmJiAoXG4gICAgICAoKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJz4nIHx8IGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJy8+JykgJiYgb3Blbl90b2tlbi50ZXh0WzBdID09PSAnPCcpIHx8XG4gICAgICAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnfX0nICYmIG9wZW5fdG9rZW4udGV4dFswXSA9PT0gJ3snICYmIG9wZW5fdG9rZW4udGV4dFsxXSA9PT0gJ3snKSkpXG4gICkgfHwgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09OVFJPTF9GTE9XX0NMT1NFICYmXG4gICAgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ30nICYmIG9wZW5fdG9rZW4udGV4dC5lbmRzV2l0aCgneycpKSk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jdXJyZW50X3RhZ19uYW1lID0gJyc7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9nZXRfbmV4dF90b2tlbiA9IGZ1bmN0aW9uKHByZXZpb3VzX3Rva2VuLCBvcGVuX3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgdGhpcy5fcmVhZFdoaXRlc3BhY2UoKTtcbiAgdmFyIGMgPSB0aGlzLl9pbnB1dC5wZWVrKCk7XG5cbiAgaWYgKGMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkVPRiwgJycpO1xuICB9XG5cbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX29wZW5faGFuZGxlYmFycyhjLCBvcGVuX3Rva2VuKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX2F0dHJpYnV0ZShjLCBwcmV2aW91c190b2tlbiwgb3Blbl90b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9jbG9zZShjLCBvcGVuX3Rva2VuKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX2NvbnRyb2xfZmxvd3MoYywgb3Blbl90b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9yYXdfY29udGVudChjLCBwcmV2aW91c190b2tlbiwgb3Blbl90b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9jb250ZW50X3dvcmQoYywgb3Blbl90b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9jb21tZW50X29yX2NkYXRhKGMpO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfcHJvY2Vzc2luZyhjKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX29wZW4oYywgb3Blbl90b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlVOS05PV04sIHRoaXMuX2lucHV0Lm5leHQoKSk7XG5cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9jb21tZW50X29yX2NkYXRhID0gZnVuY3Rpb24oYykgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHZhciB0b2tlbiA9IG51bGw7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gbnVsbDtcbiAgdmFyIGRpcmVjdGl2ZXMgPSBudWxsO1xuXG4gIGlmIChjID09PSAnPCcpIHtcbiAgICB2YXIgcGVlazEgPSB0aGlzLl9pbnB1dC5wZWVrKDEpO1xuICAgIC8vIFdlIHRyZWF0IGFsbCBjb21tZW50cyBhcyBsaXRlcmFscywgZXZlbiBtb3JlIHRoYW4gcHJlZm9ybWF0dGVkIHRhZ3NcbiAgICAvLyB3ZSBvbmx5IGxvb2sgZm9yIHRoZSBhcHByb3ByaWF0ZSBjbG9zaW5nIG1hcmtlclxuICAgIGlmIChwZWVrMSA9PT0gJyEnKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLmNvbW1lbnQucmVhZCgpO1xuXG4gICAgICAvLyBvbmx5IHByb2Nlc3MgZGlyZWN0aXZlIG9uIGh0bWwgY29tbWVudHNcbiAgICAgIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgICAgIGRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzX2NvcmUuZ2V0X2RpcmVjdGl2ZXMocmVzdWx0aW5nX3N0cmluZyk7XG4gICAgICAgIGlmIChkaXJlY3RpdmVzICYmIGRpcmVjdGl2ZXMuaWdub3JlID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSBkaXJlY3RpdmVzX2NvcmUucmVhZElnbm9yZWQodGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLmNkYXRhLnJlYWQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uQ09NTUVOVCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgICB0b2tlbi5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX3Byb2Nlc3NpbmcgPSBmdW5jdGlvbihjKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSBudWxsO1xuICB2YXIgZGlyZWN0aXZlcyA9IG51bGw7XG5cbiAgaWYgKGMgPT09ICc8Jykge1xuICAgIHZhciBwZWVrMSA9IHRoaXMuX2lucHV0LnBlZWsoMSk7XG4gICAgaWYgKHBlZWsxID09PSAnIScgfHwgcGVlazEgPT09ICc/Jykge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5jb25kaXRpb25hbF9jb21tZW50LnJlYWQoKTtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8IHRoaXMuX19wYXR0ZXJucy5wcm9jZXNzaW5nLnJlYWQoKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uQ09NTUVOVCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgICB0b2tlbi5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX29wZW4gPSBmdW5jdGlvbihjLCBvcGVuX3Rva2VuKSB7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gbnVsbDtcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgaWYgKCFvcGVuX3Rva2VuIHx8IG9wZW5fdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09OVFJPTF9GTE9XX09QRU4pIHtcbiAgICBpZiAoYyA9PT0gJzwnKSB7XG5cbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5faW5wdXQucGVlaygpID09PSAnLycpIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICB9XG4gICAgICByZXN1bHRpbmdfc3RyaW5nICs9IHRoaXMuX19wYXR0ZXJucy5lbGVtZW50X25hbWUucmVhZCgpO1xuICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVEFHX09QRU4sIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX29wZW5faGFuZGxlYmFycyA9IGZ1bmN0aW9uKGMsIG9wZW5fdG9rZW4pIHtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSBudWxsO1xuICB2YXIgdG9rZW4gPSBudWxsO1xuICBpZiAoIW9wZW5fdG9rZW4gfHwgb3Blbl90b2tlbi50eXBlID09PSBUT0tFTi5DT05UUk9MX0ZMT1dfT1BFTikge1xuICAgIGlmICh0aGlzLl9vcHRpb25zLmluZGVudF9oYW5kbGViYXJzICYmIGMgPT09ICd7JyAmJiB0aGlzLl9pbnB1dC5wZWVrKDEpID09PSAneycpIHtcbiAgICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKDIpID09PSAnIScpIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzX2NvbW1lbnQucmVhZCgpO1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fCB0aGlzLl9fcGF0dGVybnMuaGFuZGxlYmFycy5yZWFkKCk7XG4gICAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkNPTU1FTlQsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzX29wZW4ucmVhZCgpO1xuICAgICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5UQUdfT1BFTiwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfY29udHJvbF9mbG93cyA9IGZ1bmN0aW9uKGMsIG9wZW5fdG9rZW4pIHtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSAnJztcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgLy8gT25seSBjaGVjayBmb3IgY29udHJvbCBmbG93cyBpZiBhbmd1bGFyIHRlbXBsYXRpbmcgaXMgc2V0IEFORCBpbmRlbnRpbmcgaXMgc2V0XG4gIGlmICghdGhpcy5fb3B0aW9ucy50ZW1wbGF0aW5nLmluY2x1ZGVzKCdhbmd1bGFyJykgfHwgIXRoaXMuX29wdGlvbnMuaW5kZW50X2hhbmRsZWJhcnMpIHtcbiAgICByZXR1cm4gdG9rZW47XG4gIH1cblxuICBpZiAoYyA9PT0gJ0AnKSB7XG4gICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5hbmd1bGFyX2NvbnRyb2xfZmxvd19zdGFydC5yZWFkKCk7XG4gICAgaWYgKHJlc3VsdGluZ19zdHJpbmcgPT09ICcnKSB7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgdmFyIG9wZW5pbmdfcGFyZW50aGVzZXNfY291bnQgPSByZXN1bHRpbmdfc3RyaW5nLmVuZHNXaXRoKCcoJykgPyAxIDogMDtcbiAgICB2YXIgY2xvc2luZ19wYXJlbnRoZXNlc19jb3VudCA9IDA7XG4gICAgLy8gVGhlIG9wZW5pbmcgYnJhY2Ugb2YgdGhlIGNvbnRyb2wgZmxvdyBpcyB3aGVyZSB0aGUgbnVtYmVyIG9mIG9wZW5pbmcgYW5kIGNsb3NpbmcgcGFyZW50aGVzZXMgZXF1YWxcbiAgICAvLyBlLmcuIEBpZih7dmFsdWU6IHRydWV9ICE9PSBudWxsKSB7IFxuICAgIHdoaWxlICghKHJlc3VsdGluZ19zdHJpbmcuZW5kc1dpdGgoJ3snKSAmJiBvcGVuaW5nX3BhcmVudGhlc2VzX2NvdW50ID09PSBjbG9zaW5nX3BhcmVudGhlc2VzX2NvdW50KSkge1xuICAgICAgdmFyIG5leHRfY2hhciA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgIGlmIChuZXh0X2NoYXIgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKG5leHRfY2hhciA9PT0gJygnKSB7XG4gICAgICAgIG9wZW5pbmdfcGFyZW50aGVzZXNfY291bnQrKztcbiAgICAgIH0gZWxzZSBpZiAobmV4dF9jaGFyID09PSAnKScpIHtcbiAgICAgICAgY2xvc2luZ19wYXJlbnRoZXNlc19jb3VudCsrO1xuICAgICAgfVxuICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSBuZXh0X2NoYXI7XG4gICAgfVxuICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkNPTlRST0xfRkxPV19PUEVOLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgfSBlbHNlIGlmIChjID09PSAnfScgJiYgb3Blbl90b2tlbiAmJiBvcGVuX3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTlRST0xfRkxPV19PUEVOKSB7XG4gICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5DT05UUk9MX0ZMT1dfQ0xPU0UsIHJlc3VsdGluZ19zdHJpbmcpO1xuICB9XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9jbG9zZSA9IGZ1bmN0aW9uKGMsIG9wZW5fdG9rZW4pIHtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSBudWxsO1xuICB2YXIgdG9rZW4gPSBudWxsO1xuICBpZiAob3Blbl90b2tlbiAmJiBvcGVuX3Rva2VuLnR5cGUgPT09IFRPS0VOLlRBR19PUEVOKSB7XG4gICAgaWYgKG9wZW5fdG9rZW4udGV4dFswXSA9PT0gJzwnICYmIChjID09PSAnPicgfHwgKGMgPT09ICcvJyAmJiB0aGlzLl9pbnB1dC5wZWVrKDEpID09PSAnPicpKSkge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgIGlmIChjID09PSAnLycpIHsgLy8gIGZvciBjbG9zZSB0YWcgXCIvPlwiXG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgfVxuICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVEFHX0NMT1NFLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB9IGVsc2UgaWYgKG9wZW5fdG9rZW4udGV4dFswXSA9PT0gJ3snICYmIGMgPT09ICd9JyAmJiB0aGlzLl9pbnB1dC5wZWVrKDEpID09PSAnfScpIHtcbiAgICAgIHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgIHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlRBR19DTE9TRSwgJ319Jyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9hdHRyaWJ1dGUgPSBmdW5jdGlvbihjLCBwcmV2aW91c190b2tlbiwgb3Blbl90b2tlbikge1xuICB2YXIgdG9rZW4gPSBudWxsO1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9ICcnO1xuICBpZiAob3Blbl90b2tlbiAmJiBvcGVuX3Rva2VuLnRleHRbMF0gPT09ICc8Jykge1xuXG4gICAgaWYgKGMgPT09ICc9Jykge1xuICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRVFVQUxTLCB0aGlzLl9pbnB1dC5uZXh0KCkpO1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gJ1wiJyB8fCBjID09PSBcIidcIikge1xuICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgICBjb250ZW50ICs9IHRoaXMuX19wYXR0ZXJucy5kb3VibGVfcXVvdGUucmVhZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGVudCArPSB0aGlzLl9fcGF0dGVybnMuc2luZ2xlX3F1b3RlLnJlYWQoKTtcbiAgICAgIH1cbiAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlZBTFVFLCBjb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5hdHRyaWJ1dGUucmVhZCgpO1xuXG4gICAgICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgICAgICBpZiAocHJldmlvdXNfdG9rZW4udHlwZSA9PT0gVE9LRU4uRVFVQUxTKSB7XG4gICAgICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVkFMVUUsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkFUVFJJQlVURSwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfY29udGVudF91bmZvcm1hdHRlZCA9IGZ1bmN0aW9uKHRhZ19uYW1lKSB7XG4gIC8vIHZvaWRfZWxlbWVudHMgaGF2ZSBubyBjb250ZW50IGFuZCBzbyBjYW5ub3QgaGF2ZSB1bmZvcm1hdHRlZCBjb250ZW50XG4gIC8vIHNjcmlwdCBhbmQgc3R5bGUgdGFncyBzaG91bGQgYWx3YXlzIGJlIHJlYWQgYXMgdW5mb3JtYXR0ZWQgY29udGVudFxuICAvLyBmaW5hbGx5IGNvbnRlbnRfdW5mb3JtYXR0ZWQgYW5kIHVuZm9ybWF0dGVkIGVsZW1lbnQgY29udGVudHMgYXJlIHVuZm9ybWF0dGVkXG4gIHJldHVybiB0aGlzLl9vcHRpb25zLnZvaWRfZWxlbWVudHMuaW5kZXhPZih0YWdfbmFtZSkgPT09IC0xICYmXG4gICAgKHRoaXMuX29wdGlvbnMuY29udGVudF91bmZvcm1hdHRlZC5pbmRleE9mKHRhZ19uYW1lKSAhPT0gLTEgfHxcbiAgICAgIHRoaXMuX29wdGlvbnMudW5mb3JtYXR0ZWQuaW5kZXhPZih0YWdfbmFtZSkgIT09IC0xKTtcbn07XG5cblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9yYXdfY29udGVudCA9IGZ1bmN0aW9uKGMsIHByZXZpb3VzX3Rva2VuLCBvcGVuX3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSAnJztcbiAgaWYgKG9wZW5fdG9rZW4gJiYgb3Blbl90b2tlbi50ZXh0WzBdID09PSAneycpIHtcbiAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnNfcmF3X2Nsb3NlLnJlYWQoKTtcbiAgfSBlbHNlIGlmIChwcmV2aW91c190b2tlbi50eXBlID09PSBUT0tFTi5UQUdfQ0xPU0UgJiZcbiAgICBwcmV2aW91c190b2tlbi5vcGVuZWQudGV4dFswXSA9PT0gJzwnICYmIHByZXZpb3VzX3Rva2VuLnRleHRbMF0gIT09ICcvJykge1xuICAgIC8vIF5eIGVtcHR5IHRhZyBoYXMgbm8gY29udGVudCBcbiAgICB2YXIgdGFnX25hbWUgPSBwcmV2aW91c190b2tlbi5vcGVuZWQudGV4dC5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodGFnX25hbWUgPT09ICdzY3JpcHQnIHx8IHRhZ19uYW1lID09PSAnc3R5bGUnKSB7XG4gICAgICAvLyBTY3JpcHQgYW5kIHN0eWxlIHRhZ3MgYXJlIGFsbG93ZWQgdG8gaGF2ZSBjb21tZW50cyB3cmFwcGluZyB0aGVpciBjb250ZW50XG4gICAgICAvLyBvciBqdXN0IGhhdmUgcmVndWxhciBjb250ZW50LlxuICAgICAgdmFyIHRva2VuID0gdGhpcy5fcmVhZF9jb21tZW50X29yX2NkYXRhKGMpO1xuICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgIHRva2VuLnR5cGUgPSBUT0tFTi5URVhUO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQucmVhZFVudGlsKG5ldyBSZWdFeHAoJzwvJyArIHRhZ19uYW1lICsgJ1tcXFxcblxcXFxyXFxcXHQgXSo/PicsICdpZycpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2lzX2NvbnRlbnRfdW5mb3JtYXR0ZWQodGFnX25hbWUpKSB7XG5cbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9pbnB1dC5yZWFkVW50aWwobmV3IFJlZ0V4cCgnPC8nICsgdGFnX25hbWUgKyAnW1xcXFxuXFxcXHJcXFxcdCBdKj8+JywgJ2lnJykpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5URVhULCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9jb250ZW50X3dvcmQgPSBmdW5jdGlvbihjLCBvcGVuX3Rva2VuKSB7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gJyc7XG4gIGlmICh0aGlzLl9vcHRpb25zLnVuZm9ybWF0dGVkX2NvbnRlbnRfZGVsaW1pdGVyKSB7XG4gICAgaWYgKGMgPT09IHRoaXMuX29wdGlvbnMudW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXJbMF0pIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMudW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXIucmVhZCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcmVzdWx0aW5nX3N0cmluZykge1xuICAgIHJlc3VsdGluZ19zdHJpbmcgPSAob3Blbl90b2tlbiAmJiBvcGVuX3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTlRST0xfRkxPV19PUEVOKSA/IHRoaXMuX19wYXR0ZXJucy53b3JkX2NvbnRyb2xfZmxvd19jbG9zZV9leGNsdWRlZC5yZWFkKCkgOiB0aGlzLl9fcGF0dGVybnMud29yZC5yZWFkKCk7XG4gIH1cbiAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlRFWFQsIHJlc3VsdGluZ19zdHJpbmcpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XG5tb2R1bGUuZXhwb3J0cy5UT0tFTiA9IFRPS0VOO1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBcdF0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbi8qKioqKiovIFx0bGVnYWN5X2JlYXV0aWZ5X2h0bWwgPSBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIH0pKClcbjtcbnZhciBzdHlsZV9odG1sID0gbGVnYWN5X2JlYXV0aWZ5X2h0bWw7XG4vKiBGb290ZXIgKi9cbmlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBBTUQgKCBodHRwczovL2dpdGh1Yi5jb20vYW1kanMvYW1kanMtYXBpL3dpa2kvQU1EI2RlZmluZWFtZC1wcm9wZXJ0eS0gKVxuICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiLi9iZWF1dGlmeVwiLCBcIi4vYmVhdXRpZnktY3NzXCJdLCBmdW5jdGlvbihyZXF1aXJlYW1kKSB7XG4gICAgICAgIHZhciBqc19iZWF1dGlmeSA9IHJlcXVpcmVhbWQoXCIuL2JlYXV0aWZ5XCIpO1xuICAgICAgICB2YXIgY3NzX2JlYXV0aWZ5ID0gcmVxdWlyZWFtZChcIi4vYmVhdXRpZnktY3NzXCIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBodG1sX2JlYXV0aWZ5OiBmdW5jdGlvbihodG1sX3NvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZV9odG1sKGh0bWxfc291cmNlLCBvcHRpb25zLCBqc19iZWF1dGlmeS5qc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5LmNzc19iZWF1dGlmeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIENvbW1vbkpTLiBKdXN0IHB1dCB0aGlzIGZpbGUgc29tZXdoZXJlIG9uIHlvdXIgcmVxdWlyZS5wYXRoc1xuICAgIC8vIGFuZCB5b3Ugd2lsbCBiZSBhYmxlIHRvIGB2YXIgaHRtbF9iZWF1dGlmeSA9IHJlcXVpcmUoXCJiZWF1dGlmeVwiKS5odG1sX2JlYXV0aWZ5YC5cbiAgICB2YXIganNfYmVhdXRpZnkgPSByZXF1aXJlKCcuL2JlYXV0aWZ5LmpzJyk7XG4gICAgdmFyIGNzc19iZWF1dGlmeSA9IHJlcXVpcmUoJy4vYmVhdXRpZnktY3NzLmpzJyk7XG5cbiAgICBleHBvcnRzLmh0bWxfYmVhdXRpZnkgPSBmdW5jdGlvbihodG1sX3NvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucywganNfYmVhdXRpZnkuanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeS5jc3NfYmVhdXRpZnkpO1xuICAgIH07XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBJZiB3ZSdyZSBydW5uaW5nIGEgd2ViIHBhZ2UgYW5kIGRvbid0IGhhdmUgZWl0aGVyIG9mIHRoZSBhYm92ZSwgYWRkIG91ciBvbmUgZ2xvYmFsXG4gICAgd2luZG93Lmh0bWxfYmVhdXRpZnkgPSBmdW5jdGlvbihodG1sX3NvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucywgd2luZG93LmpzX2JlYXV0aWZ5LCB3aW5kb3cuY3NzX2JlYXV0aWZ5KTtcbiAgICB9O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgZXZlbiBoYXZlIHdpbmRvdywgdHJ5IGdsb2JhbC5cbiAgICBnbG9iYWwuaHRtbF9iZWF1dGlmeSA9IGZ1bmN0aW9uKGh0bWxfc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBzdHlsZV9odG1sKGh0bWxfc291cmNlLCBvcHRpb25zLCBnbG9iYWwuanNfYmVhdXRpZnksIGdsb2JhbC5jc3NfYmVhdXRpZnkpO1xuICAgIH07XG59XG5cbn0oKSk7XG4iXSwibmFtZXMiOlsibGVnYWN5X2JlYXV0aWZ5X2h0bWwiLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwibW9kdWxlIiwiT3V0cHV0TGluZSIsInBhcmVudCIsIl9fcGFyZW50IiwiX19jaGFyYWN0ZXJfY291bnQiLCJfX2luZGVudF9jb3VudCIsIl9fYWxpZ25tZW50X2NvdW50IiwiX193cmFwX3BvaW50X2luZGV4IiwiX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudCIsIl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQiLCJfX3dyYXBfcG9pbnRfYWxpZ25tZW50X2NvdW50IiwiX19pdGVtcyIsInByb3RvdHlwZSIsImNsb25lX2VtcHR5IiwibGluZSIsInNldF9pbmRlbnQiLCJpdGVtIiwiaW5kZXgiLCJsZW5ndGgiLCJoYXNfbWF0Y2giLCJwYXR0ZXJuIiwibGFzdENoZWNrZWRPdXRwdXQiLCJtYXRjaCIsImluZGVudCIsImFsaWdubWVudCIsImlzX2VtcHR5IiwiZ2V0X2luZGVudF9zaXplIiwiX3NldF93cmFwX3BvaW50Iiwid3JhcF9saW5lX2xlbmd0aCIsIm5leHRfbGluZSIsIl9zaG91bGRfd3JhcCIsIl9hbGxvd193cmFwIiwiYWRkX25ld19saW5lIiwibmV4dCIsImN1cnJlbnRfbGluZSIsInNsaWNlIiwic3BsaWNlIiwibGFzdCIsInB1c2giLCJsYXN0X25ld2xpbmVfaW5kZXgiLCJsYXN0SW5kZXhPZiIsInBvcCIsIl9yZW1vdmVfaW5kZW50IiwiaW5kZW50X3NpemUiLCJfcmVtb3ZlX3dyYXBfaW5kZW50IiwidHJpbSIsInRvU3RyaW5nIiwicmVzdWx0IiwiaW5kZW50X2VtcHR5X2xpbmVzIiwiZ2V0X2luZGVudF9zdHJpbmciLCJqb2luIiwiSW5kZW50U3RyaW5nQ2FjaGUiLCJvcHRpb25zIiwiYmFzZUluZGVudFN0cmluZyIsIl9fY2FjaGUiLCJfX2luZGVudF9zaXplIiwiX19pbmRlbnRfc3RyaW5nIiwiaW5kZW50X2NoYXIiLCJpbmRlbnRfd2l0aF90YWJzIiwiQXJyYXkiLCJpbmRlbnRfbGV2ZWwiLCJfX2Jhc2Vfc3RyaW5nIiwiX19iYXNlX3N0cmluZ19sZW5ndGgiLCJjb2x1bW4iLCJfX2Vuc3VyZV9jYWNoZSIsIl9fYWRkX2NvbHVtbiIsIk1hdGgiLCJmbG9vciIsIk91dHB1dCIsIl9faW5kZW50X2NhY2hlIiwicmF3IiwiX2VuZF93aXRoX25ld2xpbmUiLCJlbmRfd2l0aF9uZXdsaW5lIiwiX19saW5lcyIsInByZXZpb3VzX2xpbmUiLCJzcGFjZV9iZWZvcmVfdG9rZW4iLCJub25fYnJlYWtpbmdfc3BhY2UiLCJwcmV2aW91c190b2tlbl93cmFwcGVkIiwiX19hZGRfb3V0cHV0bGluZSIsImdldF9saW5lX251bWJlciIsImZvcmNlX25ld2xpbmUiLCJqdXN0X2FkZGVkX25ld2xpbmUiLCJnZXRfY29kZSIsImVvbCIsImxhc3RfaXRlbSIsInJlcGxhY2UiLCJzd2VldF9jb2RlIiwic2V0X3dyYXBfcG9pbnQiLCJhZGRfcmF3X3Rva2VuIiwidG9rZW4iLCJ4IiwibmV3bGluZXMiLCJ3aGl0ZXNwYWNlX2JlZm9yZSIsInRleHQiLCJhZGRfdG9rZW4iLCJwcmludGFibGVfdG9rZW4iLCJfX2FkZF9zcGFjZV9iZWZvcmVfdG9rZW4iLCJyZW1vdmVfaW5kZW50Iiwib3V0cHV0X2xlbmd0aCIsImVhdF9uZXdsaW5lcyIsInVuZGVmaW5lZCIsImp1c3RfYWRkZWRfYmxhbmtsaW5lIiwiZW5zdXJlX2VtcHR5X2xpbmVfYWJvdmUiLCJzdGFydHNfd2l0aCIsImVuZHNfd2l0aCIsInBvdGVudGlhbEVtcHR5TGluZSIsImluZGV4T2YiLCJleHBvcnRzIiwiVG9rZW4iLCJ0eXBlIiwiY29tbWVudHNfYmVmb3JlIiwicHJldmlvdXMiLCJvcGVuZWQiLCJjbG9zZWQiLCJkaXJlY3RpdmVzIiwiT3B0aW9ucyIsIm1lcmdlX2NoaWxkX2ZpZWxkIiwicmF3X29wdGlvbnMiLCJfbWVyZ2VPcHRzIiwiZGlzYWJsZWQiLCJfZ2V0X2Jvb2xlYW4iLCJfZ2V0X2NoYXJhY3RlcnMiLCJfZ2V0X251bWJlciIsInByZXNlcnZlX25ld2xpbmVzIiwibWF4X3ByZXNlcnZlX25ld2xpbmVzIiwidGVtcGxhdGluZyIsIl9nZXRfc2VsZWN0aW9uX2xpc3QiLCJfZ2V0X2FycmF5IiwibmFtZSIsImRlZmF1bHRfdmFsdWUiLCJvcHRpb25fdmFsdWUiLCJjb25jYXQiLCJzcGxpdCIsInBhcnNlSW50IiwiaXNOYU4iLCJfZ2V0X3NlbGVjdGlvbiIsInNlbGVjdGlvbl9saXN0IiwiRXJyb3IiLCJfaXNfdmFsaWRfc2VsZWN0aW9uIiwic29tZSIsImFsbE9wdGlvbnMiLCJjaGlsZEZpZWxkTmFtZSIsImZpbmFsT3B0cyIsIl9ub3JtYWxpemVPcHRzIiwiY29udmVydGVkT3B0cyIsImtleSIsIm5ld0tleSIsIm5vcm1hbGl6ZU9wdHMiLCJtZXJnZU9wdHMiLCJyZWdleHBfaGFzX3N0aWNreSIsIlJlZ0V4cCIsImhhc093blByb3BlcnR5IiwiSW5wdXRTY2FubmVyIiwiaW5wdXRfc3RyaW5nIiwiX19pbnB1dCIsIl9faW5wdXRfbGVuZ3RoIiwiX19wb3NpdGlvbiIsInJlc3RhcnQiLCJiYWNrIiwiaGFzTmV4dCIsInZhbCIsImNoYXJBdCIsInBlZWsiLCJfX21hdGNoIiwibGFzdEluZGV4IiwicGF0dGVybl9tYXRjaCIsImV4ZWMiLCJzdGlja3kiLCJ0ZXN0IiwidGVzdENoYXIiLCJyZWFkIiwic3RhcnRpbmdfcGF0dGVybiIsInVudGlsX3BhdHRlcm4iLCJ1bnRpbF9hZnRlciIsInJlYWRVbnRpbCIsIm1hdGNoX2luZGV4Iiwic3Vic3RyaW5nIiwicmVhZFVudGlsQWZ0ZXIiLCJnZXRfcmVnZXhwIiwibWF0Y2hfZnJvbSIsImZsYWdzIiwic291cmNlIiwiZ2V0X2xpdGVyYWxfcmVnZXhwIiwibGl0ZXJhbF9zdHJpbmciLCJwZWVrVW50aWxBZnRlciIsInN0YXJ0IiwibG9va0JhY2siLCJ0ZXN0VmFsIiwidG9Mb3dlckNhc2UiLCJfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiVG9rZW5TdHJlYW0iLCJXaGl0ZXNwYWNlUGF0dGVybiIsIlRPS0VOIiwiU1RBUlQiLCJSQVciLCJFT0YiLCJUb2tlbml6ZXIiLCJfaW5wdXQiLCJfb3B0aW9ucyIsIl9fdG9rZW5zIiwiX3BhdHRlcm5zIiwid2hpdGVzcGFjZSIsInRva2VuaXplIiwiX3Jlc2V0IiwiY3VycmVudCIsIm9wZW5fdG9rZW4iLCJvcGVuX3N0YWNrIiwiY29tbWVudHMiLCJfZ2V0X25leHRfdG9rZW4iLCJfaXNfY29tbWVudCIsImFkZCIsImlzRW1wdHkiLCJfaXNfb3BlbmluZyIsIl9pc19jbG9zaW5nIiwiX2lzX2ZpcnN0X3Rva2VuIiwicHJldmlvdXNfdG9rZW4iLCJfcmVhZFdoaXRlc3BhY2UiLCJyZXN1bHRpbmdfc3RyaW5nIiwiX2NyZWF0ZV90b2tlbiIsImN1cnJlbnRfdG9rZW4iLCJuZXdsaW5lX2NvdW50Iiwid2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4iLCJwYXJlbnRfdG9rZW4iLCJfX3Rva2Vuc19sZW5ndGgiLCJfX3BhcmVudF90b2tlbiIsIlBhdHRlcm4iLCJpbnB1dF9zY2FubmVyIiwiY2FsbCIsIl9saW5lX3JlZ2V4cCIsIl9fc2V0X3doaXRlc3BhY2VfcGF0dGVybnMiLCJ3aGl0ZXNwYWNlX2NoYXJzIiwibmV3bGluZV9jaGFycyIsIl9tYXRjaF9wYXR0ZXJuIiwiX25ld2xpbmVfcmVnZXhwIiwibWF0Y2hlcyIsIl9fc3BsaXQiLCJtYXRjaGluZyIsIl9jcmVhdGUiLCJfdXBkYXRlIiwicmVnZXhwIiwic3RhcnRfaW5kZXgiLCJuZXh0X21hdGNoIiwiX3N0YXJ0aW5nX3BhdHRlcm4iLCJfdW50aWxfcGF0dGVybiIsIl91bnRpbF9hZnRlciIsInJlYWRfbWF0Y2giLCJ1bnRpbCIsInN0YXJ0aW5nX3dpdGgiLCJEaXJlY3RpdmVzIiwic3RhcnRfYmxvY2tfcGF0dGVybiIsImVuZF9ibG9ja19wYXR0ZXJuIiwiX19kaXJlY3RpdmVzX2Jsb2NrX3BhdHRlcm4iLCJfX2RpcmVjdGl2ZV9wYXR0ZXJuIiwiX19kaXJlY3RpdmVzX2VuZF9pZ25vcmVfcGF0dGVybiIsImdldF9kaXJlY3RpdmVzIiwiZGlyZWN0aXZlX21hdGNoIiwicmVhZElnbm9yZWQiLCJpbnB1dCIsInRlbXBsYXRlX25hbWVzIiwiZGphbmdvIiwiZXJiIiwiaGFuZGxlYmFycyIsInBocCIsInNtYXJ0eSIsImFuZ3VsYXIiLCJUZW1wbGF0YWJsZVBhdHRlcm4iLCJfX3RlbXBsYXRlX3BhdHRlcm4iLCJfZGlzYWJsZWQiLCJPYmplY3QiLCJhc3NpZ24iLCJfZXhjbHVkZWQiLCJfX3BhdHRlcm5zIiwiaGFuZGxlYmFyc19jb21tZW50IiwiaGFuZGxlYmFyc191bmVzY2FwZWQiLCJkamFuZ29fdmFsdWUiLCJkamFuZ29fY29tbWVudCIsInNtYXJ0eV9jb21tZW50Iiwic21hcnR5X2xpdGVyYWwiLCJfX3NldF90ZW1wbGF0ZWRfcGF0dGVybiIsImRpc2FibGUiLCJsYW5ndWFnZSIsInJlYWRfb3B0aW9ucyIsImV4Y2x1ZGUiLCJfcmVhZF90ZW1wbGF0ZSIsIml0ZW1zIiwiYyIsInBlZWsxIiwiQmVhdXRpZmllciIsInN0eWxlX2h0bWwiLCJodG1sX3NvdXJjZSIsImpzX2JlYXV0aWZ5IiwiY3NzX2JlYXV0aWZ5IiwiYmVhdXRpZmllciIsImJlYXV0aWZ5IiwiZGVmYXVsdE9wdGlvbnMiLCJsaW5lQnJlYWsiLCJhbGxMaW5lQnJlYWtzIiwiUHJpbnRlciIsImJhc2VfaW5kZW50X3N0cmluZyIsImFsaWdubWVudF9zaXplIiwiX291dHB1dCIsImN1cnJlbnRfbGluZV9oYXNfbWF0Y2giLCJzZXRfc3BhY2VfYmVmb3JlX3Rva2VuIiwidmFsdWUiLCJub25fYnJlYWtpbmciLCJwcmludF9wcmVzZXJ2ZWRfbmV3bGluZXMiLCJyYXdfdG9rZW4iLCJURVhUIiwibiIsInByaW50X25ld2xpbmUiLCJ0cmF2ZXJzZV93aGl0ZXNwYWNlIiwiZm9yY2UiLCJwcmludF90b2tlbiIsImRlaW5kZW50IiwiZ2V0X2Z1bGxfaW5kZW50IiwibGV2ZWwiLCJnZXRfdHlwZV9hdHRyaWJ1dGUiLCJzdGFydF90b2tlbiIsIkFUVFJJQlVURSIsIkVRVUFMUyIsIlZBTFVFIiwiZ2V0X2N1c3RvbV9iZWF1dGlmaWVyX25hbWUiLCJ0YWdfY2hlY2siLCJ0eXBlQXR0cmlidXRlIiwic2VhcmNoIiwiaW5fYXJyYXkiLCJ3aGF0IiwiYXJyIiwiVGFnRnJhbWUiLCJwYXJzZXJfdG9rZW4iLCJ0YWciLCJ0YWdfbmFtZSIsIlRhZ1N0YWNrIiwicHJpbnRlciIsIl9wcmludGVyIiwiX2N1cnJlbnRfZnJhbWUiLCJnZXRfcGFyc2VyX3Rva2VuIiwicmVjb3JkX3RhZyIsIm5ld19mcmFtZSIsIl90cnlfcG9wX2ZyYW1lIiwiZnJhbWUiLCJfZ2V0X2ZyYW1lIiwidGFnX2xpc3QiLCJzdG9wX2xpc3QiLCJ0cnlfcG9wIiwiaW5kZW50X3RvX3RhZyIsInNvdXJjZV90ZXh0IiwiX3NvdXJjZV90ZXh0IiwiX2pzX2JlYXV0aWZ5IiwiX2Nzc19iZWF1dGlmeSIsIl90YWdfc3RhY2siLCJvcHRpb25IdG1sIiwiX2lzX3dyYXBfYXR0cmlidXRlc19mb3JjZSIsIndyYXBfYXR0cmlidXRlcyIsInN1YnN0ciIsIl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfZXhwYW5kX211bHRpbGluZSIsIl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfYWxpZ25lZCIsIl9pc193cmFwX2F0dHJpYnV0ZXNfYWxpZ25lZF9tdWx0aXBsZSIsIl9pc193cmFwX2F0dHJpYnV0ZXNfcHJlc2VydmUiLCJfaXNfd3JhcF9hdHRyaWJ1dGVzX3ByZXNlcnZlX2FsaWduZWQiLCJsYXN0X3Rva2VuIiwibGFzdF90YWdfdG9rZW4iLCJUYWdPcGVuUGFyc2VyVG9rZW4iLCJ0b2tlbnMiLCJUQUdfT1BFTiIsIkNPTU1FTlQiLCJfaGFuZGxlX3RhZ19vcGVuIiwidGFnX2NvbXBsZXRlIiwiX2hhbmRsZV9pbnNpZGVfdGFnIiwiVEFHX0NMT1NFIiwiX2hhbmRsZV90YWdfY2xvc2UiLCJfaGFuZGxlX3RleHQiLCJDT05UUk9MX0ZMT1dfT1BFTiIsIl9oYW5kbGVfY29udHJvbF9mbG93X29wZW4iLCJDT05UUk9MX0ZMT1dfQ0xPU0UiLCJfaGFuZGxlX2NvbnRyb2xfZmxvd19jbG9zZSIsImlzX3VuZm9ybWF0dGVkIiwidGFnX3N0YXJ0X2NoYXIiLCJoYXNfd3JhcHBlZF9hdHRycyIsImluZGVudF9jb250ZW50IiwiaXNfY29udGVudF91bmZvcm1hdHRlZCIsImlzX2lubGluZV9lbGVtZW50Iiwid3JhcHBlZCIsImF0dHJfY291bnQiLCJ3cmFwX2F0dHJpYnV0ZXNfbWluX2F0dHJzIiwiY3VzdG9tX2JlYXV0aWZpZXJfbmFtZSIsIl9wcmludF9jdXN0b21fYmVhdGlmaWVyX3RleHQiLCJsb2NhbCIsIl9iZWF1dGlmaWVyIiwic2NyaXB0X2luZGVudF9sZXZlbCIsInByZSIsInBvc3QiLCJpbmRlbnRfc2NyaXB0cyIsImluZGVudGF0aW9uIiwibWF0Y2hlZCIsIkNoaWxkX29wdGlvbnMiLCJjaGlsZF9vcHRpb25zIiwid2hpdGUiLCJfZ2V0X3RhZ19vcGVuX3Rva2VuIiwiaXNfZW1wdHlfZWxlbWVudCIsImlzX3N0YXJ0X3RhZyIsInN0YXJ0X3RhZ190b2tlbiIsIl9zZXRfdGFnX3Bvc2l0aW9uIiwicGVla19pbmRleCIsInBlZWtfdG9rZW4iLCJpc19lbmRfdGFnIiwibXVsdGlsaW5lX2NvbnRlbnQiLCJ0YWdfY2hlY2tfbWF0Y2giLCJzdGFydHNXaXRoIiwiaGFuZGxlYmFyX3N0YXJ0cyIsIndyYXBfYXR0cmlidXRlc19pbmRlbnRfc2l6ZSIsInZvaWRfZWxlbWVudHMiLCJ1bmZvcm1hdHRlZCIsImNvbnRlbnRfdW5mb3JtYXR0ZWQiLCJpbmxpbmUiLCJpbmxpbmVfY3VzdG9tX2VsZW1lbnRzIiwiaW5jbHVkZXMiLCJfZG9fb3B0aW9uYWxfZW5kX2VsZW1lbnQiLCJleHRyYV9saW5lcnMiLCJmb3VuZElmT25DdXJyZW50TGluZSIsIl9jYWxjbHVhdGVfcGFyZW50X211bHRpbGluZSIsImRvX2VuZF9leHBhbmQiLCJpbmRlbnRfaW5uZXJfaHRtbCIsImluZGVudF9oZWFkX2lubmVyX2h0bWwiLCJpbmRlbnRfYm9keV9pbm5lcl9odG1sIiwicF9jbG9zZXJzIiwicF9wYXJlbnRfZXhjbHVkZXMiLCJwX3BhcmVudCIsIkJhc2VPcHRpb25zIiwiaW5kZW50X2hhbmRsZWJhcnMiLCJ1bmZvcm1hdHRlZF9jb250ZW50X2RlbGltaXRlciIsIkJhc2VUb2tlbml6ZXIiLCJCQVNFVE9LRU4iLCJVTktOT1dOIiwiZGlyZWN0aXZlc19jb3JlIiwiX2N1cnJlbnRfdGFnX25hbWUiLCJ0ZW1wbGF0YWJsZV9yZWFkZXIiLCJwYXR0ZXJuX3JlYWRlciIsIndvcmQiLCJ3b3JkX2NvbnRyb2xfZmxvd19jbG9zZV9leGNsdWRlZCIsInNpbmdsZV9xdW90ZSIsImRvdWJsZV9xdW90ZSIsImF0dHJpYnV0ZSIsImVsZW1lbnRfbmFtZSIsImFuZ3VsYXJfY29udHJvbF9mbG93X3N0YXJ0IiwiaGFuZGxlYmFyc19vcGVuIiwiaGFuZGxlYmFyc19yYXdfY2xvc2UiLCJjb21tZW50IiwiY2RhdGEiLCJjb25kaXRpb25hbF9jb21tZW50IiwicHJvY2Vzc2luZyIsIl91bmZvcm1hdHRlZF9jb250ZW50X2RlbGltaXRlciIsImxpdGVyYWxfcmVnZXhwIiwiZW5kc1dpdGgiLCJfcmVhZF9vcGVuX2hhbmRsZWJhcnMiLCJfcmVhZF9hdHRyaWJ1dGUiLCJfcmVhZF9jbG9zZSIsIl9yZWFkX2NvbnRyb2xfZmxvd3MiLCJfcmVhZF9yYXdfY29udGVudCIsIl9yZWFkX2NvbnRlbnRfd29yZCIsIl9yZWFkX2NvbW1lbnRfb3JfY2RhdGEiLCJfcmVhZF9wcm9jZXNzaW5nIiwiX3JlYWRfb3BlbiIsImlnbm9yZSIsIm9wZW5pbmdfcGFyZW50aGVzZXNfY291bnQiLCJjbG9zaW5nX3BhcmVudGhlc2VzX2NvdW50IiwibmV4dF9jaGFyIiwiY29udGVudCIsIl9pc19jb250ZW50X3VuZm9ybWF0dGVkIiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwibW9kdWxlSWQiLCJjYWNoZWRNb2R1bGUiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiZGVmaW5lIiwiYW1kIiwicmVxdWlyZWFtZCIsImh0bWxfYmVhdXRpZnkiLCJyZXF1aXJlIiwid2luZG93IiwiZ2xvYmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/js-beautify/js/lib/beautify-html.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/js-beautify/js/lib/beautify.js":
/*!*****************************************************!*\
  !*** ./node_modules/js-beautify/js/lib/beautify.js ***!
  \*****************************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/* AUTO-GENERATED. DO NOT MODIFY. */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n JS Beautifier\n---------------\n\n\n  Written by Einar Lielmanis, <einar@beautifier.io>\n      https://beautifier.io/\n\n  Originally converted to javascript by Vital, <vital76@gmail.com>\n  \"End braces on own line\" added by Chris J. Shull, <chrisjshull@gmail.com>\n  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@beautifier.io>\n\n\n  Usage:\n    js_beautify(js_source_text);\n    js_beautify(js_source_text, options);\n\n  The options are:\n    indent_size (default 4)          - indentation size,\n    indent_char (default space)      - character to indent with,\n    preserve_newlines (default true) - whether existing line breaks should be preserved,\n    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,\n\n    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.\n\n            jslint_happy        !jslint_happy\n            ---------------------------------\n            function ()         function()\n\n            switch () {         switch() {\n            case 1:               case 1:\n              break;                break;\n            }                   }\n\n    space_after_anon_function (default false) - should the space before an anonymous function's parens be added, \"function()\" vs \"function ()\",\n          NOTE: This option is overridden by jslint_happy (i.e. if jslint_happy is true, space_after_anon_function is true by design)\n\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\" | \"none\" | any of the former + \",preserve-inline\"\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.\n            preserve-inline will try to preserve inline blocks of curly braces\n\n    space_before_conditional (default true) - should the space before conditional statement be added, \"if(true)\" vs \"if (true)\",\n\n    unescape_strings (default false) - should printable characters in strings encoded in \\xNN notation be unescaped, \"example\" vs \"\\x65\\x78\\x61\\x6d\\x70\\x6c\\x65\"\n\n    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.\n          NOTE: This is not a hard limit. Lines will continue until a point where a newline would\n                be preserved if it were present.\n\n    end_with_newline (default false)  - end output with a newline\n\n\n    e.g\n\n    js_beautify(js_source_text, {\n      'indent_size': 1,\n      'indent_char': '\\t'\n    });\n\n*/ (function() {\n    /* GENERATED_BUILD_OUTPUT */ var legacy_beautify_js;\n    /******/ (function() {\n        /******/ \"use strict\";\n        /******/ var __webpack_modules__ = [\n            /* 0 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_4024__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Beautifier = __nested_webpack_require_4024__(1).Beautifier, Options = __nested_webpack_require_4024__(5).Options;\n                function js_beautify(js_source_text, options) {\n                    var beautifier = new Beautifier(js_source_text, options);\n                    return beautifier.beautify();\n                }\n                module.exports = js_beautify;\n                module.exports.defaultOptions = function() {\n                    return new Options();\n                };\n            /***/ },\n            /* 1 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_5811__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Output = __nested_webpack_require_5811__(2).Output;\n                var Token = __nested_webpack_require_5811__(3).Token;\n                var acorn = __nested_webpack_require_5811__(4);\n                var Options = __nested_webpack_require_5811__(5).Options;\n                var Tokenizer = __nested_webpack_require_5811__(7).Tokenizer;\n                var line_starters = __nested_webpack_require_5811__(7).line_starters;\n                var positionable_operators = __nested_webpack_require_5811__(7).positionable_operators;\n                var TOKEN = __nested_webpack_require_5811__(7).TOKEN;\n                function in_array(what, arr) {\n                    return arr.indexOf(what) !== -1;\n                }\n                function ltrim(s) {\n                    return s.replace(/^\\s+/g, \"\");\n                }\n                function generateMapFromStrings(list) {\n                    var result = {};\n                    for(var x = 0; x < list.length; x++){\n                        // make the mapped names underscored instead of dash\n                        result[list[x].replace(/-/g, \"_\")] = list[x];\n                    }\n                    return result;\n                }\n                function reserved_word(token, word) {\n                    return token && token.type === TOKEN.RESERVED && token.text === word;\n                }\n                function reserved_array(token, words) {\n                    return token && token.type === TOKEN.RESERVED && in_array(token.text, words);\n                }\n                // Unsure of what they mean, but they work. Worth cleaning up in future.\n                var special_words = [\n                    \"case\",\n                    \"return\",\n                    \"do\",\n                    \"if\",\n                    \"throw\",\n                    \"else\",\n                    \"await\",\n                    \"break\",\n                    \"continue\",\n                    \"async\"\n                ];\n                var validPositionValues = [\n                    \"before-newline\",\n                    \"after-newline\",\n                    \"preserve-newline\"\n                ];\n                // Generate map from array\n                var OPERATOR_POSITION = generateMapFromStrings(validPositionValues);\n                var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [\n                    OPERATOR_POSITION.before_newline,\n                    OPERATOR_POSITION.preserve_newline\n                ];\n                var MODE = {\n                    BlockStatement: \"BlockStatement\",\n                    Statement: \"Statement\",\n                    ObjectLiteral: \"ObjectLiteral\",\n                    ArrayLiteral: \"ArrayLiteral\",\n                    ForInitializer: \"ForInitializer\",\n                    Conditional: \"Conditional\",\n                    Expression: \"Expression\" //'(EXPRESSION)'\n                };\n                function remove_redundant_indentation(output, frame) {\n                    // This implementation is effective but has some issues:\n                    //     - can cause line wrap to happen too soon due to indent removal\n                    //           after wrap points are calculated\n                    // These issues are minor compared to ugly indentation.\n                    if (frame.multiline_frame || frame.mode === MODE.ForInitializer || frame.mode === MODE.Conditional) {\n                        return;\n                    }\n                    // remove one indent from each line inside this section\n                    output.remove_indent(frame.start_line_index);\n                }\n                // we could use just string.split, but\n                // IE doesn't like returning empty strings\n                function split_linebreaks(s) {\n                    //return s.split(/\\x0d\\x0a|\\x0a/);\n                    s = s.replace(acorn.allLineBreaks, \"\\n\");\n                    var out = [], idx = s.indexOf(\"\\n\");\n                    while(idx !== -1){\n                        out.push(s.substring(0, idx));\n                        s = s.substring(idx + 1);\n                        idx = s.indexOf(\"\\n\");\n                    }\n                    if (s.length) {\n                        out.push(s);\n                    }\n                    return out;\n                }\n                function is_array(mode) {\n                    return mode === MODE.ArrayLiteral;\n                }\n                function is_expression(mode) {\n                    return in_array(mode, [\n                        MODE.Expression,\n                        MODE.ForInitializer,\n                        MODE.Conditional\n                    ]);\n                }\n                function all_lines_start_with(lines, c) {\n                    for(var i = 0; i < lines.length; i++){\n                        var line = lines[i].trim();\n                        if (line.charAt(0) !== c) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                function each_line_matches_indent(lines, indent) {\n                    var i = 0, len = lines.length, line;\n                    for(; i < len; i++){\n                        line = lines[i];\n                        // allow empty lines to pass through\n                        if (line && line.indexOf(indent) !== 0) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                function Beautifier(source_text, options) {\n                    options = options || {};\n                    this._source_text = source_text || \"\";\n                    this._output = null;\n                    this._tokens = null;\n                    this._last_last_text = null;\n                    this._flags = null;\n                    this._previous_flags = null;\n                    this._flag_store = null;\n                    this._options = new Options(options);\n                }\n                Beautifier.prototype.create_flags = function(flags_base, mode) {\n                    var next_indent_level = 0;\n                    if (flags_base) {\n                        next_indent_level = flags_base.indentation_level;\n                        if (!this._output.just_added_newline() && flags_base.line_indent_level > next_indent_level) {\n                            next_indent_level = flags_base.line_indent_level;\n                        }\n                    }\n                    var next_flags = {\n                        mode: mode,\n                        parent: flags_base,\n                        last_token: flags_base ? flags_base.last_token : new Token(TOKEN.START_BLOCK, \"\"),\n                        last_word: flags_base ? flags_base.last_word : \"\",\n                        declaration_statement: false,\n                        declaration_assignment: false,\n                        multiline_frame: false,\n                        inline_frame: false,\n                        if_block: false,\n                        else_block: false,\n                        class_start_block: false,\n                        do_block: false,\n                        do_while: false,\n                        import_block: false,\n                        in_case_statement: false,\n                        in_case: false,\n                        case_body: false,\n                        case_block: false,\n                        indentation_level: next_indent_level,\n                        alignment: 0,\n                        line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,\n                        start_line_index: this._output.get_line_number(),\n                        ternary_depth: 0\n                    };\n                    return next_flags;\n                };\n                Beautifier.prototype._reset = function(source_text) {\n                    var baseIndentString = source_text.match(/^[\\t ]*/)[0];\n                    this._last_last_text = \"\"; // pre-last token text\n                    this._output = new Output(this._options, baseIndentString);\n                    // If testing the ignore directive, start with output disable set to true\n                    this._output.raw = this._options.test_output_raw;\n                    // Stack of parsing/formatting states, including MODE.\n                    // We tokenize, parse, and output in an almost purely a forward-only stream of token input\n                    // and formatted output.  This makes the beautifier less accurate than full parsers\n                    // but also far more tolerant of syntax errors.\n                    //\n                    // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type\n                    // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later\n                    // encounter a \":\", we'll switch to to MODE.ObjectLiteral.  If we then see a \";\",\n                    // most full parsers would die, but the beautifier gracefully falls back to\n                    // MODE.BlockStatement and continues on.\n                    this._flag_store = [];\n                    this.set_mode(MODE.BlockStatement);\n                    var tokenizer = new Tokenizer(source_text, this._options);\n                    this._tokens = tokenizer.tokenize();\n                    return source_text;\n                };\n                Beautifier.prototype.beautify = function() {\n                    // if disabled, return the input unchanged.\n                    if (this._options.disabled) {\n                        return this._source_text;\n                    }\n                    var sweet_code;\n                    var source_text = this._reset(this._source_text);\n                    var eol = this._options.eol;\n                    if (this._options.eol === \"auto\") {\n                        eol = \"\\n\";\n                        if (source_text && acorn.lineBreak.test(source_text || \"\")) {\n                            eol = source_text.match(acorn.lineBreak)[0];\n                        }\n                    }\n                    var current_token = this._tokens.next();\n                    while(current_token){\n                        this.handle_token(current_token);\n                        this._last_last_text = this._flags.last_token.text;\n                        this._flags.last_token = current_token;\n                        current_token = this._tokens.next();\n                    }\n                    sweet_code = this._output.get_code(eol);\n                    return sweet_code;\n                };\n                Beautifier.prototype.handle_token = function(current_token, preserve_statement_flags) {\n                    if (current_token.type === TOKEN.START_EXPR) {\n                        this.handle_start_expr(current_token);\n                    } else if (current_token.type === TOKEN.END_EXPR) {\n                        this.handle_end_expr(current_token);\n                    } else if (current_token.type === TOKEN.START_BLOCK) {\n                        this.handle_start_block(current_token);\n                    } else if (current_token.type === TOKEN.END_BLOCK) {\n                        this.handle_end_block(current_token);\n                    } else if (current_token.type === TOKEN.WORD) {\n                        this.handle_word(current_token);\n                    } else if (current_token.type === TOKEN.RESERVED) {\n                        this.handle_word(current_token);\n                    } else if (current_token.type === TOKEN.SEMICOLON) {\n                        this.handle_semicolon(current_token);\n                    } else if (current_token.type === TOKEN.STRING) {\n                        this.handle_string(current_token);\n                    } else if (current_token.type === TOKEN.EQUALS) {\n                        this.handle_equals(current_token);\n                    } else if (current_token.type === TOKEN.OPERATOR) {\n                        this.handle_operator(current_token);\n                    } else if (current_token.type === TOKEN.COMMA) {\n                        this.handle_comma(current_token);\n                    } else if (current_token.type === TOKEN.BLOCK_COMMENT) {\n                        this.handle_block_comment(current_token, preserve_statement_flags);\n                    } else if (current_token.type === TOKEN.COMMENT) {\n                        this.handle_comment(current_token, preserve_statement_flags);\n                    } else if (current_token.type === TOKEN.DOT) {\n                        this.handle_dot(current_token);\n                    } else if (current_token.type === TOKEN.EOF) {\n                        this.handle_eof(current_token);\n                    } else if (current_token.type === TOKEN.UNKNOWN) {\n                        this.handle_unknown(current_token, preserve_statement_flags);\n                    } else {\n                        this.handle_unknown(current_token, preserve_statement_flags);\n                    }\n                };\n                Beautifier.prototype.handle_whitespace_and_comments = function(current_token, preserve_statement_flags) {\n                    var newlines = current_token.newlines;\n                    var keep_whitespace = this._options.keep_array_indentation && is_array(this._flags.mode);\n                    if (current_token.comments_before) {\n                        var comment_token = current_token.comments_before.next();\n                        while(comment_token){\n                            // The cleanest handling of inline comments is to treat them as though they aren't there.\n                            // Just continue formatting and the behavior should be logical.\n                            // Also ignore unknown tokens.  Again, this should result in better behavior.\n                            this.handle_whitespace_and_comments(comment_token, preserve_statement_flags);\n                            this.handle_token(comment_token, preserve_statement_flags);\n                            comment_token = current_token.comments_before.next();\n                        }\n                    }\n                    if (keep_whitespace) {\n                        for(var i = 0; i < newlines; i += 1){\n                            this.print_newline(i > 0, preserve_statement_flags);\n                        }\n                    } else {\n                        if (this._options.max_preserve_newlines && newlines > this._options.max_preserve_newlines) {\n                            newlines = this._options.max_preserve_newlines;\n                        }\n                        if (this._options.preserve_newlines) {\n                            if (newlines > 1) {\n                                this.print_newline(false, preserve_statement_flags);\n                                for(var j = 1; j < newlines; j += 1){\n                                    this.print_newline(true, preserve_statement_flags);\n                                }\n                            }\n                        }\n                    }\n                };\n                var newline_restricted_tokens = [\n                    \"async\",\n                    \"break\",\n                    \"continue\",\n                    \"return\",\n                    \"throw\",\n                    \"yield\"\n                ];\n                Beautifier.prototype.allow_wrap_or_preserved_newline = function(current_token, force_linewrap) {\n                    force_linewrap = force_linewrap === undefined ? false : force_linewrap;\n                    // Never wrap the first token on a line\n                    if (this._output.just_added_newline()) {\n                        return;\n                    }\n                    var shouldPreserveOrForce = this._options.preserve_newlines && current_token.newlines || force_linewrap;\n                    var operatorLogicApplies = in_array(this._flags.last_token.text, positionable_operators) || in_array(current_token.text, positionable_operators);\n                    if (operatorLogicApplies) {\n                        var shouldPrintOperatorNewline = in_array(this._flags.last_token.text, positionable_operators) && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE) || in_array(current_token.text, positionable_operators);\n                        shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;\n                    }\n                    if (shouldPreserveOrForce) {\n                        this.print_newline(false, true);\n                    } else if (this._options.wrap_line_length) {\n                        if (reserved_array(this._flags.last_token, newline_restricted_tokens)) {\n                            // These tokens should never have a newline inserted\n                            // between them and the following expression.\n                            return;\n                        }\n                        this._output.set_wrap_point();\n                    }\n                };\n                Beautifier.prototype.print_newline = function(force_newline, preserve_statement_flags) {\n                    if (!preserve_statement_flags) {\n                        if (this._flags.last_token.text !== \";\" && this._flags.last_token.text !== \",\" && this._flags.last_token.text !== \"=\" && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === \"--\" || this._flags.last_token.text === \"++\")) {\n                            var next_token = this._tokens.peek();\n                            while(this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, \"else\")) && !this._flags.do_block){\n                                this.restore_mode();\n                            }\n                        }\n                    }\n                    if (this._output.add_new_line(force_newline)) {\n                        this._flags.multiline_frame = true;\n                    }\n                };\n                Beautifier.prototype.print_token_line_indentation = function(current_token) {\n                    if (this._output.just_added_newline()) {\n                        if (this._options.keep_array_indentation && current_token.newlines && (current_token.text === \"[\" || is_array(this._flags.mode))) {\n                            this._output.current_line.set_indent(-1);\n                            this._output.current_line.push(current_token.whitespace_before);\n                            this._output.space_before_token = false;\n                        } else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) {\n                            this._flags.line_indent_level = this._flags.indentation_level;\n                        }\n                    }\n                };\n                Beautifier.prototype.print_token = function(current_token) {\n                    if (this._output.raw) {\n                        this._output.add_raw_token(current_token);\n                        return;\n                    }\n                    if (this._options.comma_first && current_token.previous && current_token.previous.type === TOKEN.COMMA && this._output.just_added_newline()) {\n                        if (this._output.previous_line.last() === \",\") {\n                            var popped = this._output.previous_line.pop();\n                            // if the comma was already at the start of the line,\n                            // pull back onto that line and reprint the indentation\n                            if (this._output.previous_line.is_empty()) {\n                                this._output.previous_line.push(popped);\n                                this._output.trim(true);\n                                this._output.current_line.pop();\n                                this._output.trim();\n                            }\n                            // add the comma in front of the next token\n                            this.print_token_line_indentation(current_token);\n                            this._output.add_token(\",\");\n                            this._output.space_before_token = true;\n                        }\n                    }\n                    this.print_token_line_indentation(current_token);\n                    this._output.non_breaking_space = true;\n                    this._output.add_token(current_token.text);\n                    if (this._output.previous_token_wrapped) {\n                        this._flags.multiline_frame = true;\n                    }\n                };\n                Beautifier.prototype.indent = function() {\n                    this._flags.indentation_level += 1;\n                    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);\n                };\n                Beautifier.prototype.deindent = function() {\n                    if (this._flags.indentation_level > 0 && (!this._flags.parent || this._flags.indentation_level > this._flags.parent.indentation_level)) {\n                        this._flags.indentation_level -= 1;\n                        this._output.set_indent(this._flags.indentation_level, this._flags.alignment);\n                    }\n                };\n                Beautifier.prototype.set_mode = function(mode) {\n                    if (this._flags) {\n                        this._flag_store.push(this._flags);\n                        this._previous_flags = this._flags;\n                    } else {\n                        this._previous_flags = this.create_flags(null, mode);\n                    }\n                    this._flags = this.create_flags(this._previous_flags, mode);\n                    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);\n                };\n                Beautifier.prototype.restore_mode = function() {\n                    if (this._flag_store.length > 0) {\n                        this._previous_flags = this._flags;\n                        this._flags = this._flag_store.pop();\n                        if (this._previous_flags.mode === MODE.Statement) {\n                            remove_redundant_indentation(this._output, this._previous_flags);\n                        }\n                        this._output.set_indent(this._flags.indentation_level, this._flags.alignment);\n                    }\n                };\n                Beautifier.prototype.start_of_object_property = function() {\n                    return this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement && (this._flags.last_token.text === \":\" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, [\n                        \"get\",\n                        \"set\"\n                    ]));\n                };\n                Beautifier.prototype.start_of_statement = function(current_token) {\n                    var start = false;\n                    start = start || reserved_array(this._flags.last_token, [\n                        \"var\",\n                        \"let\",\n                        \"const\"\n                    ]) && current_token.type === TOKEN.WORD;\n                    start = start || reserved_word(this._flags.last_token, \"do\");\n                    start = start || !(this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement) && reserved_array(this._flags.last_token, newline_restricted_tokens) && !current_token.newlines;\n                    start = start || reserved_word(this._flags.last_token, \"else\") && !(reserved_word(current_token, \"if\") && !current_token.comments_before);\n                    start = start || this._flags.last_token.type === TOKEN.END_EXPR && (this._previous_flags.mode === MODE.ForInitializer || this._previous_flags.mode === MODE.Conditional);\n                    start = start || this._flags.last_token.type === TOKEN.WORD && this._flags.mode === MODE.BlockStatement && !this._flags.in_case && !(current_token.text === \"--\" || current_token.text === \"++\") && this._last_last_text !== \"function\" && current_token.type !== TOKEN.WORD && current_token.type !== TOKEN.RESERVED;\n                    start = start || this._flags.mode === MODE.ObjectLiteral && (this._flags.last_token.text === \":\" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, [\n                        \"get\",\n                        \"set\"\n                    ]));\n                    if (start) {\n                        this.set_mode(MODE.Statement);\n                        this.indent();\n                        this.handle_whitespace_and_comments(current_token, true);\n                        // Issue #276:\n                        // If starting a new statement with [if, for, while, do], push to a new line.\n                        // if (a) if (b) if(c) d(); else e(); else f();\n                        if (!this.start_of_object_property()) {\n                            this.allow_wrap_or_preserved_newline(current_token, reserved_array(current_token, [\n                                \"do\",\n                                \"for\",\n                                \"if\",\n                                \"while\"\n                            ]));\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                Beautifier.prototype.handle_start_expr = function(current_token) {\n                    // The conditional starts the statement if appropriate.\n                    if (!this.start_of_statement(current_token)) {\n                        this.handle_whitespace_and_comments(current_token);\n                    }\n                    var next_mode = MODE.Expression;\n                    if (current_token.text === \"[\") {\n                        if (this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === \")\") {\n                            // this is array index specifier, break immediately\n                            // a[x], fn()[x]\n                            if (reserved_array(this._flags.last_token, line_starters)) {\n                                this._output.space_before_token = true;\n                            }\n                            this.print_token(current_token);\n                            this.set_mode(next_mode);\n                            this.indent();\n                            if (this._options.space_in_paren) {\n                                this._output.space_before_token = true;\n                            }\n                            return;\n                        }\n                        next_mode = MODE.ArrayLiteral;\n                        if (is_array(this._flags.mode)) {\n                            if (this._flags.last_token.text === \"[\" || this._flags.last_token.text === \",\" && (this._last_last_text === \"]\" || this._last_last_text === \"}\")) {\n                                // ], [ goes to new line\n                                // }, [ goes to new line\n                                if (!this._options.keep_array_indentation) {\n                                    this.print_newline();\n                                }\n                            }\n                        }\n                        if (!in_array(this._flags.last_token.type, [\n                            TOKEN.START_EXPR,\n                            TOKEN.END_EXPR,\n                            TOKEN.WORD,\n                            TOKEN.OPERATOR,\n                            TOKEN.DOT\n                        ])) {\n                            this._output.space_before_token = true;\n                        }\n                    } else {\n                        if (this._flags.last_token.type === TOKEN.RESERVED) {\n                            if (this._flags.last_token.text === \"for\") {\n                                this._output.space_before_token = this._options.space_before_conditional;\n                                next_mode = MODE.ForInitializer;\n                            } else if (in_array(this._flags.last_token.text, [\n                                \"if\",\n                                \"while\",\n                                \"switch\"\n                            ])) {\n                                this._output.space_before_token = this._options.space_before_conditional;\n                                next_mode = MODE.Conditional;\n                            } else if (in_array(this._flags.last_word, [\n                                \"await\",\n                                \"async\"\n                            ])) {\n                                // Should be a space between await and an IIFE, or async and an arrow function\n                                this._output.space_before_token = true;\n                            } else if (this._flags.last_token.text === \"import\" && current_token.whitespace_before === \"\") {\n                                this._output.space_before_token = false;\n                            } else if (in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === \"catch\") {\n                                this._output.space_before_token = true;\n                            }\n                        } else if (this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {\n                            // Support of this kind of newline preservation.\n                            // a = (b &&\n                            //     (c || d));\n                            if (!this.start_of_object_property()) {\n                                this.allow_wrap_or_preserved_newline(current_token);\n                            }\n                        } else if (this._flags.last_token.type === TOKEN.WORD) {\n                            this._output.space_before_token = false;\n                            // function name() vs function name ()\n                            // function* name() vs function* name ()\n                            // async name() vs async name ()\n                            // In ES6, you can also define the method properties of an object\n                            // var obj = {a: function() {}}\n                            // It can be abbreviated\n                            // var obj = {a() {}}\n                            // var obj = { a() {}} vs var obj = { a () {}}\n                            // var obj = { * a() {}} vs var obj = { * a () {}}\n                            var peek_back_two = this._tokens.peek(-3);\n                            if (this._options.space_after_named_function && peek_back_two) {\n                                // peek starts at next character so -1 is current token\n                                var peek_back_three = this._tokens.peek(-4);\n                                if (reserved_array(peek_back_two, [\n                                    \"async\",\n                                    \"function\"\n                                ]) || peek_back_two.text === \"*\" && reserved_array(peek_back_three, [\n                                    \"async\",\n                                    \"function\"\n                                ])) {\n                                    this._output.space_before_token = true;\n                                } else if (this._flags.mode === MODE.ObjectLiteral) {\n                                    if (peek_back_two.text === \"{\" || peek_back_two.text === \",\" || peek_back_two.text === \"*\" && (peek_back_three.text === \"{\" || peek_back_three.text === \",\")) {\n                                        this._output.space_before_token = true;\n                                    }\n                                } else if (this._flags.parent && this._flags.parent.class_start_block) {\n                                    this._output.space_before_token = true;\n                                }\n                            }\n                        } else {\n                            // Support preserving wrapped arrow function expressions\n                            // a.b('c',\n                            //     () => d.e\n                            // )\n                            this.allow_wrap_or_preserved_newline(current_token);\n                        }\n                        // function() vs function ()\n                        // yield*() vs yield* ()\n                        // function*() vs function* ()\n                        if (this._flags.last_token.type === TOKEN.RESERVED && (this._flags.last_word === \"function\" || this._flags.last_word === \"typeof\") || this._flags.last_token.text === \"*\" && (in_array(this._last_last_text, [\n                            \"function\",\n                            \"yield\"\n                        ]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, [\n                            \"{\",\n                            \",\"\n                        ]))) {\n                            this._output.space_before_token = this._options.space_after_anon_function;\n                        }\n                    }\n                    if (this._flags.last_token.text === \";\" || this._flags.last_token.type === TOKEN.START_BLOCK) {\n                        this.print_newline();\n                    } else if (this._flags.last_token.type === TOKEN.END_EXPR || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.END_BLOCK || this._flags.last_token.text === \".\" || this._flags.last_token.type === TOKEN.COMMA) {\n                        // do nothing on (( and )( and ][ and ]( and .(\n                        // TODO: Consider whether forcing this is required.  Review failing tests when removed.\n                        this.allow_wrap_or_preserved_newline(current_token, current_token.newlines);\n                    }\n                    this.print_token(current_token);\n                    this.set_mode(next_mode);\n                    if (this._options.space_in_paren) {\n                        this._output.space_before_token = true;\n                    }\n                    // In all cases, if we newline while inside an expression it should be indented.\n                    this.indent();\n                };\n                Beautifier.prototype.handle_end_expr = function(current_token) {\n                    // statements inside expressions are not valid syntax, but...\n                    // statements must all be closed when their container closes\n                    while(this._flags.mode === MODE.Statement){\n                        this.restore_mode();\n                    }\n                    this.handle_whitespace_and_comments(current_token);\n                    if (this._flags.multiline_frame) {\n                        this.allow_wrap_or_preserved_newline(current_token, current_token.text === \"]\" && is_array(this._flags.mode) && !this._options.keep_array_indentation);\n                    }\n                    if (this._options.space_in_paren) {\n                        if (this._flags.last_token.type === TOKEN.START_EXPR && !this._options.space_in_empty_paren) {\n                            // () [] no inner space in empty parens like these, ever, ref #320\n                            this._output.trim();\n                            this._output.space_before_token = false;\n                        } else {\n                            this._output.space_before_token = true;\n                        }\n                    }\n                    this.deindent();\n                    this.print_token(current_token);\n                    this.restore_mode();\n                    remove_redundant_indentation(this._output, this._previous_flags);\n                    // do {} while () // no statement required after\n                    if (this._flags.do_while && this._previous_flags.mode === MODE.Conditional) {\n                        this._previous_flags.mode = MODE.Expression;\n                        this._flags.do_block = false;\n                        this._flags.do_while = false;\n                    }\n                };\n                Beautifier.prototype.handle_start_block = function(current_token) {\n                    this.handle_whitespace_and_comments(current_token);\n                    // Check if this is should be treated as a ObjectLiteral\n                    var next_token = this._tokens.peek();\n                    var second_token = this._tokens.peek(1);\n                    if (this._flags.last_word === \"switch\" && this._flags.last_token.type === TOKEN.END_EXPR) {\n                        this.set_mode(MODE.BlockStatement);\n                        this._flags.in_case_statement = true;\n                    } else if (this._flags.case_body) {\n                        this.set_mode(MODE.BlockStatement);\n                    } else if (second_token && (in_array(second_token.text, [\n                        \":\",\n                        \",\"\n                    ]) && in_array(next_token.type, [\n                        TOKEN.STRING,\n                        TOKEN.WORD,\n                        TOKEN.RESERVED\n                    ]) || in_array(next_token.text, [\n                        \"get\",\n                        \"set\",\n                        \"...\"\n                    ]) && in_array(second_token.type, [\n                        TOKEN.WORD,\n                        TOKEN.RESERVED\n                    ]))) {\n                        // We don't support TypeScript,but we didn't break it for a very long time.\n                        // We'll try to keep not breaking it.\n                        if (in_array(this._last_last_text, [\n                            \"class\",\n                            \"interface\"\n                        ]) && !in_array(second_token.text, [\n                            \":\",\n                            \",\"\n                        ])) {\n                            this.set_mode(MODE.BlockStatement);\n                        } else {\n                            this.set_mode(MODE.ObjectLiteral);\n                        }\n                    } else if (this._flags.last_token.type === TOKEN.OPERATOR && this._flags.last_token.text === \"=>\") {\n                        // arrow function: (param1, paramN) => { statements }\n                        this.set_mode(MODE.BlockStatement);\n                    } else if (in_array(this._flags.last_token.type, [\n                        TOKEN.EQUALS,\n                        TOKEN.START_EXPR,\n                        TOKEN.COMMA,\n                        TOKEN.OPERATOR\n                    ]) || reserved_array(this._flags.last_token, [\n                        \"return\",\n                        \"throw\",\n                        \"import\",\n                        \"default\"\n                    ])) {\n                        // Detecting shorthand function syntax is difficult by scanning forward,\n                        //     so check the surrounding context.\n                        // If the block is being returned, imported, export default, passed as arg,\n                        //     assigned with = or assigned in a nested object, treat as an ObjectLiteral.\n                        this.set_mode(MODE.ObjectLiteral);\n                    } else {\n                        this.set_mode(MODE.BlockStatement);\n                    }\n                    if (this._flags.last_token) {\n                        if (reserved_array(this._flags.last_token.previous, [\n                            \"class\",\n                            \"extends\"\n                        ])) {\n                            this._flags.class_start_block = true;\n                        }\n                    }\n                    var empty_braces = !next_token.comments_before && next_token.text === \"}\";\n                    var empty_anonymous_function = empty_braces && this._flags.last_word === \"function\" && this._flags.last_token.type === TOKEN.END_EXPR;\n                    if (this._options.brace_preserve_inline) {\n                        // search forward for a newline wanted inside this block\n                        var index = 0;\n                        var check_token = null;\n                        this._flags.inline_frame = true;\n                        do {\n                            index += 1;\n                            check_token = this._tokens.peek(index - 1);\n                            if (check_token.newlines) {\n                                this._flags.inline_frame = false;\n                                break;\n                            }\n                        }while (check_token.type !== TOKEN.EOF && !(check_token.type === TOKEN.END_BLOCK && check_token.opened === current_token));\n                    }\n                    if ((this._options.brace_style === \"expand\" || this._options.brace_style === \"none\" && current_token.newlines) && !this._flags.inline_frame) {\n                        if (this._flags.last_token.type !== TOKEN.OPERATOR && (empty_anonymous_function || this._flags.last_token.type === TOKEN.EQUALS || reserved_array(this._flags.last_token, special_words) && this._flags.last_token.text !== \"else\")) {\n                            this._output.space_before_token = true;\n                        } else {\n                            this.print_newline(false, true);\n                        }\n                    } else {\n                        if (is_array(this._previous_flags.mode) && (this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.COMMA)) {\n                            if (this._flags.last_token.type === TOKEN.COMMA || this._options.space_in_paren) {\n                                this._output.space_before_token = true;\n                            }\n                            if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR && this._flags.inline_frame) {\n                                this.allow_wrap_or_preserved_newline(current_token);\n                                this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame;\n                                this._flags.multiline_frame = false;\n                            }\n                        }\n                        if (this._flags.last_token.type !== TOKEN.OPERATOR && this._flags.last_token.type !== TOKEN.START_EXPR) {\n                            if (in_array(this._flags.last_token.type, [\n                                TOKEN.START_BLOCK,\n                                TOKEN.SEMICOLON\n                            ]) && !this._flags.inline_frame) {\n                                this.print_newline();\n                            } else {\n                                this._output.space_before_token = true;\n                            }\n                        }\n                    }\n                    this.print_token(current_token);\n                    this.indent();\n                    // Except for specific cases, open braces are followed by a new line.\n                    if (!empty_braces && !(this._options.brace_preserve_inline && this._flags.inline_frame)) {\n                        this.print_newline();\n                    }\n                };\n                Beautifier.prototype.handle_end_block = function(current_token) {\n                    // statements must all be closed when their container closes\n                    this.handle_whitespace_and_comments(current_token);\n                    while(this._flags.mode === MODE.Statement){\n                        this.restore_mode();\n                    }\n                    var empty_braces = this._flags.last_token.type === TOKEN.START_BLOCK;\n                    if (this._flags.inline_frame && !empty_braces) {\n                        this._output.space_before_token = true;\n                    } else if (this._options.brace_style === \"expand\") {\n                        if (!empty_braces) {\n                            this.print_newline();\n                        }\n                    } else {\n                        // skip {}\n                        if (!empty_braces) {\n                            if (is_array(this._flags.mode) && this._options.keep_array_indentation) {\n                                // we REALLY need a newline here, but newliner would skip that\n                                this._options.keep_array_indentation = false;\n                                this.print_newline();\n                                this._options.keep_array_indentation = true;\n                            } else {\n                                this.print_newline();\n                            }\n                        }\n                    }\n                    this.restore_mode();\n                    this.print_token(current_token);\n                };\n                Beautifier.prototype.handle_word = function(current_token) {\n                    if (current_token.type === TOKEN.RESERVED) {\n                        if (in_array(current_token.text, [\n                            \"set\",\n                            \"get\"\n                        ]) && this._flags.mode !== MODE.ObjectLiteral) {\n                            current_token.type = TOKEN.WORD;\n                        } else if (current_token.text === \"import\" && in_array(this._tokens.peek().text, [\n                            \"(\",\n                            \".\"\n                        ])) {\n                            current_token.type = TOKEN.WORD;\n                        } else if (in_array(current_token.text, [\n                            \"as\",\n                            \"from\"\n                        ]) && !this._flags.import_block) {\n                            current_token.type = TOKEN.WORD;\n                        } else if (this._flags.mode === MODE.ObjectLiteral) {\n                            var next_token = this._tokens.peek();\n                            if (next_token.text === \":\") {\n                                current_token.type = TOKEN.WORD;\n                            }\n                        }\n                    }\n                    if (this.start_of_statement(current_token)) {\n                        // The conditional starts the statement if appropriate.\n                        if (reserved_array(this._flags.last_token, [\n                            \"var\",\n                            \"let\",\n                            \"const\"\n                        ]) && current_token.type === TOKEN.WORD) {\n                            this._flags.declaration_statement = true;\n                        }\n                    } else if (current_token.newlines && !is_expression(this._flags.mode) && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === \"--\" || this._flags.last_token.text === \"++\") && this._flags.last_token.type !== TOKEN.EQUALS && (this._options.preserve_newlines || !reserved_array(this._flags.last_token, [\n                        \"var\",\n                        \"let\",\n                        \"const\",\n                        \"set\",\n                        \"get\"\n                    ]))) {\n                        this.handle_whitespace_and_comments(current_token);\n                        this.print_newline();\n                    } else {\n                        this.handle_whitespace_and_comments(current_token);\n                    }\n                    if (this._flags.do_block && !this._flags.do_while) {\n                        if (reserved_word(current_token, \"while\")) {\n                            // do {} ## while ()\n                            this._output.space_before_token = true;\n                            this.print_token(current_token);\n                            this._output.space_before_token = true;\n                            this._flags.do_while = true;\n                            return;\n                        } else {\n                            // do {} should always have while as the next word.\n                            // if we don't see the expected while, recover\n                            this.print_newline();\n                            this._flags.do_block = false;\n                        }\n                    }\n                    // if may be followed by else, or not\n                    // Bare/inline ifs are tricky\n                    // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();\n                    if (this._flags.if_block) {\n                        if (!this._flags.else_block && reserved_word(current_token, \"else\")) {\n                            this._flags.else_block = true;\n                        } else {\n                            while(this._flags.mode === MODE.Statement){\n                                this.restore_mode();\n                            }\n                            this._flags.if_block = false;\n                            this._flags.else_block = false;\n                        }\n                    }\n                    if (this._flags.in_case_statement && reserved_array(current_token, [\n                        \"case\",\n                        \"default\"\n                    ])) {\n                        this.print_newline();\n                        if (!this._flags.case_block && (this._flags.case_body || this._options.jslint_happy)) {\n                            // switch cases following one another\n                            this.deindent();\n                        }\n                        this._flags.case_body = false;\n                        this.print_token(current_token);\n                        this._flags.in_case = true;\n                        return;\n                    }\n                    if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {\n                        if (!this.start_of_object_property() && !// start of object property is different for numeric values with +/- prefix operators\n                        (in_array(this._flags.last_token.text, [\n                            \"+\",\n                            \"-\"\n                        ]) && this._last_last_text === \":\" && this._flags.parent.mode === MODE.ObjectLiteral)) {\n                            this.allow_wrap_or_preserved_newline(current_token);\n                        }\n                    }\n                    if (reserved_word(current_token, \"function\")) {\n                        if (in_array(this._flags.last_token.text, [\n                            \"}\",\n                            \";\"\n                        ]) || this._output.just_added_newline() && !(in_array(this._flags.last_token.text, [\n                            \"(\",\n                            \"[\",\n                            \"{\",\n                            \":\",\n                            \"=\",\n                            \",\"\n                        ]) || this._flags.last_token.type === TOKEN.OPERATOR)) {\n                            // make sure there is a nice clean space of at least one blank line\n                            // before a new function definition\n                            if (!this._output.just_added_blankline() && !current_token.comments_before) {\n                                this.print_newline();\n                                this.print_newline(true);\n                            }\n                        }\n                        if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD) {\n                            if (reserved_array(this._flags.last_token, [\n                                \"get\",\n                                \"set\",\n                                \"new\",\n                                \"export\"\n                            ]) || reserved_array(this._flags.last_token, newline_restricted_tokens)) {\n                                this._output.space_before_token = true;\n                            } else if (reserved_word(this._flags.last_token, \"default\") && this._last_last_text === \"export\") {\n                                this._output.space_before_token = true;\n                            } else if (this._flags.last_token.text === \"declare\") {\n                                // accomodates Typescript declare function formatting\n                                this._output.space_before_token = true;\n                            } else {\n                                this.print_newline();\n                            }\n                        } else if (this._flags.last_token.type === TOKEN.OPERATOR || this._flags.last_token.text === \"=\") {\n                            // foo = function\n                            this._output.space_before_token = true;\n                        } else if (!this._flags.multiline_frame && (is_expression(this._flags.mode) || is_array(this._flags.mode))) {\n                        // (function\n                        } else {\n                            this.print_newline();\n                        }\n                        this.print_token(current_token);\n                        this._flags.last_word = current_token.text;\n                        return;\n                    }\n                    var prefix = \"NONE\";\n                    if (this._flags.last_token.type === TOKEN.END_BLOCK) {\n                        if (this._previous_flags.inline_frame) {\n                            prefix = \"SPACE\";\n                        } else if (!reserved_array(current_token, [\n                            \"else\",\n                            \"catch\",\n                            \"finally\",\n                            \"from\"\n                        ])) {\n                            prefix = \"NEWLINE\";\n                        } else {\n                            if (this._options.brace_style === \"expand\" || this._options.brace_style === \"end-expand\" || this._options.brace_style === \"none\" && current_token.newlines) {\n                                prefix = \"NEWLINE\";\n                            } else {\n                                prefix = \"SPACE\";\n                                this._output.space_before_token = true;\n                            }\n                        }\n                    } else if (this._flags.last_token.type === TOKEN.SEMICOLON && this._flags.mode === MODE.BlockStatement) {\n                        // TODO: Should this be for STATEMENT as well?\n                        prefix = \"NEWLINE\";\n                    } else if (this._flags.last_token.type === TOKEN.SEMICOLON && is_expression(this._flags.mode)) {\n                        prefix = \"SPACE\";\n                    } else if (this._flags.last_token.type === TOKEN.STRING) {\n                        prefix = \"NEWLINE\";\n                    } else if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === \"*\" && (in_array(this._last_last_text, [\n                        \"function\",\n                        \"yield\"\n                    ]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, [\n                        \"{\",\n                        \",\"\n                    ]))) {\n                        prefix = \"SPACE\";\n                    } else if (this._flags.last_token.type === TOKEN.START_BLOCK) {\n                        if (this._flags.inline_frame) {\n                            prefix = \"SPACE\";\n                        } else {\n                            prefix = \"NEWLINE\";\n                        }\n                    } else if (this._flags.last_token.type === TOKEN.END_EXPR) {\n                        this._output.space_before_token = true;\n                        prefix = \"NEWLINE\";\n                    }\n                    if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== \")\") {\n                        if (this._flags.inline_frame || this._flags.last_token.text === \"else\" || this._flags.last_token.text === \"export\") {\n                            prefix = \"SPACE\";\n                        } else {\n                            prefix = \"NEWLINE\";\n                        }\n                    }\n                    if (reserved_array(current_token, [\n                        \"else\",\n                        \"catch\",\n                        \"finally\"\n                    ])) {\n                        if ((!(this._flags.last_token.type === TOKEN.END_BLOCK && this._previous_flags.mode === MODE.BlockStatement) || this._options.brace_style === \"expand\" || this._options.brace_style === \"end-expand\" || this._options.brace_style === \"none\" && current_token.newlines) && !this._flags.inline_frame) {\n                            this.print_newline();\n                        } else {\n                            this._output.trim(true);\n                            var line = this._output.current_line;\n                            // If we trimmed and there's something other than a close block before us\n                            // put a newline back in.  Handles '} // comment' scenario.\n                            if (line.last() !== \"}\") {\n                                this.print_newline();\n                            }\n                            this._output.space_before_token = true;\n                        }\n                    } else if (prefix === \"NEWLINE\") {\n                        if (reserved_array(this._flags.last_token, special_words)) {\n                            // no newline between 'return nnn'\n                            this._output.space_before_token = true;\n                        } else if (this._flags.last_token.text === \"declare\" && reserved_array(current_token, [\n                            \"var\",\n                            \"let\",\n                            \"const\"\n                        ])) {\n                            // accomodates Typescript declare formatting\n                            this._output.space_before_token = true;\n                        } else if (this._flags.last_token.type !== TOKEN.END_EXPR) {\n                            if ((this._flags.last_token.type !== TOKEN.START_EXPR || !reserved_array(current_token, [\n                                \"var\",\n                                \"let\",\n                                \"const\"\n                            ])) && this._flags.last_token.text !== \":\") {\n                                // no need to force newline on 'var': for (var x = 0...)\n                                if (reserved_word(current_token, \"if\") && reserved_word(current_token.previous, \"else\")) {\n                                    // no newline for } else if {\n                                    this._output.space_before_token = true;\n                                } else {\n                                    this.print_newline();\n                                }\n                            }\n                        } else if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== \")\") {\n                            this.print_newline();\n                        }\n                    } else if (this._flags.multiline_frame && is_array(this._flags.mode) && this._flags.last_token.text === \",\" && this._last_last_text === \"}\") {\n                        this.print_newline(); // }, in lists get a newline treatment\n                    } else if (prefix === \"SPACE\") {\n                        this._output.space_before_token = true;\n                    }\n                    if (current_token.previous && (current_token.previous.type === TOKEN.WORD || current_token.previous.type === TOKEN.RESERVED)) {\n                        this._output.space_before_token = true;\n                    }\n                    this.print_token(current_token);\n                    this._flags.last_word = current_token.text;\n                    if (current_token.type === TOKEN.RESERVED) {\n                        if (current_token.text === \"do\") {\n                            this._flags.do_block = true;\n                        } else if (current_token.text === \"if\") {\n                            this._flags.if_block = true;\n                        } else if (current_token.text === \"import\") {\n                            this._flags.import_block = true;\n                        } else if (this._flags.import_block && reserved_word(current_token, \"from\")) {\n                            this._flags.import_block = false;\n                        }\n                    }\n                };\n                Beautifier.prototype.handle_semicolon = function(current_token) {\n                    if (this.start_of_statement(current_token)) {\n                        // The conditional starts the statement if appropriate.\n                        // Semicolon can be the start (and end) of a statement\n                        this._output.space_before_token = false;\n                    } else {\n                        this.handle_whitespace_and_comments(current_token);\n                    }\n                    var next_token = this._tokens.peek();\n                    while(this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, \"else\")) && !this._flags.do_block){\n                        this.restore_mode();\n                    }\n                    // hacky but effective for the moment\n                    if (this._flags.import_block) {\n                        this._flags.import_block = false;\n                    }\n                    this.print_token(current_token);\n                };\n                Beautifier.prototype.handle_string = function(current_token) {\n                    if (current_token.text.startsWith(\"`\") && current_token.newlines === 0 && current_token.whitespace_before === \"\" && (current_token.previous.text === \")\" || this._flags.last_token.type === TOKEN.WORD)) {\n                    //Conditional for detectign backtick strings\n                    } else if (this.start_of_statement(current_token)) {\n                        // The conditional starts the statement if appropriate.\n                        // One difference - strings want at least a space before\n                        this._output.space_before_token = true;\n                    } else {\n                        this.handle_whitespace_and_comments(current_token);\n                        if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.inline_frame) {\n                            this._output.space_before_token = true;\n                        } else if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {\n                            if (!this.start_of_object_property()) {\n                                this.allow_wrap_or_preserved_newline(current_token);\n                            }\n                        } else if (current_token.text.startsWith(\"`\") && this._flags.last_token.type === TOKEN.END_EXPR && (current_token.previous.text === \"]\" || current_token.previous.text === \")\") && current_token.newlines === 0) {\n                            this._output.space_before_token = true;\n                        } else {\n                            this.print_newline();\n                        }\n                    }\n                    this.print_token(current_token);\n                };\n                Beautifier.prototype.handle_equals = function(current_token) {\n                    if (this.start_of_statement(current_token)) {\n                    // The conditional starts the statement if appropriate.\n                    } else {\n                        this.handle_whitespace_and_comments(current_token);\n                    }\n                    if (this._flags.declaration_statement) {\n                        // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done\n                        this._flags.declaration_assignment = true;\n                    }\n                    this._output.space_before_token = true;\n                    this.print_token(current_token);\n                    this._output.space_before_token = true;\n                };\n                Beautifier.prototype.handle_comma = function(current_token) {\n                    this.handle_whitespace_and_comments(current_token, true);\n                    this.print_token(current_token);\n                    this._output.space_before_token = true;\n                    if (this._flags.declaration_statement) {\n                        if (is_expression(this._flags.parent.mode)) {\n                            // do not break on comma, for(var a = 1, b = 2)\n                            this._flags.declaration_assignment = false;\n                        }\n                        if (this._flags.declaration_assignment) {\n                            this._flags.declaration_assignment = false;\n                            this.print_newline(false, true);\n                        } else if (this._options.comma_first) {\n                            // for comma-first, we want to allow a newline before the comma\n                            // to turn into a newline after the comma, which we will fixup later\n                            this.allow_wrap_or_preserved_newline(current_token);\n                        }\n                    } else if (this._flags.mode === MODE.ObjectLiteral || this._flags.mode === MODE.Statement && this._flags.parent.mode === MODE.ObjectLiteral) {\n                        if (this._flags.mode === MODE.Statement) {\n                            this.restore_mode();\n                        }\n                        if (!this._flags.inline_frame) {\n                            this.print_newline();\n                        }\n                    } else if (this._options.comma_first) {\n                        // EXPR or DO_BLOCK\n                        // for comma-first, we want to allow a newline before the comma\n                        // to turn into a newline after the comma, which we will fixup later\n                        this.allow_wrap_or_preserved_newline(current_token);\n                    }\n                };\n                Beautifier.prototype.handle_operator = function(current_token) {\n                    var isGeneratorAsterisk = current_token.text === \"*\" && (reserved_array(this._flags.last_token, [\n                        \"function\",\n                        \"yield\"\n                    ]) || in_array(this._flags.last_token.type, [\n                        TOKEN.START_BLOCK,\n                        TOKEN.COMMA,\n                        TOKEN.END_BLOCK,\n                        TOKEN.SEMICOLON\n                    ]));\n                    var isUnary = in_array(current_token.text, [\n                        \"-\",\n                        \"+\"\n                    ]) && (in_array(this._flags.last_token.type, [\n                        TOKEN.START_BLOCK,\n                        TOKEN.START_EXPR,\n                        TOKEN.EQUALS,\n                        TOKEN.OPERATOR\n                    ]) || in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === \",\");\n                    if (this.start_of_statement(current_token)) {\n                    // The conditional starts the statement if appropriate.\n                    } else {\n                        var preserve_statement_flags = !isGeneratorAsterisk;\n                        this.handle_whitespace_and_comments(current_token, preserve_statement_flags);\n                    }\n                    // hack for actionscript's import .*;\n                    if (current_token.text === \"*\" && this._flags.last_token.type === TOKEN.DOT) {\n                        this.print_token(current_token);\n                        return;\n                    }\n                    if (current_token.text === \"::\") {\n                        // no spaces around exotic namespacing syntax operator\n                        this.print_token(current_token);\n                        return;\n                    }\n                    if (in_array(current_token.text, [\n                        \"-\",\n                        \"+\"\n                    ]) && this.start_of_object_property()) {\n                        // numeric value with +/- symbol in front as a property\n                        this.print_token(current_token);\n                        return;\n                    }\n                    // Allow line wrapping between operators when operator_position is\n                    //   set to before or preserve\n                    if (this._flags.last_token.type === TOKEN.OPERATOR && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {\n                        this.allow_wrap_or_preserved_newline(current_token);\n                    }\n                    if (current_token.text === \":\" && this._flags.in_case) {\n                        this.print_token(current_token);\n                        this._flags.in_case = false;\n                        this._flags.case_body = true;\n                        if (this._tokens.peek().type !== TOKEN.START_BLOCK) {\n                            this.indent();\n                            this.print_newline();\n                            this._flags.case_block = false;\n                        } else {\n                            this._flags.case_block = true;\n                            this._output.space_before_token = true;\n                        }\n                        return;\n                    }\n                    var space_before = true;\n                    var space_after = true;\n                    var in_ternary = false;\n                    if (current_token.text === \":\") {\n                        if (this._flags.ternary_depth === 0) {\n                            // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.\n                            space_before = false;\n                        } else {\n                            this._flags.ternary_depth -= 1;\n                            in_ternary = true;\n                        }\n                    } else if (current_token.text === \"?\") {\n                        this._flags.ternary_depth += 1;\n                    }\n                    // let's handle the operator_position option prior to any conflicting logic\n                    if (!isUnary && !isGeneratorAsterisk && this._options.preserve_newlines && in_array(current_token.text, positionable_operators)) {\n                        var isColon = current_token.text === \":\";\n                        var isTernaryColon = isColon && in_ternary;\n                        var isOtherColon = isColon && !in_ternary;\n                        switch(this._options.operator_position){\n                            case OPERATOR_POSITION.before_newline:\n                                // if the current token is : and it's not a ternary statement then we set space_before to false\n                                this._output.space_before_token = !isOtherColon;\n                                this.print_token(current_token);\n                                if (!isColon || isTernaryColon) {\n                                    this.allow_wrap_or_preserved_newline(current_token);\n                                }\n                                this._output.space_before_token = true;\n                                return;\n                            case OPERATOR_POSITION.after_newline:\n                                // if the current token is anything but colon, or (via deduction) it's a colon and in a ternary statement,\n                                //   then print a newline.\n                                this._output.space_before_token = true;\n                                if (!isColon || isTernaryColon) {\n                                    if (this._tokens.peek().newlines) {\n                                        this.print_newline(false, true);\n                                    } else {\n                                        this.allow_wrap_or_preserved_newline(current_token);\n                                    }\n                                } else {\n                                    this._output.space_before_token = false;\n                                }\n                                this.print_token(current_token);\n                                this._output.space_before_token = true;\n                                return;\n                            case OPERATOR_POSITION.preserve_newline:\n                                if (!isOtherColon) {\n                                    this.allow_wrap_or_preserved_newline(current_token);\n                                }\n                                // if we just added a newline, or the current token is : and it's not a ternary statement,\n                                //   then we set space_before to false\n                                space_before = !(this._output.just_added_newline() || isOtherColon);\n                                this._output.space_before_token = space_before;\n                                this.print_token(current_token);\n                                this._output.space_before_token = true;\n                                return;\n                        }\n                    }\n                    if (isGeneratorAsterisk) {\n                        this.allow_wrap_or_preserved_newline(current_token);\n                        space_before = false;\n                        var next_token = this._tokens.peek();\n                        space_after = next_token && in_array(next_token.type, [\n                            TOKEN.WORD,\n                            TOKEN.RESERVED\n                        ]);\n                    } else if (current_token.text === \"...\") {\n                        this.allow_wrap_or_preserved_newline(current_token);\n                        space_before = this._flags.last_token.type === TOKEN.START_BLOCK;\n                        space_after = false;\n                    } else if (in_array(current_token.text, [\n                        \"--\",\n                        \"++\",\n                        \"!\",\n                        \"~\"\n                    ]) || isUnary) {\n                        // unary operators (and binary +/- pretending to be unary) special cases\n                        if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR) {\n                            this.allow_wrap_or_preserved_newline(current_token);\n                        }\n                        space_before = false;\n                        space_after = false;\n                        // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1\n                        // if there is a newline between -- or ++ and anything else we should preserve it.\n                        if (current_token.newlines && (current_token.text === \"--\" || current_token.text === \"++\" || current_token.text === \"~\")) {\n                            var new_line_needed = reserved_array(this._flags.last_token, special_words) && current_token.newlines;\n                            if (new_line_needed && (this._previous_flags.if_block || this._previous_flags.else_block)) {\n                                this.restore_mode();\n                            }\n                            this.print_newline(new_line_needed, true);\n                        }\n                        if (this._flags.last_token.text === \";\" && is_expression(this._flags.mode)) {\n                            // for (;; ++i)\n                            //        ^^^\n                            space_before = true;\n                        }\n                        if (this._flags.last_token.type === TOKEN.RESERVED) {\n                            space_before = true;\n                        } else if (this._flags.last_token.type === TOKEN.END_EXPR) {\n                            space_before = !(this._flags.last_token.text === \"]\" && (current_token.text === \"--\" || current_token.text === \"++\"));\n                        } else if (this._flags.last_token.type === TOKEN.OPERATOR) {\n                            // a++ + ++b;\n                            // a - -b\n                            space_before = in_array(current_token.text, [\n                                \"--\",\n                                \"-\",\n                                \"++\",\n                                \"+\"\n                            ]) && in_array(this._flags.last_token.text, [\n                                \"--\",\n                                \"-\",\n                                \"++\",\n                                \"+\"\n                            ]);\n                            // + and - are not unary when preceeded by -- or ++ operator\n                            // a-- + b\n                            // a * +b\n                            // a - -b\n                            if (in_array(current_token.text, [\n                                \"+\",\n                                \"-\"\n                            ]) && in_array(this._flags.last_token.text, [\n                                \"--\",\n                                \"++\"\n                            ])) {\n                                space_after = true;\n                            }\n                        }\n                        if ((this._flags.mode === MODE.BlockStatement && !this._flags.inline_frame || this._flags.mode === MODE.Statement) && (this._flags.last_token.text === \"{\" || this._flags.last_token.text === \";\")) {\n                            // { foo; --i }\n                            // foo(); --bar;\n                            this.print_newline();\n                        }\n                    }\n                    this._output.space_before_token = this._output.space_before_token || space_before;\n                    this.print_token(current_token);\n                    this._output.space_before_token = space_after;\n                };\n                Beautifier.prototype.handle_block_comment = function(current_token, preserve_statement_flags) {\n                    if (this._output.raw) {\n                        this._output.add_raw_token(current_token);\n                        if (current_token.directives && current_token.directives.preserve === \"end\") {\n                            // If we're testing the raw output behavior, do not allow a directive to turn it off.\n                            this._output.raw = this._options.test_output_raw;\n                        }\n                        return;\n                    }\n                    if (current_token.directives) {\n                        this.print_newline(false, preserve_statement_flags);\n                        this.print_token(current_token);\n                        if (current_token.directives.preserve === \"start\") {\n                            this._output.raw = true;\n                        }\n                        this.print_newline(false, true);\n                        return;\n                    }\n                    // inline block\n                    if (!acorn.newline.test(current_token.text) && !current_token.newlines) {\n                        this._output.space_before_token = true;\n                        this.print_token(current_token);\n                        this._output.space_before_token = true;\n                        return;\n                    } else {\n                        this.print_block_commment(current_token, preserve_statement_flags);\n                    }\n                };\n                Beautifier.prototype.print_block_commment = function(current_token, preserve_statement_flags) {\n                    var lines = split_linebreaks(current_token.text);\n                    var j; // iterator for this case\n                    var javadoc = false;\n                    var starless = false;\n                    var lastIndent = current_token.whitespace_before;\n                    var lastIndentLength = lastIndent.length;\n                    // block comment starts with a new line\n                    this.print_newline(false, preserve_statement_flags);\n                    // first line always indented\n                    this.print_token_line_indentation(current_token);\n                    this._output.add_token(lines[0]);\n                    this.print_newline(false, preserve_statement_flags);\n                    if (lines.length > 1) {\n                        lines = lines.slice(1);\n                        javadoc = all_lines_start_with(lines, \"*\");\n                        starless = each_line_matches_indent(lines, lastIndent);\n                        if (javadoc) {\n                            this._flags.alignment = 1;\n                        }\n                        for(j = 0; j < lines.length; j++){\n                            if (javadoc) {\n                                // javadoc: reformat and re-indent\n                                this.print_token_line_indentation(current_token);\n                                this._output.add_token(ltrim(lines[j]));\n                            } else if (starless && lines[j]) {\n                                // starless: re-indent non-empty content, avoiding trim\n                                this.print_token_line_indentation(current_token);\n                                this._output.add_token(lines[j].substring(lastIndentLength));\n                            } else {\n                                // normal comments output raw\n                                this._output.current_line.set_indent(-1);\n                                this._output.add_token(lines[j]);\n                            }\n                            // for comments on their own line or  more than one line, make sure there's a new line after\n                            this.print_newline(false, preserve_statement_flags);\n                        }\n                        this._flags.alignment = 0;\n                    }\n                };\n                Beautifier.prototype.handle_comment = function(current_token, preserve_statement_flags) {\n                    if (current_token.newlines) {\n                        this.print_newline(false, preserve_statement_flags);\n                    } else {\n                        this._output.trim(true);\n                    }\n                    this._output.space_before_token = true;\n                    this.print_token(current_token);\n                    this.print_newline(false, preserve_statement_flags);\n                };\n                Beautifier.prototype.handle_dot = function(current_token) {\n                    if (this.start_of_statement(current_token)) {\n                    // The conditional starts the statement if appropriate.\n                    } else {\n                        this.handle_whitespace_and_comments(current_token, true);\n                    }\n                    if (this._flags.last_token.text.match(\"^[0-9]+$\")) {\n                        this._output.space_before_token = true;\n                    }\n                    if (reserved_array(this._flags.last_token, special_words)) {\n                        this._output.space_before_token = false;\n                    } else {\n                        // allow preserved newlines before dots in general\n                        // force newlines on dots after close paren when break_chained - for bar().baz()\n                        this.allow_wrap_or_preserved_newline(current_token, this._flags.last_token.text === \")\" && this._options.break_chained_methods);\n                    }\n                    // Only unindent chained method dot if this dot starts a new line.\n                    // Otherwise the automatic extra indentation removal will handle the over indent\n                    if (this._options.unindent_chained_methods && this._output.just_added_newline()) {\n                        this.deindent();\n                    }\n                    this.print_token(current_token);\n                };\n                Beautifier.prototype.handle_unknown = function(current_token, preserve_statement_flags) {\n                    this.print_token(current_token);\n                    if (current_token.text[current_token.text.length - 1] === \"\\n\") {\n                        this.print_newline(false, preserve_statement_flags);\n                    }\n                };\n                Beautifier.prototype.handle_eof = function(current_token) {\n                    // Unwind any open statements\n                    while(this._flags.mode === MODE.Statement){\n                        this.restore_mode();\n                    }\n                    this.handle_whitespace_and_comments(current_token);\n                };\n                module.exports.Beautifier = Beautifier;\n            /***/ },\n            /* 2 */ /***/ function(module) {\n                /*jshint node:true */ /*\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function OutputLine(parent) {\n                    this.__parent = parent;\n                    this.__character_count = 0;\n                    // use indent_count as a marker for this.__lines that have preserved indentation\n                    this.__indent_count = -1;\n                    this.__alignment_count = 0;\n                    this.__wrap_point_index = 0;\n                    this.__wrap_point_character_count = 0;\n                    this.__wrap_point_indent_count = -1;\n                    this.__wrap_point_alignment_count = 0;\n                    this.__items = [];\n                }\n                OutputLine.prototype.clone_empty = function() {\n                    var line = new OutputLine(this.__parent);\n                    line.set_indent(this.__indent_count, this.__alignment_count);\n                    return line;\n                };\n                OutputLine.prototype.item = function(index) {\n                    if (index < 0) {\n                        return this.__items[this.__items.length + index];\n                    } else {\n                        return this.__items[index];\n                    }\n                };\n                OutputLine.prototype.has_match = function(pattern) {\n                    for(var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--){\n                        if (this.__items[lastCheckedOutput].match(pattern)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n                OutputLine.prototype.set_indent = function(indent, alignment) {\n                    if (this.is_empty()) {\n                        this.__indent_count = indent || 0;\n                        this.__alignment_count = alignment || 0;\n                        this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);\n                    }\n                };\n                OutputLine.prototype._set_wrap_point = function() {\n                    if (this.__parent.wrap_line_length) {\n                        this.__wrap_point_index = this.__items.length;\n                        this.__wrap_point_character_count = this.__character_count;\n                        this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;\n                        this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;\n                    }\n                };\n                OutputLine.prototype._should_wrap = function() {\n                    return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;\n                };\n                OutputLine.prototype._allow_wrap = function() {\n                    if (this._should_wrap()) {\n                        this.__parent.add_new_line();\n                        var next = this.__parent.current_line;\n                        next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);\n                        next.__items = this.__items.slice(this.__wrap_point_index);\n                        this.__items = this.__items.slice(0, this.__wrap_point_index);\n                        next.__character_count += this.__character_count - this.__wrap_point_character_count;\n                        this.__character_count = this.__wrap_point_character_count;\n                        if (next.__items[0] === \" \") {\n                            next.__items.splice(0, 1);\n                            next.__character_count -= 1;\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                OutputLine.prototype.is_empty = function() {\n                    return this.__items.length === 0;\n                };\n                OutputLine.prototype.last = function() {\n                    if (!this.is_empty()) {\n                        return this.__items[this.__items.length - 1];\n                    } else {\n                        return null;\n                    }\n                };\n                OutputLine.prototype.push = function(item) {\n                    this.__items.push(item);\n                    var last_newline_index = item.lastIndexOf(\"\\n\");\n                    if (last_newline_index !== -1) {\n                        this.__character_count = item.length - last_newline_index;\n                    } else {\n                        this.__character_count += item.length;\n                    }\n                };\n                OutputLine.prototype.pop = function() {\n                    var item = null;\n                    if (!this.is_empty()) {\n                        item = this.__items.pop();\n                        this.__character_count -= item.length;\n                    }\n                    return item;\n                };\n                OutputLine.prototype._remove_indent = function() {\n                    if (this.__indent_count > 0) {\n                        this.__indent_count -= 1;\n                        this.__character_count -= this.__parent.indent_size;\n                    }\n                };\n                OutputLine.prototype._remove_wrap_indent = function() {\n                    if (this.__wrap_point_indent_count > 0) {\n                        this.__wrap_point_indent_count -= 1;\n                    }\n                };\n                OutputLine.prototype.trim = function() {\n                    while(this.last() === \" \"){\n                        this.__items.pop();\n                        this.__character_count -= 1;\n                    }\n                };\n                OutputLine.prototype.toString = function() {\n                    var result = \"\";\n                    if (this.is_empty()) {\n                        if (this.__parent.indent_empty_lines) {\n                            result = this.__parent.get_indent_string(this.__indent_count);\n                        }\n                    } else {\n                        result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);\n                        result += this.__items.join(\"\");\n                    }\n                    return result;\n                };\n                function IndentStringCache(options, baseIndentString) {\n                    this.__cache = [\n                        \"\"\n                    ];\n                    this.__indent_size = options.indent_size;\n                    this.__indent_string = options.indent_char;\n                    if (!options.indent_with_tabs) {\n                        this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);\n                    }\n                    // Set to null to continue support for auto detection of base indent\n                    baseIndentString = baseIndentString || \"\";\n                    if (options.indent_level > 0) {\n                        baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);\n                    }\n                    this.__base_string = baseIndentString;\n                    this.__base_string_length = baseIndentString.length;\n                }\n                IndentStringCache.prototype.get_indent_size = function(indent, column) {\n                    var result = this.__base_string_length;\n                    column = column || 0;\n                    if (indent < 0) {\n                        result = 0;\n                    }\n                    result += indent * this.__indent_size;\n                    result += column;\n                    return result;\n                };\n                IndentStringCache.prototype.get_indent_string = function(indent_level, column) {\n                    var result = this.__base_string;\n                    column = column || 0;\n                    if (indent_level < 0) {\n                        indent_level = 0;\n                        result = \"\";\n                    }\n                    column += indent_level * this.__indent_size;\n                    this.__ensure_cache(column);\n                    result += this.__cache[column];\n                    return result;\n                };\n                IndentStringCache.prototype.__ensure_cache = function(column) {\n                    while(column >= this.__cache.length){\n                        this.__add_column();\n                    }\n                };\n                IndentStringCache.prototype.__add_column = function() {\n                    var column = this.__cache.length;\n                    var indent = 0;\n                    var result = \"\";\n                    if (this.__indent_size && column >= this.__indent_size) {\n                        indent = Math.floor(column / this.__indent_size);\n                        column -= indent * this.__indent_size;\n                        result = new Array(indent + 1).join(this.__indent_string);\n                    }\n                    if (column) {\n                        result += new Array(column + 1).join(\" \");\n                    }\n                    this.__cache.push(result);\n                };\n                function Output(options, baseIndentString) {\n                    this.__indent_cache = new IndentStringCache(options, baseIndentString);\n                    this.raw = false;\n                    this._end_with_newline = options.end_with_newline;\n                    this.indent_size = options.indent_size;\n                    this.wrap_line_length = options.wrap_line_length;\n                    this.indent_empty_lines = options.indent_empty_lines;\n                    this.__lines = [];\n                    this.previous_line = null;\n                    this.current_line = null;\n                    this.next_line = new OutputLine(this);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = false;\n                    // initialize\n                    this.__add_outputline();\n                }\n                Output.prototype.__add_outputline = function() {\n                    this.previous_line = this.current_line;\n                    this.current_line = this.next_line.clone_empty();\n                    this.__lines.push(this.current_line);\n                };\n                Output.prototype.get_line_number = function() {\n                    return this.__lines.length;\n                };\n                Output.prototype.get_indent_string = function(indent, column) {\n                    return this.__indent_cache.get_indent_string(indent, column);\n                };\n                Output.prototype.get_indent_size = function(indent, column) {\n                    return this.__indent_cache.get_indent_size(indent, column);\n                };\n                Output.prototype.is_empty = function() {\n                    return !this.previous_line && this.current_line.is_empty();\n                };\n                Output.prototype.add_new_line = function(force_newline) {\n                    // never newline at the start of file\n                    // otherwise, newline only if we didn't just add one or we're forced\n                    if (this.is_empty() || !force_newline && this.just_added_newline()) {\n                        return false;\n                    }\n                    // if raw output is enabled, don't print additional newlines,\n                    // but still return True as though you had\n                    if (!this.raw) {\n                        this.__add_outputline();\n                    }\n                    return true;\n                };\n                Output.prototype.get_code = function(eol) {\n                    this.trim(true);\n                    // handle some edge cases where the last tokens\n                    // has text that ends with newline(s)\n                    var last_item = this.current_line.pop();\n                    if (last_item) {\n                        if (last_item[last_item.length - 1] === \"\\n\") {\n                            last_item = last_item.replace(/\\n+$/g, \"\");\n                        }\n                        this.current_line.push(last_item);\n                    }\n                    if (this._end_with_newline) {\n                        this.__add_outputline();\n                    }\n                    var sweet_code = this.__lines.join(\"\\n\");\n                    if (eol !== \"\\n\") {\n                        sweet_code = sweet_code.replace(/[\\n]/g, eol);\n                    }\n                    return sweet_code;\n                };\n                Output.prototype.set_wrap_point = function() {\n                    this.current_line._set_wrap_point();\n                };\n                Output.prototype.set_indent = function(indent, alignment) {\n                    indent = indent || 0;\n                    alignment = alignment || 0;\n                    // Next line stores alignment values\n                    this.next_line.set_indent(indent, alignment);\n                    // Never indent your first output indent at the start of the file\n                    if (this.__lines.length > 1) {\n                        this.current_line.set_indent(indent, alignment);\n                        return true;\n                    }\n                    this.current_line.set_indent();\n                    return false;\n                };\n                Output.prototype.add_raw_token = function(token) {\n                    for(var x = 0; x < token.newlines; x++){\n                        this.__add_outputline();\n                    }\n                    this.current_line.set_indent(-1);\n                    this.current_line.push(token.whitespace_before);\n                    this.current_line.push(token.text);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = false;\n                };\n                Output.prototype.add_token = function(printable_token) {\n                    this.__add_space_before_token();\n                    this.current_line.push(printable_token);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = this.current_line._allow_wrap();\n                };\n                Output.prototype.__add_space_before_token = function() {\n                    if (this.space_before_token && !this.just_added_newline()) {\n                        if (!this.non_breaking_space) {\n                            this.set_wrap_point();\n                        }\n                        this.current_line.push(\" \");\n                    }\n                };\n                Output.prototype.remove_indent = function(index) {\n                    var output_length = this.__lines.length;\n                    while(index < output_length){\n                        this.__lines[index]._remove_indent();\n                        index++;\n                    }\n                    this.current_line._remove_wrap_indent();\n                };\n                Output.prototype.trim = function(eat_newlines) {\n                    eat_newlines = eat_newlines === undefined ? false : eat_newlines;\n                    this.current_line.trim();\n                    while(eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()){\n                        this.__lines.pop();\n                        this.current_line = this.__lines[this.__lines.length - 1];\n                        this.current_line.trim();\n                    }\n                    this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;\n                };\n                Output.prototype.just_added_newline = function() {\n                    return this.current_line.is_empty();\n                };\n                Output.prototype.just_added_blankline = function() {\n                    return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();\n                };\n                Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {\n                    var index = this.__lines.length - 2;\n                    while(index >= 0){\n                        var potentialEmptyLine = this.__lines[index];\n                        if (potentialEmptyLine.is_empty()) {\n                            break;\n                        } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {\n                            this.__lines.splice(index + 1, 0, new OutputLine(this));\n                            this.previous_line = this.__lines[this.__lines.length - 2];\n                            break;\n                        }\n                        index--;\n                    }\n                };\n                module.exports.Output = Output;\n            /***/ },\n            /* 3 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Token(type, text, newlines, whitespace_before) {\n                    this.type = type;\n                    this.text = text;\n                    // comments_before are\n                    // comments that have a new line before them\n                    // and may or may not have a newline after\n                    // this is a set of comments before\n                    this.comments_before = null; /* inline comment*/ \n                    // this.comments_after =  new TokenStream(); // no new line before and newline after\n                    this.newlines = newlines || 0;\n                    this.whitespace_before = whitespace_before || \"\";\n                    this.parent = null;\n                    this.next = null;\n                    this.previous = null;\n                    this.opened = null;\n                    this.closed = null;\n                    this.directives = null;\n                }\n                module.exports.Token = Token;\n            /***/ },\n            /* 4 */ /***/ function(__unused_webpack_module, exports1) {\n                /* jshint node: true, curly: false */ // Parts of this section of code is taken from acorn.\n                //\n                // Acorn was written by Marijn Haverbeke and released under an MIT\n                // license. The Unicode regexps (for identifiers and whitespace) were\n                // taken from [Esprima](http://esprima.org) by Ariya Hidayat.\n                //\n                // Git repositories for Acorn are available at\n                //\n                //     http://marijnhaverbeke.nl/git/acorn\n                //     https://github.com/marijnh/acorn.git\n                // ## Character categories\n                // acorn used char codes to squeeze the last bit of performance out\n                // Beautifier is okay without that, so we're using regex\n                // permit # (23), $ (36), and @ (64). @ is used in ES7 decorators.\n                // 65 through 91 are uppercase letters.\n                // permit _ (95).\n                // 97 through 123 are lowercase letters.\n                var baseASCIIidentifierStartChars = \"\\\\x23\\\\x24\\\\x40\\\\x41-\\\\x5a\\\\x5f\\\\x61-\\\\x7a\";\n                // inside an identifier @ is not allowed but 0-9 are.\n                var baseASCIIidentifierChars = \"\\\\x24\\\\x30-\\\\x39\\\\x41-\\\\x5a\\\\x5f\\\\x61-\\\\x7a\";\n                // Big ugly regular expressions that match characters in the\n                // whitespace, identifier, and identifier-start categories. These\n                // are only applied when a character is found to actually have a\n                // code point above 128.\n                var nonASCIIidentifierStartChars = \"\\\\xaa\\\\xb5\\\\xba\\\\xc0-\\\\xd6\\\\xd8-\\\\xf6\\\\xf8-\\\\u02c1\\\\u02c6-\\\\u02d1\\\\u02e0-\\\\u02e4\\\\u02ec\\\\u02ee\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037a-\\\\u037d\\\\u0386\\\\u0388-\\\\u038a\\\\u038c\\\\u038e-\\\\u03a1\\\\u03a3-\\\\u03f5\\\\u03f7-\\\\u0481\\\\u048a-\\\\u0527\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05d0-\\\\u05ea\\\\u05f0-\\\\u05f2\\\\u0620-\\\\u064a\\\\u066e\\\\u066f\\\\u0671-\\\\u06d3\\\\u06d5\\\\u06e5\\\\u06e6\\\\u06ee\\\\u06ef\\\\u06fa-\\\\u06fc\\\\u06ff\\\\u0710\\\\u0712-\\\\u072f\\\\u074d-\\\\u07a5\\\\u07b1\\\\u07ca-\\\\u07ea\\\\u07f4\\\\u07f5\\\\u07fa\\\\u0800-\\\\u0815\\\\u081a\\\\u0824\\\\u0828\\\\u0840-\\\\u0858\\\\u08a0\\\\u08a2-\\\\u08ac\\\\u0904-\\\\u0939\\\\u093d\\\\u0950\\\\u0958-\\\\u0961\\\\u0971-\\\\u0977\\\\u0979-\\\\u097f\\\\u0985-\\\\u098c\\\\u098f\\\\u0990\\\\u0993-\\\\u09a8\\\\u09aa-\\\\u09b0\\\\u09b2\\\\u09b6-\\\\u09b9\\\\u09bd\\\\u09ce\\\\u09dc\\\\u09dd\\\\u09df-\\\\u09e1\\\\u09f0\\\\u09f1\\\\u0a05-\\\\u0a0a\\\\u0a0f\\\\u0a10\\\\u0a13-\\\\u0a28\\\\u0a2a-\\\\u0a30\\\\u0a32\\\\u0a33\\\\u0a35\\\\u0a36\\\\u0a38\\\\u0a39\\\\u0a59-\\\\u0a5c\\\\u0a5e\\\\u0a72-\\\\u0a74\\\\u0a85-\\\\u0a8d\\\\u0a8f-\\\\u0a91\\\\u0a93-\\\\u0aa8\\\\u0aaa-\\\\u0ab0\\\\u0ab2\\\\u0ab3\\\\u0ab5-\\\\u0ab9\\\\u0abd\\\\u0ad0\\\\u0ae0\\\\u0ae1\\\\u0b05-\\\\u0b0c\\\\u0b0f\\\\u0b10\\\\u0b13-\\\\u0b28\\\\u0b2a-\\\\u0b30\\\\u0b32\\\\u0b33\\\\u0b35-\\\\u0b39\\\\u0b3d\\\\u0b5c\\\\u0b5d\\\\u0b5f-\\\\u0b61\\\\u0b71\\\\u0b83\\\\u0b85-\\\\u0b8a\\\\u0b8e-\\\\u0b90\\\\u0b92-\\\\u0b95\\\\u0b99\\\\u0b9a\\\\u0b9c\\\\u0b9e\\\\u0b9f\\\\u0ba3\\\\u0ba4\\\\u0ba8-\\\\u0baa\\\\u0bae-\\\\u0bb9\\\\u0bd0\\\\u0c05-\\\\u0c0c\\\\u0c0e-\\\\u0c10\\\\u0c12-\\\\u0c28\\\\u0c2a-\\\\u0c33\\\\u0c35-\\\\u0c39\\\\u0c3d\\\\u0c58\\\\u0c59\\\\u0c60\\\\u0c61\\\\u0c85-\\\\u0c8c\\\\u0c8e-\\\\u0c90\\\\u0c92-\\\\u0ca8\\\\u0caa-\\\\u0cb3\\\\u0cb5-\\\\u0cb9\\\\u0cbd\\\\u0cde\\\\u0ce0\\\\u0ce1\\\\u0cf1\\\\u0cf2\\\\u0d05-\\\\u0d0c\\\\u0d0e-\\\\u0d10\\\\u0d12-\\\\u0d3a\\\\u0d3d\\\\u0d4e\\\\u0d60\\\\u0d61\\\\u0d7a-\\\\u0d7f\\\\u0d85-\\\\u0d96\\\\u0d9a-\\\\u0db1\\\\u0db3-\\\\u0dbb\\\\u0dbd\\\\u0dc0-\\\\u0dc6\\\\u0e01-\\\\u0e30\\\\u0e32\\\\u0e33\\\\u0e40-\\\\u0e46\\\\u0e81\\\\u0e82\\\\u0e84\\\\u0e87\\\\u0e88\\\\u0e8a\\\\u0e8d\\\\u0e94-\\\\u0e97\\\\u0e99-\\\\u0e9f\\\\u0ea1-\\\\u0ea3\\\\u0ea5\\\\u0ea7\\\\u0eaa\\\\u0eab\\\\u0ead-\\\\u0eb0\\\\u0eb2\\\\u0eb3\\\\u0ebd\\\\u0ec0-\\\\u0ec4\\\\u0ec6\\\\u0edc-\\\\u0edf\\\\u0f00\\\\u0f40-\\\\u0f47\\\\u0f49-\\\\u0f6c\\\\u0f88-\\\\u0f8c\\\\u1000-\\\\u102a\\\\u103f\\\\u1050-\\\\u1055\\\\u105a-\\\\u105d\\\\u1061\\\\u1065\\\\u1066\\\\u106e-\\\\u1070\\\\u1075-\\\\u1081\\\\u108e\\\\u10a0-\\\\u10c5\\\\u10c7\\\\u10cd\\\\u10d0-\\\\u10fa\\\\u10fc-\\\\u1248\\\\u124a-\\\\u124d\\\\u1250-\\\\u1256\\\\u1258\\\\u125a-\\\\u125d\\\\u1260-\\\\u1288\\\\u128a-\\\\u128d\\\\u1290-\\\\u12b0\\\\u12b2-\\\\u12b5\\\\u12b8-\\\\u12be\\\\u12c0\\\\u12c2-\\\\u12c5\\\\u12c8-\\\\u12d6\\\\u12d8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135a\\\\u1380-\\\\u138f\\\\u13a0-\\\\u13f4\\\\u1401-\\\\u166c\\\\u166f-\\\\u167f\\\\u1681-\\\\u169a\\\\u16a0-\\\\u16ea\\\\u16ee-\\\\u16f0\\\\u1700-\\\\u170c\\\\u170e-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176c\\\\u176e-\\\\u1770\\\\u1780-\\\\u17b3\\\\u17d7\\\\u17dc\\\\u1820-\\\\u1877\\\\u1880-\\\\u18a8\\\\u18aa\\\\u18b0-\\\\u18f5\\\\u1900-\\\\u191c\\\\u1950-\\\\u196d\\\\u1970-\\\\u1974\\\\u1980-\\\\u19ab\\\\u19c1-\\\\u19c7\\\\u1a00-\\\\u1a16\\\\u1a20-\\\\u1a54\\\\u1aa7\\\\u1b05-\\\\u1b33\\\\u1b45-\\\\u1b4b\\\\u1b83-\\\\u1ba0\\\\u1bae\\\\u1baf\\\\u1bba-\\\\u1be5\\\\u1c00-\\\\u1c23\\\\u1c4d-\\\\u1c4f\\\\u1c5a-\\\\u1c7d\\\\u1ce9-\\\\u1cec\\\\u1cee-\\\\u1cf1\\\\u1cf5\\\\u1cf6\\\\u1d00-\\\\u1dbf\\\\u1e00-\\\\u1f15\\\\u1f18-\\\\u1f1d\\\\u1f20-\\\\u1f45\\\\u1f48-\\\\u1f4d\\\\u1f50-\\\\u1f57\\\\u1f59\\\\u1f5b\\\\u1f5d\\\\u1f5f-\\\\u1f7d\\\\u1f80-\\\\u1fb4\\\\u1fb6-\\\\u1fbc\\\\u1fbe\\\\u1fc2-\\\\u1fc4\\\\u1fc6-\\\\u1fcc\\\\u1fd0-\\\\u1fd3\\\\u1fd6-\\\\u1fdb\\\\u1fe0-\\\\u1fec\\\\u1ff2-\\\\u1ff4\\\\u1ff6-\\\\u1ffc\\\\u2071\\\\u207f\\\\u2090-\\\\u209c\\\\u2102\\\\u2107\\\\u210a-\\\\u2113\\\\u2115\\\\u2119-\\\\u211d\\\\u2124\\\\u2126\\\\u2128\\\\u212a-\\\\u212d\\\\u212f-\\\\u2139\\\\u213c-\\\\u213f\\\\u2145-\\\\u2149\\\\u214e\\\\u2160-\\\\u2188\\\\u2c00-\\\\u2c2e\\\\u2c30-\\\\u2c5e\\\\u2c60-\\\\u2ce4\\\\u2ceb-\\\\u2cee\\\\u2cf2\\\\u2cf3\\\\u2d00-\\\\u2d25\\\\u2d27\\\\u2d2d\\\\u2d30-\\\\u2d67\\\\u2d6f\\\\u2d80-\\\\u2d96\\\\u2da0-\\\\u2da6\\\\u2da8-\\\\u2dae\\\\u2db0-\\\\u2db6\\\\u2db8-\\\\u2dbe\\\\u2dc0-\\\\u2dc6\\\\u2dc8-\\\\u2dce\\\\u2dd0-\\\\u2dd6\\\\u2dd8-\\\\u2dde\\\\u2e2f\\\\u3005-\\\\u3007\\\\u3021-\\\\u3029\\\\u3031-\\\\u3035\\\\u3038-\\\\u303c\\\\u3041-\\\\u3096\\\\u309d-\\\\u309f\\\\u30a1-\\\\u30fa\\\\u30fc-\\\\u30ff\\\\u3105-\\\\u312d\\\\u3131-\\\\u318e\\\\u31a0-\\\\u31ba\\\\u31f0-\\\\u31ff\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fcc\\\\ua000-\\\\ua48c\\\\ua4d0-\\\\ua4fd\\\\ua500-\\\\ua60c\\\\ua610-\\\\ua61f\\\\ua62a\\\\ua62b\\\\ua640-\\\\ua66e\\\\ua67f-\\\\ua697\\\\ua6a0-\\\\ua6ef\\\\ua717-\\\\ua71f\\\\ua722-\\\\ua788\\\\ua78b-\\\\ua78e\\\\ua790-\\\\ua793\\\\ua7a0-\\\\ua7aa\\\\ua7f8-\\\\ua801\\\\ua803-\\\\ua805\\\\ua807-\\\\ua80a\\\\ua80c-\\\\ua822\\\\ua840-\\\\ua873\\\\ua882-\\\\ua8b3\\\\ua8f2-\\\\ua8f7\\\\ua8fb\\\\ua90a-\\\\ua925\\\\ua930-\\\\ua946\\\\ua960-\\\\ua97c\\\\ua984-\\\\ua9b2\\\\ua9cf\\\\uaa00-\\\\uaa28\\\\uaa40-\\\\uaa42\\\\uaa44-\\\\uaa4b\\\\uaa60-\\\\uaa76\\\\uaa7a\\\\uaa80-\\\\uaaaf\\\\uaab1\\\\uaab5\\\\uaab6\\\\uaab9-\\\\uaabd\\\\uaac0\\\\uaac2\\\\uaadb-\\\\uaadd\\\\uaae0-\\\\uaaea\\\\uaaf2-\\\\uaaf4\\\\uab01-\\\\uab06\\\\uab09-\\\\uab0e\\\\uab11-\\\\uab16\\\\uab20-\\\\uab26\\\\uab28-\\\\uab2e\\\\uabc0-\\\\uabe2\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\uf900-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufb00-\\\\ufb06\\\\ufb13-\\\\ufb17\\\\ufb1d\\\\ufb1f-\\\\ufb28\\\\ufb2a-\\\\ufb36\\\\ufb38-\\\\ufb3c\\\\ufb3e\\\\ufb40\\\\ufb41\\\\ufb43\\\\ufb44\\\\ufb46-\\\\ufbb1\\\\ufbd3-\\\\ufd3d\\\\ufd50-\\\\ufd8f\\\\ufd92-\\\\ufdc7\\\\ufdf0-\\\\ufdfb\\\\ufe70-\\\\ufe74\\\\ufe76-\\\\ufefc\\\\uff21-\\\\uff3a\\\\uff41-\\\\uff5a\\\\uff66-\\\\uffbe\\\\uffc2-\\\\uffc7\\\\uffca-\\\\uffcf\\\\uffd2-\\\\uffd7\\\\uffda-\\\\uffdc\";\n                var nonASCIIidentifierChars = \"\\\\u0300-\\\\u036f\\\\u0483-\\\\u0487\\\\u0591-\\\\u05bd\\\\u05bf\\\\u05c1\\\\u05c2\\\\u05c4\\\\u05c5\\\\u05c7\\\\u0610-\\\\u061a\\\\u0620-\\\\u0649\\\\u0672-\\\\u06d3\\\\u06e7-\\\\u06e8\\\\u06fb-\\\\u06fc\\\\u0730-\\\\u074a\\\\u0800-\\\\u0814\\\\u081b-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082d\\\\u0840-\\\\u0857\\\\u08e4-\\\\u08fe\\\\u0900-\\\\u0903\\\\u093a-\\\\u093c\\\\u093e-\\\\u094f\\\\u0951-\\\\u0957\\\\u0962-\\\\u0963\\\\u0966-\\\\u096f\\\\u0981-\\\\u0983\\\\u09bc\\\\u09be-\\\\u09c4\\\\u09c7\\\\u09c8\\\\u09d7\\\\u09df-\\\\u09e0\\\\u0a01-\\\\u0a03\\\\u0a3c\\\\u0a3e-\\\\u0a42\\\\u0a47\\\\u0a48\\\\u0a4b-\\\\u0a4d\\\\u0a51\\\\u0a66-\\\\u0a71\\\\u0a75\\\\u0a81-\\\\u0a83\\\\u0abc\\\\u0abe-\\\\u0ac5\\\\u0ac7-\\\\u0ac9\\\\u0acb-\\\\u0acd\\\\u0ae2-\\\\u0ae3\\\\u0ae6-\\\\u0aef\\\\u0b01-\\\\u0b03\\\\u0b3c\\\\u0b3e-\\\\u0b44\\\\u0b47\\\\u0b48\\\\u0b4b-\\\\u0b4d\\\\u0b56\\\\u0b57\\\\u0b5f-\\\\u0b60\\\\u0b66-\\\\u0b6f\\\\u0b82\\\\u0bbe-\\\\u0bc2\\\\u0bc6-\\\\u0bc8\\\\u0bca-\\\\u0bcd\\\\u0bd7\\\\u0be6-\\\\u0bef\\\\u0c01-\\\\u0c03\\\\u0c46-\\\\u0c48\\\\u0c4a-\\\\u0c4d\\\\u0c55\\\\u0c56\\\\u0c62-\\\\u0c63\\\\u0c66-\\\\u0c6f\\\\u0c82\\\\u0c83\\\\u0cbc\\\\u0cbe-\\\\u0cc4\\\\u0cc6-\\\\u0cc8\\\\u0cca-\\\\u0ccd\\\\u0cd5\\\\u0cd6\\\\u0ce2-\\\\u0ce3\\\\u0ce6-\\\\u0cef\\\\u0d02\\\\u0d03\\\\u0d46-\\\\u0d48\\\\u0d57\\\\u0d62-\\\\u0d63\\\\u0d66-\\\\u0d6f\\\\u0d82\\\\u0d83\\\\u0dca\\\\u0dcf-\\\\u0dd4\\\\u0dd6\\\\u0dd8-\\\\u0ddf\\\\u0df2\\\\u0df3\\\\u0e34-\\\\u0e3a\\\\u0e40-\\\\u0e45\\\\u0e50-\\\\u0e59\\\\u0eb4-\\\\u0eb9\\\\u0ec8-\\\\u0ecd\\\\u0ed0-\\\\u0ed9\\\\u0f18\\\\u0f19\\\\u0f20-\\\\u0f29\\\\u0f35\\\\u0f37\\\\u0f39\\\\u0f41-\\\\u0f47\\\\u0f71-\\\\u0f84\\\\u0f86-\\\\u0f87\\\\u0f8d-\\\\u0f97\\\\u0f99-\\\\u0fbc\\\\u0fc6\\\\u1000-\\\\u1029\\\\u1040-\\\\u1049\\\\u1067-\\\\u106d\\\\u1071-\\\\u1074\\\\u1082-\\\\u108d\\\\u108f-\\\\u109d\\\\u135d-\\\\u135f\\\\u170e-\\\\u1710\\\\u1720-\\\\u1730\\\\u1740-\\\\u1750\\\\u1772\\\\u1773\\\\u1780-\\\\u17b2\\\\u17dd\\\\u17e0-\\\\u17e9\\\\u180b-\\\\u180d\\\\u1810-\\\\u1819\\\\u1920-\\\\u192b\\\\u1930-\\\\u193b\\\\u1951-\\\\u196d\\\\u19b0-\\\\u19c0\\\\u19c8-\\\\u19c9\\\\u19d0-\\\\u19d9\\\\u1a00-\\\\u1a15\\\\u1a20-\\\\u1a53\\\\u1a60-\\\\u1a7c\\\\u1a7f-\\\\u1a89\\\\u1a90-\\\\u1a99\\\\u1b46-\\\\u1b4b\\\\u1b50-\\\\u1b59\\\\u1b6b-\\\\u1b73\\\\u1bb0-\\\\u1bb9\\\\u1be6-\\\\u1bf3\\\\u1c00-\\\\u1c22\\\\u1c40-\\\\u1c49\\\\u1c5b-\\\\u1c7d\\\\u1cd0-\\\\u1cd2\\\\u1d00-\\\\u1dbe\\\\u1e01-\\\\u1f15\\\\u200c\\\\u200d\\\\u203f\\\\u2040\\\\u2054\\\\u20d0-\\\\u20dc\\\\u20e1\\\\u20e5-\\\\u20f0\\\\u2d81-\\\\u2d96\\\\u2de0-\\\\u2dff\\\\u3021-\\\\u3028\\\\u3099\\\\u309a\\\\ua640-\\\\ua66d\\\\ua674-\\\\ua67d\\\\ua69f\\\\ua6f0-\\\\ua6f1\\\\ua7f8-\\\\ua800\\\\ua806\\\\ua80b\\\\ua823-\\\\ua827\\\\ua880-\\\\ua881\\\\ua8b4-\\\\ua8c4\\\\ua8d0-\\\\ua8d9\\\\ua8f3-\\\\ua8f7\\\\ua900-\\\\ua909\\\\ua926-\\\\ua92d\\\\ua930-\\\\ua945\\\\ua980-\\\\ua983\\\\ua9b3-\\\\ua9c0\\\\uaa00-\\\\uaa27\\\\uaa40-\\\\uaa41\\\\uaa4c-\\\\uaa4d\\\\uaa50-\\\\uaa59\\\\uaa7b\\\\uaae0-\\\\uaae9\\\\uaaf2-\\\\uaaf3\\\\uabc0-\\\\uabe1\\\\uabec\\\\uabed\\\\uabf0-\\\\uabf9\\\\ufb20-\\\\ufb28\\\\ufe00-\\\\ufe0f\\\\ufe20-\\\\ufe26\\\\ufe33\\\\ufe34\\\\ufe4d-\\\\ufe4f\\\\uff10-\\\\uff19\\\\uff3f\";\n                //var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n                //var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n                var unicodeEscapeOrCodePoint = \"\\\\\\\\u[0-9a-fA-F]{4}|\\\\\\\\u\\\\{[0-9a-fA-F]+\\\\}\";\n                var identifierStart = \"(?:\" + unicodeEscapeOrCodePoint + \"|[\" + baseASCIIidentifierStartChars + nonASCIIidentifierStartChars + \"])\";\n                var identifierChars = \"(?:\" + unicodeEscapeOrCodePoint + \"|[\" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"])*\";\n                exports1.identifier = new RegExp(identifierStart + identifierChars, \"g\");\n                exports1.identifierStart = new RegExp(identifierStart);\n                exports1.identifierMatch = new RegExp(\"(?:\" + unicodeEscapeOrCodePoint + \"|[\" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"])+\");\n                var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/; // jshint ignore:line\n                // Whether a single character denotes a newline.\n                exports1.newline = /[\\n\\r\\u2028\\u2029]/;\n                // Matches a whole line break (where CRLF is considered a single\n                // line break). Used to count lines.\n                // in javascript, these two differ\n                // in python they are the same, different methods are called on them\n                exports1.lineBreak = new RegExp(\"\\r\\n|\" + exports1.newline.source);\n                exports1.allLineBreaks = new RegExp(exports1.lineBreak.source, \"g\");\n            /***/ },\n            /* 5 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_122920__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var BaseOptions = __nested_webpack_require_122920__(6).Options;\n                var validPositionValues = [\n                    \"before-newline\",\n                    \"after-newline\",\n                    \"preserve-newline\"\n                ];\n                function Options(options) {\n                    BaseOptions.call(this, options, \"js\");\n                    // compatibility, re\n                    var raw_brace_style = this.raw_options.brace_style || null;\n                    if (raw_brace_style === \"expand-strict\") {\n                        this.raw_options.brace_style = \"expand\";\n                    } else if (raw_brace_style === \"collapse-preserve-inline\") {\n                        this.raw_options.brace_style = \"collapse,preserve-inline\";\n                    } else if (this.raw_options.braces_on_own_line !== undefined) {\n                        this.raw_options.brace_style = this.raw_options.braces_on_own_line ? \"expand\" : \"collapse\";\n                    // } else if (!raw_brace_style) { //Nothing exists to set it\n                    //   raw_brace_style = \"collapse\";\n                    }\n                    //preserve-inline in delimited string will trigger brace_preserve_inline, everything\n                    //else is considered a brace_style and the last one only will have an effect\n                    var brace_style_split = this._get_selection_list(\"brace_style\", [\n                        \"collapse\",\n                        \"expand\",\n                        \"end-expand\",\n                        \"none\",\n                        \"preserve-inline\"\n                    ]);\n                    this.brace_preserve_inline = false; //Defaults in case one or other was not specified in meta-option\n                    this.brace_style = \"collapse\";\n                    for(var bs = 0; bs < brace_style_split.length; bs++){\n                        if (brace_style_split[bs] === \"preserve-inline\") {\n                            this.brace_preserve_inline = true;\n                        } else {\n                            this.brace_style = brace_style_split[bs];\n                        }\n                    }\n                    this.unindent_chained_methods = this._get_boolean(\"unindent_chained_methods\");\n                    this.break_chained_methods = this._get_boolean(\"break_chained_methods\");\n                    this.space_in_paren = this._get_boolean(\"space_in_paren\");\n                    this.space_in_empty_paren = this._get_boolean(\"space_in_empty_paren\");\n                    this.jslint_happy = this._get_boolean(\"jslint_happy\");\n                    this.space_after_anon_function = this._get_boolean(\"space_after_anon_function\");\n                    this.space_after_named_function = this._get_boolean(\"space_after_named_function\");\n                    this.keep_array_indentation = this._get_boolean(\"keep_array_indentation\");\n                    this.space_before_conditional = this._get_boolean(\"space_before_conditional\", true);\n                    this.unescape_strings = this._get_boolean(\"unescape_strings\");\n                    this.e4x = this._get_boolean(\"e4x\");\n                    this.comma_first = this._get_boolean(\"comma_first\");\n                    this.operator_position = this._get_selection(\"operator_position\", validPositionValues);\n                    // For testing of beautify preserve:start directive\n                    this.test_output_raw = this._get_boolean(\"test_output_raw\");\n                    // force this._options.space_after_anon_function to true if this._options.jslint_happy\n                    if (this.jslint_happy) {\n                        this.space_after_anon_function = true;\n                    }\n                }\n                Options.prototype = new BaseOptions();\n                module.exports.Options = Options;\n            /***/ },\n            /* 6 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Options(options, merge_child_field) {\n                    this.raw_options = _mergeOpts(options, merge_child_field);\n                    // Support passing the source text back with no change\n                    this.disabled = this._get_boolean(\"disabled\");\n                    this.eol = this._get_characters(\"eol\", \"auto\");\n                    this.end_with_newline = this._get_boolean(\"end_with_newline\");\n                    this.indent_size = this._get_number(\"indent_size\", 4);\n                    this.indent_char = this._get_characters(\"indent_char\", \" \");\n                    this.indent_level = this._get_number(\"indent_level\");\n                    this.preserve_newlines = this._get_boolean(\"preserve_newlines\", true);\n                    this.max_preserve_newlines = this._get_number(\"max_preserve_newlines\", 32786);\n                    if (!this.preserve_newlines) {\n                        this.max_preserve_newlines = 0;\n                    }\n                    this.indent_with_tabs = this._get_boolean(\"indent_with_tabs\", this.indent_char === \"\t\");\n                    if (this.indent_with_tabs) {\n                        this.indent_char = \"\t\";\n                        // indent_size behavior changed after 1.8.6\n                        // It used to be that indent_size would be\n                        // set to 1 for indent_with_tabs. That is no longer needed and\n                        // actually doesn't make sense - why not use spaces? Further,\n                        // that might produce unexpected behavior - tabs being used\n                        // for single-column alignment. So, when indent_with_tabs is true\n                        // and indent_size is 1, reset indent_size to 4.\n                        if (this.indent_size === 1) {\n                            this.indent_size = 4;\n                        }\n                    }\n                    // Backwards compat with 1.3.x\n                    this.wrap_line_length = this._get_number(\"wrap_line_length\", this._get_number(\"max_char\"));\n                    this.indent_empty_lines = this._get_boolean(\"indent_empty_lines\");\n                    // valid templating languages ['django', 'erb', 'handlebars', 'php', 'smarty', 'angular']\n                    // For now, 'auto' = all off for javascript, all except angular on for html (and inline javascript/css).\n                    // other values ignored\n                    this.templating = this._get_selection_list(\"templating\", [\n                        \"auto\",\n                        \"none\",\n                        \"angular\",\n                        \"django\",\n                        \"erb\",\n                        \"handlebars\",\n                        \"php\",\n                        \"smarty\"\n                    ], [\n                        \"auto\"\n                    ]);\n                }\n                Options.prototype._get_array = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = default_value || [];\n                    if (typeof option_value === \"object\") {\n                        if (option_value !== null && typeof option_value.concat === \"function\") {\n                            result = option_value.concat();\n                        }\n                    } else if (typeof option_value === \"string\") {\n                        result = option_value.split(/[^a-zA-Z0-9_\\/\\-]+/);\n                    }\n                    return result;\n                };\n                Options.prototype._get_boolean = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = option_value === undefined ? !!default_value : !!option_value;\n                    return result;\n                };\n                Options.prototype._get_characters = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = default_value || \"\";\n                    if (typeof option_value === \"string\") {\n                        result = option_value.replace(/\\\\r/, \"\\r\").replace(/\\\\n/, \"\\n\").replace(/\\\\t/, \"\t\");\n                    }\n                    return result;\n                };\n                Options.prototype._get_number = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    default_value = parseInt(default_value, 10);\n                    if (isNaN(default_value)) {\n                        default_value = 0;\n                    }\n                    var result = parseInt(option_value, 10);\n                    if (isNaN(result)) {\n                        result = default_value;\n                    }\n                    return result;\n                };\n                Options.prototype._get_selection = function(name, selection_list, default_value) {\n                    var result = this._get_selection_list(name, selection_list, default_value);\n                    if (result.length !== 1) {\n                        throw new Error(\"Invalid Option Value: The option '\" + name + \"' can only be one of the following values:\\n\" + selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n                    }\n                    return result[0];\n                };\n                Options.prototype._get_selection_list = function(name, selection_list, default_value) {\n                    if (!selection_list || selection_list.length === 0) {\n                        throw new Error(\"Selection list cannot be empty.\");\n                    }\n                    default_value = default_value || [\n                        selection_list[0]\n                    ];\n                    if (!this._is_valid_selection(default_value, selection_list)) {\n                        throw new Error(\"Invalid Default Value!\");\n                    }\n                    var result = this._get_array(name, default_value);\n                    if (!this._is_valid_selection(result, selection_list)) {\n                        throw new Error(\"Invalid Option Value: The option '\" + name + \"' can contain only the following values:\\n\" + selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n                    }\n                    return result;\n                };\n                Options.prototype._is_valid_selection = function(result, selection_list) {\n                    return result.length && selection_list.length && !result.some(function(item) {\n                        return selection_list.indexOf(item) === -1;\n                    });\n                };\n                // merges child options up with the parent options object\n                // Example: obj = {a: 1, b: {a: 2}}\n                //          mergeOpts(obj, 'b')\n                //\n                //          Returns: {a: 2}\n                function _mergeOpts(allOptions, childFieldName) {\n                    var finalOpts = {};\n                    allOptions = _normalizeOpts(allOptions);\n                    var name;\n                    for(name in allOptions){\n                        if (name !== childFieldName) {\n                            finalOpts[name] = allOptions[name];\n                        }\n                    }\n                    //merge in the per type settings for the childFieldName\n                    if (childFieldName && allOptions[childFieldName]) {\n                        for(name in allOptions[childFieldName]){\n                            finalOpts[name] = allOptions[childFieldName][name];\n                        }\n                    }\n                    return finalOpts;\n                }\n                function _normalizeOpts(options) {\n                    var convertedOpts = {};\n                    var key;\n                    for(key in options){\n                        var newKey = key.replace(/-/g, \"_\");\n                        convertedOpts[newKey] = options[key];\n                    }\n                    return convertedOpts;\n                }\n                module.exports.Options = Options;\n                module.exports.normalizeOpts = _normalizeOpts;\n                module.exports.mergeOpts = _mergeOpts;\n            /***/ },\n            /* 7 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_137512__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var InputScanner = __nested_webpack_require_137512__(8).InputScanner;\n                var BaseTokenizer = __nested_webpack_require_137512__(9).Tokenizer;\n                var BASETOKEN = __nested_webpack_require_137512__(9).TOKEN;\n                var Directives = __nested_webpack_require_137512__(13).Directives;\n                var acorn = __nested_webpack_require_137512__(4);\n                var Pattern = __nested_webpack_require_137512__(12).Pattern;\n                var TemplatablePattern = __nested_webpack_require_137512__(14).TemplatablePattern;\n                function in_array(what, arr) {\n                    return arr.indexOf(what) !== -1;\n                }\n                var TOKEN = {\n                    START_EXPR: \"TK_START_EXPR\",\n                    END_EXPR: \"TK_END_EXPR\",\n                    START_BLOCK: \"TK_START_BLOCK\",\n                    END_BLOCK: \"TK_END_BLOCK\",\n                    WORD: \"TK_WORD\",\n                    RESERVED: \"TK_RESERVED\",\n                    SEMICOLON: \"TK_SEMICOLON\",\n                    STRING: \"TK_STRING\",\n                    EQUALS: \"TK_EQUALS\",\n                    OPERATOR: \"TK_OPERATOR\",\n                    COMMA: \"TK_COMMA\",\n                    BLOCK_COMMENT: \"TK_BLOCK_COMMENT\",\n                    COMMENT: \"TK_COMMENT\",\n                    DOT: \"TK_DOT\",\n                    UNKNOWN: \"TK_UNKNOWN\",\n                    START: BASETOKEN.START,\n                    RAW: BASETOKEN.RAW,\n                    EOF: BASETOKEN.EOF\n                };\n                var directives_core = new Directives(/\\/\\*/, /\\*\\//);\n                var number_pattern = /0[xX][0123456789abcdefABCDEF_]*n?|0[oO][01234567_]*n?|0[bB][01_]*n?|\\d[\\d_]*n|(?:\\.\\d[\\d_]*|\\d[\\d_]*\\.?[\\d_]*)(?:[eE][+-]?[\\d_]+)?/;\n                var digit = /[0-9]/;\n                // Dot \".\" must be distinguished from \"...\" and decimal\n                var dot_pattern = /[^\\d\\.]/;\n                var positionable_operators = (\">>> === !== &&= ??= ||= \" + \"<< && >= ** != == <= >> || ?? |> \" + \"< / - + > : & % ? ^ | *\").split(\" \");\n                // IMPORTANT: this must be sorted longest to shortest or tokenizing many not work.\n                // Also, you must update possitionable operators separately from punct\n                var punct = \">>>= \" + \"... >>= <<= === >>> !== **= &&= ??= ||= \" + \"=> ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> \" + \"= ! ? > < : / ^ - + * & % ~ |\";\n                punct = punct.replace(/[-[\\]{}()*+?.,\\\\^$|#]/g, \"\\\\$&\");\n                // ?. but not if followed by a number \n                punct = \"\\\\?\\\\.(?!\\\\d) \" + punct;\n                punct = punct.replace(/ /g, \"|\");\n                var punct_pattern = new RegExp(punct);\n                // words which should always start on new line.\n                var line_starters = \"continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export\".split(\",\");\n                var reserved_words = line_starters.concat([\n                    \"do\",\n                    \"in\",\n                    \"of\",\n                    \"else\",\n                    \"get\",\n                    \"set\",\n                    \"new\",\n                    \"catch\",\n                    \"finally\",\n                    \"typeof\",\n                    \"yield\",\n                    \"async\",\n                    \"await\",\n                    \"from\",\n                    \"as\",\n                    \"class\",\n                    \"extends\"\n                ]);\n                var reserved_word_pattern = new RegExp(\"^(?:\" + reserved_words.join(\"|\") + \")$\");\n                // var template_pattern = /(?:(?:<\\?php|<\\?=)[\\s\\S]*?\\?>)|(?:<%[\\s\\S]*?%>)/g;\n                var in_html_comment;\n                var Tokenizer = function(input_string, options) {\n                    BaseTokenizer.call(this, input_string, options);\n                    this._patterns.whitespace = this._patterns.whitespace.matching(/\\u00A0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff/.source, /\\u2028\\u2029/.source);\n                    var pattern_reader = new Pattern(this._input);\n                    var templatable = new TemplatablePattern(this._input).read_options(this._options);\n                    this.__patterns = {\n                        template: templatable,\n                        identifier: templatable.starting_with(acorn.identifier).matching(acorn.identifierMatch),\n                        number: pattern_reader.matching(number_pattern),\n                        punct: pattern_reader.matching(punct_pattern),\n                        // comment ends just before nearest linefeed or end of file\n                        comment: pattern_reader.starting_with(/\\/\\//).until(/[\\n\\r\\u2028\\u2029]/),\n                        //  /* ... */ comment ends with nearest */ or end of file\n                        block_comment: pattern_reader.starting_with(/\\/\\*/).until_after(/\\*\\//),\n                        html_comment_start: pattern_reader.matching(/<!--/),\n                        html_comment_end: pattern_reader.matching(/-->/),\n                        include: pattern_reader.starting_with(/#include/).until_after(acorn.lineBreak),\n                        shebang: pattern_reader.starting_with(/#!/).until_after(acorn.lineBreak),\n                        xml: pattern_reader.matching(/[\\s\\S]*?<(\\/?)([-a-zA-Z:0-9_.]+|{[^}]+?}|!\\[CDATA\\[[^\\]]*?\\]\\]|)(\\s*{[^}]+?}|\\s+[-a-zA-Z:0-9_.]+|\\s+[-a-zA-Z:0-9_.]+\\s*=\\s*('[^']*'|\"[^\"]*\"|{([^{}]|{[^}]+?})+?}))*\\s*(\\/?)\\s*>/),\n                        single_quote: templatable.until(/['\\\\\\n\\r\\u2028\\u2029]/),\n                        double_quote: templatable.until(/[\"\\\\\\n\\r\\u2028\\u2029]/),\n                        template_text: templatable.until(/[`\\\\$]/),\n                        template_expression: templatable.until(/[`}\\\\]/)\n                    };\n                };\n                Tokenizer.prototype = new BaseTokenizer();\n                Tokenizer.prototype._is_comment = function(current_token) {\n                    return current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.BLOCK_COMMENT || current_token.type === TOKEN.UNKNOWN;\n                };\n                Tokenizer.prototype._is_opening = function(current_token) {\n                    return current_token.type === TOKEN.START_BLOCK || current_token.type === TOKEN.START_EXPR;\n                };\n                Tokenizer.prototype._is_closing = function(current_token, open_token) {\n                    return (current_token.type === TOKEN.END_BLOCK || current_token.type === TOKEN.END_EXPR) && open_token && (current_token.text === \"]\" && open_token.text === \"[\" || current_token.text === \")\" && open_token.text === \"(\" || current_token.text === \"}\" && open_token.text === \"{\");\n                };\n                Tokenizer.prototype._reset = function() {\n                    in_html_comment = false;\n                };\n                Tokenizer.prototype._get_next_token = function(previous_token, open_token) {\n                    var token = null;\n                    this._readWhitespace();\n                    var c = this._input.peek();\n                    if (c === null) {\n                        return this._create_token(TOKEN.EOF, \"\");\n                    }\n                    token = token || this._read_non_javascript(c);\n                    token = token || this._read_string(c);\n                    token = token || this._read_pair(c, this._input.peek(1)); // Issue #2062 hack for record type '#{'\n                    token = token || this._read_word(previous_token);\n                    token = token || this._read_singles(c);\n                    token = token || this._read_comment(c);\n                    token = token || this._read_regexp(c, previous_token);\n                    token = token || this._read_xml(c, previous_token);\n                    token = token || this._read_punctuation();\n                    token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());\n                    return token;\n                };\n                Tokenizer.prototype._read_word = function(previous_token) {\n                    var resulting_string;\n                    resulting_string = this.__patterns.identifier.read();\n                    if (resulting_string !== \"\") {\n                        resulting_string = resulting_string.replace(acorn.allLineBreaks, \"\\n\");\n                        if (!(previous_token.type === TOKEN.DOT || previous_token.type === TOKEN.RESERVED && (previous_token.text === \"set\" || previous_token.text === \"get\")) && reserved_word_pattern.test(resulting_string)) {\n                            if ((resulting_string === \"in\" || resulting_string === \"of\") && (previous_token.type === TOKEN.WORD || previous_token.type === TOKEN.STRING)) {\n                                return this._create_token(TOKEN.OPERATOR, resulting_string);\n                            }\n                            return this._create_token(TOKEN.RESERVED, resulting_string);\n                        }\n                        return this._create_token(TOKEN.WORD, resulting_string);\n                    }\n                    resulting_string = this.__patterns.number.read();\n                    if (resulting_string !== \"\") {\n                        return this._create_token(TOKEN.WORD, resulting_string);\n                    }\n                };\n                Tokenizer.prototype._read_singles = function(c) {\n                    var token = null;\n                    if (c === \"(\" || c === \"[\") {\n                        token = this._create_token(TOKEN.START_EXPR, c);\n                    } else if (c === \")\" || c === \"]\") {\n                        token = this._create_token(TOKEN.END_EXPR, c);\n                    } else if (c === \"{\") {\n                        token = this._create_token(TOKEN.START_BLOCK, c);\n                    } else if (c === \"}\") {\n                        token = this._create_token(TOKEN.END_BLOCK, c);\n                    } else if (c === \";\") {\n                        token = this._create_token(TOKEN.SEMICOLON, c);\n                    } else if (c === \".\" && dot_pattern.test(this._input.peek(1))) {\n                        token = this._create_token(TOKEN.DOT, c);\n                    } else if (c === \",\") {\n                        token = this._create_token(TOKEN.COMMA, c);\n                    }\n                    if (token) {\n                        this._input.next();\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_pair = function(c, d) {\n                    var token = null;\n                    if (c === \"#\" && d === \"{\") {\n                        token = this._create_token(TOKEN.START_BLOCK, c + d);\n                    }\n                    if (token) {\n                        this._input.next();\n                        this._input.next();\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_punctuation = function() {\n                    var resulting_string = this.__patterns.punct.read();\n                    if (resulting_string !== \"\") {\n                        if (resulting_string === \"=\") {\n                            return this._create_token(TOKEN.EQUALS, resulting_string);\n                        } else if (resulting_string === \"?.\") {\n                            return this._create_token(TOKEN.DOT, resulting_string);\n                        } else {\n                            return this._create_token(TOKEN.OPERATOR, resulting_string);\n                        }\n                    }\n                };\n                Tokenizer.prototype._read_non_javascript = function(c) {\n                    var resulting_string = \"\";\n                    if (c === \"#\") {\n                        if (this._is_first_token()) {\n                            resulting_string = this.__patterns.shebang.read();\n                            if (resulting_string) {\n                                return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + \"\\n\");\n                            }\n                        }\n                        // handles extendscript #includes\n                        resulting_string = this.__patterns.include.read();\n                        if (resulting_string) {\n                            return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + \"\\n\");\n                        }\n                        c = this._input.next();\n                        // Spidermonkey-specific sharp variables for circular references. Considered obsolete.\n                        var sharp = \"#\";\n                        if (this._input.hasNext() && this._input.testChar(digit)) {\n                            do {\n                                c = this._input.next();\n                                sharp += c;\n                            }while (this._input.hasNext() && c !== \"#\" && c !== \"=\");\n                            if (c === \"#\") {\n                            //\n                            } else if (this._input.peek() === \"[\" && this._input.peek(1) === \"]\") {\n                                sharp += \"[]\";\n                                this._input.next();\n                                this._input.next();\n                            } else if (this._input.peek() === \"{\" && this._input.peek(1) === \"}\") {\n                                sharp += \"{}\";\n                                this._input.next();\n                                this._input.next();\n                            }\n                            return this._create_token(TOKEN.WORD, sharp);\n                        }\n                        this._input.back();\n                    } else if (c === \"<\" && this._is_first_token()) {\n                        resulting_string = this.__patterns.html_comment_start.read();\n                        if (resulting_string) {\n                            while(this._input.hasNext() && !this._input.testChar(acorn.newline)){\n                                resulting_string += this._input.next();\n                            }\n                            in_html_comment = true;\n                            return this._create_token(TOKEN.COMMENT, resulting_string);\n                        }\n                    } else if (in_html_comment && c === \"-\") {\n                        resulting_string = this.__patterns.html_comment_end.read();\n                        if (resulting_string) {\n                            in_html_comment = false;\n                            return this._create_token(TOKEN.COMMENT, resulting_string);\n                        }\n                    }\n                    return null;\n                };\n                Tokenizer.prototype._read_comment = function(c) {\n                    var token = null;\n                    if (c === \"/\") {\n                        var comment = \"\";\n                        if (this._input.peek(1) === \"*\") {\n                            // peek for comment /* ... */\n                            comment = this.__patterns.block_comment.read();\n                            var directives = directives_core.get_directives(comment);\n                            if (directives && directives.ignore === \"start\") {\n                                comment += directives_core.readIgnored(this._input);\n                            }\n                            comment = comment.replace(acorn.allLineBreaks, \"\\n\");\n                            token = this._create_token(TOKEN.BLOCK_COMMENT, comment);\n                            token.directives = directives;\n                        } else if (this._input.peek(1) === \"/\") {\n                            // peek for comment // ...\n                            comment = this.__patterns.comment.read();\n                            token = this._create_token(TOKEN.COMMENT, comment);\n                        }\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_string = function(c) {\n                    if (c === \"`\" || c === \"'\" || c === '\"') {\n                        var resulting_string = this._input.next();\n                        this.has_char_escapes = false;\n                        if (c === \"`\") {\n                            resulting_string += this._read_string_recursive(\"`\", true, \"${\");\n                        } else {\n                            resulting_string += this._read_string_recursive(c);\n                        }\n                        if (this.has_char_escapes && this._options.unescape_strings) {\n                            resulting_string = unescape_string(resulting_string);\n                        }\n                        if (this._input.peek() === c) {\n                            resulting_string += this._input.next();\n                        }\n                        resulting_string = resulting_string.replace(acorn.allLineBreaks, \"\\n\");\n                        return this._create_token(TOKEN.STRING, resulting_string);\n                    }\n                    return null;\n                };\n                Tokenizer.prototype._allow_regexp_or_xml = function(previous_token) {\n                    // regex and xml can only appear in specific locations during parsing\n                    return previous_token.type === TOKEN.RESERVED && in_array(previous_token.text, [\n                        \"return\",\n                        \"case\",\n                        \"throw\",\n                        \"else\",\n                        \"do\",\n                        \"typeof\",\n                        \"yield\"\n                    ]) || previous_token.type === TOKEN.END_EXPR && previous_token.text === \")\" && previous_token.opened.previous.type === TOKEN.RESERVED && in_array(previous_token.opened.previous.text, [\n                        \"if\",\n                        \"while\",\n                        \"for\"\n                    ]) || in_array(previous_token.type, [\n                        TOKEN.COMMENT,\n                        TOKEN.START_EXPR,\n                        TOKEN.START_BLOCK,\n                        TOKEN.START,\n                        TOKEN.END_BLOCK,\n                        TOKEN.OPERATOR,\n                        TOKEN.EQUALS,\n                        TOKEN.EOF,\n                        TOKEN.SEMICOLON,\n                        TOKEN.COMMA\n                    ]);\n                };\n                Tokenizer.prototype._read_regexp = function(c, previous_token) {\n                    if (c === \"/\" && this._allow_regexp_or_xml(previous_token)) {\n                        // handle regexp\n                        //\n                        var resulting_string = this._input.next();\n                        var esc = false;\n                        var in_char_class = false;\n                        while(this._input.hasNext() && (esc || in_char_class || this._input.peek() !== c) && !this._input.testChar(acorn.newline)){\n                            resulting_string += this._input.peek();\n                            if (!esc) {\n                                esc = this._input.peek() === \"\\\\\";\n                                if (this._input.peek() === \"[\") {\n                                    in_char_class = true;\n                                } else if (this._input.peek() === \"]\") {\n                                    in_char_class = false;\n                                }\n                            } else {\n                                esc = false;\n                            }\n                            this._input.next();\n                        }\n                        if (this._input.peek() === c) {\n                            resulting_string += this._input.next();\n                            // regexps may have modifiers /regexp/MOD , so fetch those, too\n                            // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.\n                            resulting_string += this._input.read(acorn.identifier);\n                        }\n                        return this._create_token(TOKEN.STRING, resulting_string);\n                    }\n                    return null;\n                };\n                Tokenizer.prototype._read_xml = function(c, previous_token) {\n                    if (this._options.e4x && c === \"<\" && this._allow_regexp_or_xml(previous_token)) {\n                        var xmlStr = \"\";\n                        var match = this.__patterns.xml.read_match();\n                        // handle e4x xml literals\n                        //\n                        if (match) {\n                            // Trim root tag to attempt to\n                            var rootTag = match[2].replace(/^{\\s+/, \"{\").replace(/\\s+}$/, \"}\");\n                            var isCurlyRoot = rootTag.indexOf(\"{\") === 0;\n                            var depth = 0;\n                            while(match){\n                                var isEndTag = !!match[1];\n                                var tagName = match[2];\n                                var isSingletonTag = !!match[match.length - 1] || tagName.slice(0, 8) === \"![CDATA[\";\n                                if (!isSingletonTag && (tagName === rootTag || isCurlyRoot && tagName.replace(/^{\\s+/, \"{\").replace(/\\s+}$/, \"}\"))) {\n                                    if (isEndTag) {\n                                        --depth;\n                                    } else {\n                                        ++depth;\n                                    }\n                                }\n                                xmlStr += match[0];\n                                if (depth <= 0) {\n                                    break;\n                                }\n                                match = this.__patterns.xml.read_match();\n                            }\n                            // if we didn't close correctly, keep unformatted.\n                            if (!match) {\n                                xmlStr += this._input.match(/[\\s\\S]*/g)[0];\n                            }\n                            xmlStr = xmlStr.replace(acorn.allLineBreaks, \"\\n\");\n                            return this._create_token(TOKEN.STRING, xmlStr);\n                        }\n                    }\n                    return null;\n                };\n                function unescape_string(s) {\n                    // You think that a regex would work for this\n                    // return s.replace(/\\\\x([0-9a-f]{2})/gi, function(match, val) {\n                    //         return String.fromCharCode(parseInt(val, 16));\n                    //     })\n                    // However, dealing with '\\xff', '\\\\xff', '\\\\\\xff' makes this more fun.\n                    var out = \"\", escaped = 0;\n                    var input_scan = new InputScanner(s);\n                    var matched = null;\n                    while(input_scan.hasNext()){\n                        // Keep any whitespace, non-slash characters\n                        // also keep slash pairs.\n                        matched = input_scan.match(/([\\s]|[^\\\\]|\\\\\\\\)+/g);\n                        if (matched) {\n                            out += matched[0];\n                        }\n                        if (input_scan.peek() === \"\\\\\") {\n                            input_scan.next();\n                            if (input_scan.peek() === \"x\") {\n                                matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);\n                            } else if (input_scan.peek() === \"u\") {\n                                matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);\n                                if (!matched) {\n                                    matched = input_scan.match(/u\\{([0-9A-Fa-f]+)\\}/g);\n                                }\n                            } else {\n                                out += \"\\\\\";\n                                if (input_scan.hasNext()) {\n                                    out += input_scan.next();\n                                }\n                                continue;\n                            }\n                            // If there's some error decoding, return the original string\n                            if (!matched) {\n                                return s;\n                            }\n                            escaped = parseInt(matched[1], 16);\n                            if (escaped > 0x7e && escaped <= 0xff && matched[0].indexOf(\"x\") === 0) {\n                                // we bail out on \\x7f..\\xff,\n                                // leaving whole string escaped,\n                                // as it's probably completely binary\n                                return s;\n                            } else if (escaped >= 0x00 && escaped < 0x20) {\n                                // leave 0x00...0x1f escaped\n                                out += \"\\\\\" + matched[0];\n                            } else if (escaped > 0x10FFFF) {\n                                // If the escape sequence is out of bounds, keep the original sequence and continue conversion\n                                out += \"\\\\\" + matched[0];\n                            } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {\n                                // single-quote, apostrophe, backslash - escape these\n                                out += \"\\\\\" + String.fromCharCode(escaped);\n                            } else {\n                                out += String.fromCharCode(escaped);\n                            }\n                        }\n                    }\n                    return out;\n                }\n                // handle string\n                //\n                Tokenizer.prototype._read_string_recursive = function(delimiter, allow_unescaped_newlines, start_sub) {\n                    var current_char;\n                    var pattern;\n                    if (delimiter === \"'\") {\n                        pattern = this.__patterns.single_quote;\n                    } else if (delimiter === '\"') {\n                        pattern = this.__patterns.double_quote;\n                    } else if (delimiter === \"`\") {\n                        pattern = this.__patterns.template_text;\n                    } else if (delimiter === \"}\") {\n                        pattern = this.__patterns.template_expression;\n                    }\n                    var resulting_string = pattern.read();\n                    var next = \"\";\n                    while(this._input.hasNext()){\n                        next = this._input.next();\n                        if (next === delimiter || !allow_unescaped_newlines && acorn.newline.test(next)) {\n                            this._input.back();\n                            break;\n                        } else if (next === \"\\\\\" && this._input.hasNext()) {\n                            current_char = this._input.peek();\n                            if (current_char === \"x\" || current_char === \"u\") {\n                                this.has_char_escapes = true;\n                            } else if (current_char === \"\\r\" && this._input.peek(1) === \"\\n\") {\n                                this._input.next();\n                            }\n                            next += this._input.next();\n                        } else if (start_sub) {\n                            if (start_sub === \"${\" && next === \"$\" && this._input.peek() === \"{\") {\n                                next += this._input.next();\n                            }\n                            if (start_sub === next) {\n                                if (delimiter === \"`\") {\n                                    next += this._read_string_recursive(\"}\", allow_unescaped_newlines, \"`\");\n                                } else {\n                                    next += this._read_string_recursive(\"`\", allow_unescaped_newlines, \"${\");\n                                }\n                                if (this._input.hasNext()) {\n                                    next += this._input.next();\n                                }\n                            }\n                        }\n                        next += pattern.read();\n                        resulting_string += next;\n                    }\n                    return resulting_string;\n                };\n                module.exports.Tokenizer = Tokenizer;\n                module.exports.TOKEN = TOKEN;\n                module.exports.positionable_operators = positionable_operators.slice();\n                module.exports.line_starters = line_starters.slice();\n            /***/ },\n            /* 8 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var regexp_has_sticky = RegExp.prototype.hasOwnProperty(\"sticky\");\n                function InputScanner(input_string) {\n                    this.__input = input_string || \"\";\n                    this.__input_length = this.__input.length;\n                    this.__position = 0;\n                }\n                InputScanner.prototype.restart = function() {\n                    this.__position = 0;\n                };\n                InputScanner.prototype.back = function() {\n                    if (this.__position > 0) {\n                        this.__position -= 1;\n                    }\n                };\n                InputScanner.prototype.hasNext = function() {\n                    return this.__position < this.__input_length;\n                };\n                InputScanner.prototype.next = function() {\n                    var val = null;\n                    if (this.hasNext()) {\n                        val = this.__input.charAt(this.__position);\n                        this.__position += 1;\n                    }\n                    return val;\n                };\n                InputScanner.prototype.peek = function(index) {\n                    var val = null;\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__input_length) {\n                        val = this.__input.charAt(index);\n                    }\n                    return val;\n                };\n                // This is a JavaScript only helper function (not in python)\n                // Javascript doesn't have a match method\n                // and not all implementation support \"sticky\" flag.\n                // If they do not support sticky then both this.match() and this.test() method\n                // must get the match and check the index of the match.\n                // If sticky is supported and set, this method will use it.\n                // Otherwise it will check that global is set, and fall back to the slower method.\n                InputScanner.prototype.__match = function(pattern, index) {\n                    pattern.lastIndex = index;\n                    var pattern_match = pattern.exec(this.__input);\n                    if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {\n                        if (pattern_match.index !== index) {\n                            pattern_match = null;\n                        }\n                    }\n                    return pattern_match;\n                };\n                InputScanner.prototype.test = function(pattern, index) {\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__input_length) {\n                        return !!this.__match(pattern, index);\n                    } else {\n                        return false;\n                    }\n                };\n                InputScanner.prototype.testChar = function(pattern, index) {\n                    // test one character regex match\n                    var val = this.peek(index);\n                    pattern.lastIndex = 0;\n                    return val !== null && pattern.test(val);\n                };\n                InputScanner.prototype.match = function(pattern) {\n                    var pattern_match = this.__match(pattern, this.__position);\n                    if (pattern_match) {\n                        this.__position += pattern_match[0].length;\n                    } else {\n                        pattern_match = null;\n                    }\n                    return pattern_match;\n                };\n                InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {\n                    var val = \"\";\n                    var match;\n                    if (starting_pattern) {\n                        match = this.match(starting_pattern);\n                        if (match) {\n                            val += match[0];\n                        }\n                    }\n                    if (until_pattern && (match || !starting_pattern)) {\n                        val += this.readUntil(until_pattern, until_after);\n                    }\n                    return val;\n                };\n                InputScanner.prototype.readUntil = function(pattern, until_after) {\n                    var val = \"\";\n                    var match_index = this.__position;\n                    pattern.lastIndex = this.__position;\n                    var pattern_match = pattern.exec(this.__input);\n                    if (pattern_match) {\n                        match_index = pattern_match.index;\n                        if (until_after) {\n                            match_index += pattern_match[0].length;\n                        }\n                    } else {\n                        match_index = this.__input_length;\n                    }\n                    val = this.__input.substring(this.__position, match_index);\n                    this.__position = match_index;\n                    return val;\n                };\n                InputScanner.prototype.readUntilAfter = function(pattern) {\n                    return this.readUntil(pattern, true);\n                };\n                InputScanner.prototype.get_regexp = function(pattern, match_from) {\n                    var result = null;\n                    var flags = \"g\";\n                    if (match_from && regexp_has_sticky) {\n                        flags = \"y\";\n                    }\n                    // strings are converted to regexp\n                    if (typeof pattern === \"string\" && pattern !== \"\") {\n                        // result = new RegExp(pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'), flags);\n                        result = new RegExp(pattern, flags);\n                    } else if (pattern) {\n                        result = new RegExp(pattern.source, flags);\n                    }\n                    return result;\n                };\n                InputScanner.prototype.get_literal_regexp = function(literal_string) {\n                    return RegExp(literal_string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"));\n                };\n                /* css beautifier legacy helpers */ InputScanner.prototype.peekUntilAfter = function(pattern) {\n                    var start = this.__position;\n                    var val = this.readUntilAfter(pattern);\n                    this.__position = start;\n                    return val;\n                };\n                InputScanner.prototype.lookBack = function(testVal) {\n                    var start = this.__position - 1;\n                    return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;\n                };\n                module.exports.InputScanner = InputScanner;\n            /***/ },\n            /* 9 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_175358__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var InputScanner = __nested_webpack_require_175358__(8).InputScanner;\n                var Token = __nested_webpack_require_175358__(3).Token;\n                var TokenStream = __nested_webpack_require_175358__(10).TokenStream;\n                var WhitespacePattern = __nested_webpack_require_175358__(11).WhitespacePattern;\n                var TOKEN = {\n                    START: \"TK_START\",\n                    RAW: \"TK_RAW\",\n                    EOF: \"TK_EOF\"\n                };\n                var Tokenizer = function(input_string, options) {\n                    this._input = new InputScanner(input_string);\n                    this._options = options || {};\n                    this.__tokens = null;\n                    this._patterns = {};\n                    this._patterns.whitespace = new WhitespacePattern(this._input);\n                };\n                Tokenizer.prototype.tokenize = function() {\n                    this._input.restart();\n                    this.__tokens = new TokenStream();\n                    this._reset();\n                    var current;\n                    var previous = new Token(TOKEN.START, \"\");\n                    var open_token = null;\n                    var open_stack = [];\n                    var comments = new TokenStream();\n                    while(previous.type !== TOKEN.EOF){\n                        current = this._get_next_token(previous, open_token);\n                        while(this._is_comment(current)){\n                            comments.add(current);\n                            current = this._get_next_token(previous, open_token);\n                        }\n                        if (!comments.isEmpty()) {\n                            current.comments_before = comments;\n                            comments = new TokenStream();\n                        }\n                        current.parent = open_token;\n                        if (this._is_opening(current)) {\n                            open_stack.push(open_token);\n                            open_token = current;\n                        } else if (open_token && this._is_closing(current, open_token)) {\n                            current.opened = open_token;\n                            open_token.closed = current;\n                            open_token = open_stack.pop();\n                            current.parent = open_token;\n                        }\n                        current.previous = previous;\n                        previous.next = current;\n                        this.__tokens.add(current);\n                        previous = current;\n                    }\n                    return this.__tokens;\n                };\n                Tokenizer.prototype._is_first_token = function() {\n                    return this.__tokens.isEmpty();\n                };\n                Tokenizer.prototype._reset = function() {};\n                Tokenizer.prototype._get_next_token = function(previous_token, open_token) {\n                    this._readWhitespace();\n                    var resulting_string = this._input.read(/.+/g);\n                    if (resulting_string) {\n                        return this._create_token(TOKEN.RAW, resulting_string);\n                    } else {\n                        return this._create_token(TOKEN.EOF, \"\");\n                    }\n                };\n                Tokenizer.prototype._is_comment = function(current_token) {\n                    return false;\n                };\n                Tokenizer.prototype._is_opening = function(current_token) {\n                    return false;\n                };\n                Tokenizer.prototype._is_closing = function(current_token, open_token) {\n                    return false;\n                };\n                Tokenizer.prototype._create_token = function(type, text) {\n                    var token = new Token(type, text, this._patterns.whitespace.newline_count, this._patterns.whitespace.whitespace_before_token);\n                    return token;\n                };\n                Tokenizer.prototype._readWhitespace = function() {\n                    return this._patterns.whitespace.read();\n                };\n                module.exports.Tokenizer = Tokenizer;\n                module.exports.TOKEN = TOKEN;\n            /***/ },\n            /* 10 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function TokenStream(parent_token) {\n                    // private\n                    this.__tokens = [];\n                    this.__tokens_length = this.__tokens.length;\n                    this.__position = 0;\n                    this.__parent_token = parent_token;\n                }\n                TokenStream.prototype.restart = function() {\n                    this.__position = 0;\n                };\n                TokenStream.prototype.isEmpty = function() {\n                    return this.__tokens_length === 0;\n                };\n                TokenStream.prototype.hasNext = function() {\n                    return this.__position < this.__tokens_length;\n                };\n                TokenStream.prototype.next = function() {\n                    var val = null;\n                    if (this.hasNext()) {\n                        val = this.__tokens[this.__position];\n                        this.__position += 1;\n                    }\n                    return val;\n                };\n                TokenStream.prototype.peek = function(index) {\n                    var val = null;\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__tokens_length) {\n                        val = this.__tokens[index];\n                    }\n                    return val;\n                };\n                TokenStream.prototype.add = function(token) {\n                    if (this.__parent_token) {\n                        token.parent = this.__parent_token;\n                    }\n                    this.__tokens.push(token);\n                    this.__tokens_length += 1;\n                };\n                module.exports.TokenStream = TokenStream;\n            /***/ },\n            /* 11 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_183892__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Pattern = __nested_webpack_require_183892__(12).Pattern;\n                function WhitespacePattern(input_scanner, parent) {\n                    Pattern.call(this, input_scanner, parent);\n                    if (parent) {\n                        this._line_regexp = this._input.get_regexp(parent._line_regexp);\n                    } else {\n                        this.__set_whitespace_patterns(\"\", \"\");\n                    }\n                    this.newline_count = 0;\n                    this.whitespace_before_token = \"\";\n                }\n                WhitespacePattern.prototype = new Pattern();\n                WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {\n                    whitespace_chars += \"\\\\t \";\n                    newline_chars += \"\\\\n\\\\r\";\n                    this._match_pattern = this._input.get_regexp(\"[\" + whitespace_chars + newline_chars + \"]+\", true);\n                    this._newline_regexp = this._input.get_regexp(\"\\\\r\\\\n|[\" + newline_chars + \"]\");\n                };\n                WhitespacePattern.prototype.read = function() {\n                    this.newline_count = 0;\n                    this.whitespace_before_token = \"\";\n                    var resulting_string = this._input.read(this._match_pattern);\n                    if (resulting_string === \" \") {\n                        this.whitespace_before_token = \" \";\n                    } else if (resulting_string) {\n                        var matches = this.__split(this._newline_regexp, resulting_string);\n                        this.newline_count = matches.length - 1;\n                        this.whitespace_before_token = matches[this.newline_count];\n                    }\n                    return resulting_string;\n                };\n                WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {\n                    var result = this._create();\n                    result.__set_whitespace_patterns(whitespace_chars, newline_chars);\n                    result._update();\n                    return result;\n                };\n                WhitespacePattern.prototype._create = function() {\n                    return new WhitespacePattern(this._input, this);\n                };\n                WhitespacePattern.prototype.__split = function(regexp, input_string) {\n                    regexp.lastIndex = 0;\n                    var start_index = 0;\n                    var result = [];\n                    var next_match = regexp.exec(input_string);\n                    while(next_match){\n                        result.push(input_string.substring(start_index, next_match.index));\n                        start_index = next_match.index + next_match[0].length;\n                        next_match = regexp.exec(input_string);\n                    }\n                    if (start_index < input_string.length) {\n                        result.push(input_string.substring(start_index, input_string.length));\n                    } else {\n                        result.push(\"\");\n                    }\n                    return result;\n                };\n                module.exports.WhitespacePattern = WhitespacePattern;\n            /***/ },\n            /* 12 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Pattern(input_scanner, parent) {\n                    this._input = input_scanner;\n                    this._starting_pattern = null;\n                    this._match_pattern = null;\n                    this._until_pattern = null;\n                    this._until_after = false;\n                    if (parent) {\n                        this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);\n                        this._match_pattern = this._input.get_regexp(parent._match_pattern, true);\n                        this._until_pattern = this._input.get_regexp(parent._until_pattern);\n                        this._until_after = parent._until_after;\n                    }\n                }\n                Pattern.prototype.read = function() {\n                    var result = this._input.read(this._starting_pattern);\n                    if (!this._starting_pattern || result) {\n                        result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);\n                    }\n                    return result;\n                };\n                Pattern.prototype.read_match = function() {\n                    return this._input.match(this._match_pattern);\n                };\n                Pattern.prototype.until_after = function(pattern) {\n                    var result = this._create();\n                    result._until_after = true;\n                    result._until_pattern = this._input.get_regexp(pattern);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype.until = function(pattern) {\n                    var result = this._create();\n                    result._until_after = false;\n                    result._until_pattern = this._input.get_regexp(pattern);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype.starting_with = function(pattern) {\n                    var result = this._create();\n                    result._starting_pattern = this._input.get_regexp(pattern, true);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype.matching = function(pattern) {\n                    var result = this._create();\n                    result._match_pattern = this._input.get_regexp(pattern, true);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype._create = function() {\n                    return new Pattern(this._input, this);\n                };\n                Pattern.prototype._update = function() {};\n                module.exports.Pattern = Pattern;\n            /***/ },\n            /* 13 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Directives(start_block_pattern, end_block_pattern) {\n                    start_block_pattern = typeof start_block_pattern === \"string\" ? start_block_pattern : start_block_pattern.source;\n                    end_block_pattern = typeof end_block_pattern === \"string\" ? end_block_pattern : end_block_pattern.source;\n                    this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \\w+[:]\\w+)+ /.source + end_block_pattern, \"g\");\n                    this.__directive_pattern = / (\\w+)[:](\\w+)/g;\n                    this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\\sbeautify\\signore:end\\s/.source + end_block_pattern, \"g\");\n                }\n                Directives.prototype.get_directives = function(text) {\n                    if (!text.match(this.__directives_block_pattern)) {\n                        return null;\n                    }\n                    var directives = {};\n                    this.__directive_pattern.lastIndex = 0;\n                    var directive_match = this.__directive_pattern.exec(text);\n                    while(directive_match){\n                        directives[directive_match[1]] = directive_match[2];\n                        directive_match = this.__directive_pattern.exec(text);\n                    }\n                    return directives;\n                };\n                Directives.prototype.readIgnored = function(input) {\n                    return input.readUntilAfter(this.__directives_end_ignore_pattern);\n                };\n                module.exports.Directives = Directives;\n            /***/ },\n            /* 14 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_195284__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Pattern = __nested_webpack_require_195284__(12).Pattern;\n                var template_names = {\n                    django: false,\n                    erb: false,\n                    handlebars: false,\n                    php: false,\n                    smarty: false,\n                    angular: false\n                };\n                // This lets templates appear anywhere we would do a readUntil\n                // The cost is higher but it is pay to play.\n                function TemplatablePattern(input_scanner, parent) {\n                    Pattern.call(this, input_scanner, parent);\n                    this.__template_pattern = null;\n                    this._disabled = Object.assign({}, template_names);\n                    this._excluded = Object.assign({}, template_names);\n                    if (parent) {\n                        this.__template_pattern = this._input.get_regexp(parent.__template_pattern);\n                        this._excluded = Object.assign(this._excluded, parent._excluded);\n                        this._disabled = Object.assign(this._disabled, parent._disabled);\n                    }\n                    var pattern = new Pattern(input_scanner);\n                    this.__patterns = {\n                        handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),\n                        handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),\n                        handlebars: pattern.starting_with(/{{/).until_after(/}}/),\n                        php: pattern.starting_with(/<\\?(?:[= ]|php)/).until_after(/\\?>/),\n                        erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),\n                        // django coflicts with handlebars a bit.\n                        django: pattern.starting_with(/{%/).until_after(/%}/),\n                        django_value: pattern.starting_with(/{{/).until_after(/}}/),\n                        django_comment: pattern.starting_with(/{#/).until_after(/#}/),\n                        smarty: pattern.starting_with(/{(?=[^}{\\s\\n])/).until_after(/[^\\s\\n]}/),\n                        smarty_comment: pattern.starting_with(/{\\*/).until_after(/\\*}/),\n                        smarty_literal: pattern.starting_with(/{literal}/).until_after(/{\\/literal}/)\n                    };\n                }\n                TemplatablePattern.prototype = new Pattern();\n                TemplatablePattern.prototype._create = function() {\n                    return new TemplatablePattern(this._input, this);\n                };\n                TemplatablePattern.prototype._update = function() {\n                    this.__set_templated_pattern();\n                };\n                TemplatablePattern.prototype.disable = function(language) {\n                    var result = this._create();\n                    result._disabled[language] = true;\n                    result._update();\n                    return result;\n                };\n                TemplatablePattern.prototype.read_options = function(options) {\n                    var result = this._create();\n                    for(var language in template_names){\n                        result._disabled[language] = options.templating.indexOf(language) === -1;\n                    }\n                    result._update();\n                    return result;\n                };\n                TemplatablePattern.prototype.exclude = function(language) {\n                    var result = this._create();\n                    result._excluded[language] = true;\n                    result._update();\n                    return result;\n                };\n                TemplatablePattern.prototype.read = function() {\n                    var result = \"\";\n                    if (this._match_pattern) {\n                        result = this._input.read(this._starting_pattern);\n                    } else {\n                        result = this._input.read(this._starting_pattern, this.__template_pattern);\n                    }\n                    var next = this._read_template();\n                    while(next){\n                        if (this._match_pattern) {\n                            next += this._input.read(this._match_pattern);\n                        } else {\n                            next += this._input.readUntil(this.__template_pattern);\n                        }\n                        result += next;\n                        next = this._read_template();\n                    }\n                    if (this._until_after) {\n                        result += this._input.readUntilAfter(this._until_pattern);\n                    }\n                    return result;\n                };\n                TemplatablePattern.prototype.__set_templated_pattern = function() {\n                    var items = [];\n                    if (!this._disabled.php) {\n                        items.push(this.__patterns.php._starting_pattern.source);\n                    }\n                    if (!this._disabled.handlebars) {\n                        items.push(this.__patterns.handlebars._starting_pattern.source);\n                    }\n                    if (!this._disabled.erb) {\n                        items.push(this.__patterns.erb._starting_pattern.source);\n                    }\n                    if (!this._disabled.django) {\n                        items.push(this.__patterns.django._starting_pattern.source);\n                        // The starting pattern for django is more complex because it has different\n                        // patterns for value, comment, and other sections\n                        items.push(this.__patterns.django_value._starting_pattern.source);\n                        items.push(this.__patterns.django_comment._starting_pattern.source);\n                    }\n                    if (!this._disabled.smarty) {\n                        items.push(this.__patterns.smarty._starting_pattern.source);\n                    }\n                    if (this._until_pattern) {\n                        items.push(this._until_pattern.source);\n                    }\n                    this.__template_pattern = this._input.get_regexp(\"(?:\" + items.join(\"|\") + \")\");\n                };\n                TemplatablePattern.prototype._read_template = function() {\n                    var resulting_string = \"\";\n                    var c = this._input.peek();\n                    if (c === \"<\") {\n                        var peek1 = this._input.peek(1);\n                        //if we're in a comment, do something special\n                        // We treat all comments as literals, even more than preformatted tags\n                        // we just look for the appropriate close tag\n                        if (!this._disabled.php && !this._excluded.php && peek1 === \"?\") {\n                            resulting_string = resulting_string || this.__patterns.php.read();\n                        }\n                        if (!this._disabled.erb && !this._excluded.erb && peek1 === \"%\") {\n                            resulting_string = resulting_string || this.__patterns.erb.read();\n                        }\n                    } else if (c === \"{\") {\n                        if (!this._disabled.handlebars && !this._excluded.handlebars) {\n                            resulting_string = resulting_string || this.__patterns.handlebars_comment.read();\n                            resulting_string = resulting_string || this.__patterns.handlebars_unescaped.read();\n                            resulting_string = resulting_string || this.__patterns.handlebars.read();\n                        }\n                        if (!this._disabled.django) {\n                            // django coflicts with handlebars a bit.\n                            if (!this._excluded.django && !this._excluded.handlebars) {\n                                resulting_string = resulting_string || this.__patterns.django_value.read();\n                            }\n                            if (!this._excluded.django) {\n                                resulting_string = resulting_string || this.__patterns.django_comment.read();\n                                resulting_string = resulting_string || this.__patterns.django.read();\n                            }\n                        }\n                        if (!this._disabled.smarty) {\n                            // smarty cannot be enabled with django or handlebars enabled\n                            if (this._disabled.django && this._disabled.handlebars) {\n                                resulting_string = resulting_string || this.__patterns.smarty_comment.read();\n                                resulting_string = resulting_string || this.__patterns.smarty_literal.read();\n                                resulting_string = resulting_string || this.__patterns.smarty.read();\n                            }\n                        }\n                    }\n                    return resulting_string;\n                };\n                module.exports.TemplatablePattern = TemplatablePattern;\n            /***/ }\n        ];\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_205796__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_205796__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /******/ // startup\n        /******/ // Load entry module and return exports\n        /******/ // This entry module is referenced by other modules so it can't be inlined\n        /******/ var __nested_webpack_exports__ = __nested_webpack_require_205796__(0);\n        /******/ legacy_beautify_js = __nested_webpack_exports__;\n    /******/ /******/ })();\n    var js_beautify = legacy_beautify_js;\n    /* Footer */ if (true) {\n        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return {\n                js_beautify: js_beautify\n            };\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvbGliL2JlYXV0aWZ5LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxrQ0FBa0MsR0FDbEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9GQSxHQUVDO0lBRUQsMEJBQTBCLEdBQzFCLElBQUlBO0lBQ0osTUFBTSxHQUFJO1FBQ1YsTUFBTSxHQUFJO1FBQ1YsTUFBTSxHQUFJLElBQUlDLHNCQUF1QjtZQUNyQyxLQUFLLEdBQ0wsR0FBRyxHQUFJLFNBQVNDLE1BQU0sRUFBRUMsd0JBQXdCLEVBQUVDLCtCQUFtQjtnQkFFckUsbUJBQW1CLEdBQ25COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBLEdBSUEsSUFBSUMsYUFBY0QsK0JBQW1CQSxDQUFDLEdBQUdDLFVBQVUsRUFDakRDLFVBQVdGLCtCQUFtQkEsQ0FBQyxHQUFHRSxPQUFPO2dCQUUzQyxTQUFTQyxZQUFZQyxjQUFjLEVBQUVDLE9BQU87b0JBQzFDLElBQUlDLGFBQWEsSUFBSUwsV0FBV0csZ0JBQWdCQztvQkFDaEQsT0FBT0MsV0FBV0MsUUFBUTtnQkFDNUI7Z0JBRUFULE9BQU9VLE9BQU8sR0FBR0w7Z0JBQ2pCTCxPQUFPVSxPQUFPLENBQUNDLGNBQWMsR0FBRztvQkFDOUIsT0FBTyxJQUFJUDtnQkFDYjtZQUdBLEdBQUcsR0FBRztZQUNOLEtBQUssR0FDTCxHQUFHLEdBQUksU0FBU0osTUFBTSxFQUFFQyx3QkFBd0IsRUFBRUMsK0JBQW1CO2dCQUVyRSxtQkFBbUIsR0FDbkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkEsR0FJQSxJQUFJVSxTQUFVViwrQkFBbUJBLENBQUMsR0FBR1UsTUFBTTtnQkFDM0MsSUFBSUMsUUFBU1gsK0JBQW1CQSxDQUFDLEdBQUdXLEtBQUs7Z0JBQ3pDLElBQUlDLFFBQVFaLCtCQUFtQkEsQ0FB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QU0sR0FBTSwwQkFBMEI7Z0JBQ3RDLE1BQU0sR0FBTXBoQixTQUFTLENBQUM7WUFDWDtZQUNYLE1BQU0sR0FDTixNQUFNLEdBQUssOEJBQThCO1lBQ3pDLE1BQU0sR0FBS1gsbUJBQW1CLENBQUMraEIsU0FBUyxDQUFDOWhCLFFBQVFBLE9BQU9VLE9BQU8sRUFBRVIsaUNBQW1CQTtZQUNwRixNQUFNLEdBQ04sTUFBTSxHQUFLLG1DQUFtQztZQUM5QyxNQUFNLEdBQUssT0FBT0YsT0FBT1UsT0FBTztRQUNoQyxNQUFNLEdBQUk7UUFDVixNQUFNLEdBQ04sd0VBQXdFLEdBQ3hFLE1BQU0sR0FDTixNQUFNLEdBQUksVUFBVTtRQUNwQixNQUFNLEdBQUksdUNBQXVDO1FBQ2pELE1BQU0sR0FBSSwwRUFBMEU7UUFDcEYsTUFBTSxHQUFJLElBQUlzaEIsMEJBQW1CQSxHQUFHOWhCLGlDQUFtQkEsQ0FBQztRQUN4RCxNQUFNLEdBQUlKLHFCQUFxQmtpQiwwQkFBbUJBO0lBQ2xELE1BQU0sR0FDTixNQUFNLEdBQUc7SUFFVCxJQUFJM2hCLGNBQWNQO0lBQ2xCLFVBQVUsR0FDVixJQUFJLElBQTBDLEVBQUU7UUFDNUMsMEZBQTBGO1FBQzFGbWlCLGlDQUFPLEVBQUUsbUNBQUU7WUFDUCxPQUFPO2dCQUFFNWhCLGFBQWFBO1lBQVk7UUFDdEMsQ0FBQztBQUFBLGtHQUFDO0lBQ04sT0FBTyxFQVVOO0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvbGliL2JlYXV0aWZ5LmpzP2M3YzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyogQVVUTy1HRU5FUkFURUQuIERPIE5PVCBNT0RJRlkuICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cblxuIEpTIEJlYXV0aWZpZXJcbi0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgV3JpdHRlbiBieSBFaW5hciBMaWVsbWFuaXMsIDxlaW5hckBiZWF1dGlmaWVyLmlvPlxuICAgICAgaHR0cHM6Ly9iZWF1dGlmaWVyLmlvL1xuXG4gIE9yaWdpbmFsbHkgY29udmVydGVkIHRvIGphdmFzY3JpcHQgYnkgVml0YWwsIDx2aXRhbDc2QGdtYWlsLmNvbT5cbiAgXCJFbmQgYnJhY2VzIG9uIG93biBsaW5lXCIgYWRkZWQgYnkgQ2hyaXMgSi4gU2h1bGwsIDxjaHJpc2pzaHVsbEBnbWFpbC5jb20+XG4gIFBhcnNpbmcgaW1wcm92ZW1lbnRzIGZvciBicmFjZS1sZXNzIHN0YXRlbWVudHMgYnkgTGlhbSBOZXdtYW4gPGJpdHdpc2VtYW5AYmVhdXRpZmllci5pbz5cblxuXG4gIFVzYWdlOlxuICAgIGpzX2JlYXV0aWZ5KGpzX3NvdXJjZV90ZXh0KTtcbiAgICBqc19iZWF1dGlmeShqc19zb3VyY2VfdGV4dCwgb3B0aW9ucyk7XG5cbiAgVGhlIG9wdGlvbnMgYXJlOlxuICAgIGluZGVudF9zaXplIChkZWZhdWx0IDQpICAgICAgICAgIC0gaW5kZW50YXRpb24gc2l6ZSxcbiAgICBpbmRlbnRfY2hhciAoZGVmYXVsdCBzcGFjZSkgICAgICAtIGNoYXJhY3RlciB0byBpbmRlbnQgd2l0aCxcbiAgICBwcmVzZXJ2ZV9uZXdsaW5lcyAoZGVmYXVsdCB0cnVlKSAtIHdoZXRoZXIgZXhpc3RpbmcgbGluZSBicmVha3Mgc2hvdWxkIGJlIHByZXNlcnZlZCxcbiAgICBtYXhfcHJlc2VydmVfbmV3bGluZXMgKGRlZmF1bHQgdW5saW1pdGVkKSAtIG1heGltdW0gbnVtYmVyIG9mIGxpbmUgYnJlYWtzIHRvIGJlIHByZXNlcnZlZCBpbiBvbmUgY2h1bmssXG5cbiAgICBqc2xpbnRfaGFwcHkgKGRlZmF1bHQgZmFsc2UpIC0gaWYgdHJ1ZSwgdGhlbiBqc2xpbnQtc3RyaWN0ZXIgbW9kZSBpcyBlbmZvcmNlZC5cblxuICAgICAgICAgICAganNsaW50X2hhcHB5ICAgICAgICAhanNsaW50X2hhcHB5XG4gICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGZ1bmN0aW9uICgpICAgICAgICAgZnVuY3Rpb24oKVxuXG4gICAgICAgICAgICBzd2l0Y2ggKCkgeyAgICAgICAgIHN3aXRjaCgpIHtcbiAgICAgICAgICAgIGNhc2UgMTogICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGJyZWFrOyAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgfVxuXG4gICAgc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbiAoZGVmYXVsdCBmYWxzZSkgLSBzaG91bGQgdGhlIHNwYWNlIGJlZm9yZSBhbiBhbm9ueW1vdXMgZnVuY3Rpb24ncyBwYXJlbnMgYmUgYWRkZWQsIFwiZnVuY3Rpb24oKVwiIHZzIFwiZnVuY3Rpb24gKClcIixcbiAgICAgICAgICBOT1RFOiBUaGlzIG9wdGlvbiBpcyBvdmVycmlkZGVuIGJ5IGpzbGludF9oYXBweSAoaS5lLiBpZiBqc2xpbnRfaGFwcHkgaXMgdHJ1ZSwgc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbiBpcyB0cnVlIGJ5IGRlc2lnbilcblxuICAgIGJyYWNlX3N0eWxlIChkZWZhdWx0IFwiY29sbGFwc2VcIikgLSBcImNvbGxhcHNlXCIgfCBcImV4cGFuZFwiIHwgXCJlbmQtZXhwYW5kXCIgfCBcIm5vbmVcIiB8IGFueSBvZiB0aGUgZm9ybWVyICsgXCIscHJlc2VydmUtaW5saW5lXCJcbiAgICAgICAgICAgIHB1dCBicmFjZXMgb24gdGhlIHNhbWUgbGluZSBhcyBjb250cm9sIHN0YXRlbWVudHMgKGRlZmF1bHQpLCBvciBwdXQgYnJhY2VzIG9uIG93biBsaW5lIChBbGxtYW4gLyBBTlNJIHN0eWxlKSwgb3IganVzdCBwdXQgZW5kIGJyYWNlcyBvbiBvd24gbGluZSwgb3IgYXR0ZW1wdCB0byBrZWVwIHRoZW0gd2hlcmUgdGhleSBhcmUuXG4gICAgICAgICAgICBwcmVzZXJ2ZS1pbmxpbmUgd2lsbCB0cnkgdG8gcHJlc2VydmUgaW5saW5lIGJsb2NrcyBvZiBjdXJseSBicmFjZXNcblxuICAgIHNwYWNlX2JlZm9yZV9jb25kaXRpb25hbCAoZGVmYXVsdCB0cnVlKSAtIHNob3VsZCB0aGUgc3BhY2UgYmVmb3JlIGNvbmRpdGlvbmFsIHN0YXRlbWVudCBiZSBhZGRlZCwgXCJpZih0cnVlKVwiIHZzIFwiaWYgKHRydWUpXCIsXG5cbiAgICB1bmVzY2FwZV9zdHJpbmdzIChkZWZhdWx0IGZhbHNlKSAtIHNob3VsZCBwcmludGFibGUgY2hhcmFjdGVycyBpbiBzdHJpbmdzIGVuY29kZWQgaW4gXFx4Tk4gbm90YXRpb24gYmUgdW5lc2NhcGVkLCBcImV4YW1wbGVcIiB2cyBcIlxceDY1XFx4NzhcXHg2MVxceDZkXFx4NzBcXHg2Y1xceDY1XCJcblxuICAgIHdyYXBfbGluZV9sZW5ndGggKGRlZmF1bHQgdW5saW1pdGVkKSAtIGxpbmVzIHNob3VsZCB3cmFwIGF0IG5leHQgb3Bwb3J0dW5pdHkgYWZ0ZXIgdGhpcyBudW1iZXIgb2YgY2hhcmFjdGVycy5cbiAgICAgICAgICBOT1RFOiBUaGlzIGlzIG5vdCBhIGhhcmQgbGltaXQuIExpbmVzIHdpbGwgY29udGludWUgdW50aWwgYSBwb2ludCB3aGVyZSBhIG5ld2xpbmUgd291bGRcbiAgICAgICAgICAgICAgICBiZSBwcmVzZXJ2ZWQgaWYgaXQgd2VyZSBwcmVzZW50LlxuXG4gICAgZW5kX3dpdGhfbmV3bGluZSAoZGVmYXVsdCBmYWxzZSkgIC0gZW5kIG91dHB1dCB3aXRoIGEgbmV3bGluZVxuXG5cbiAgICBlLmdcblxuICAgIGpzX2JlYXV0aWZ5KGpzX3NvdXJjZV90ZXh0LCB7XG4gICAgICAnaW5kZW50X3NpemUnOiAxLFxuICAgICAgJ2luZGVudF9jaGFyJzogJ1xcdCdcbiAgICB9KTtcblxuKi9cblxuKGZ1bmN0aW9uKCkge1xuXG4vKiBHRU5FUkFURURfQlVJTERfT1VUUFVUICovXG52YXIgbGVnYWN5X2JlYXV0aWZ5X2pzO1xuLyoqKioqKi8gKGZ1bmN0aW9uKCkgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdFwidXNlIHN0cmljdFwiO1xuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9IChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgQmVhdXRpZmllciA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLkJlYXV0aWZpZXIpLFxuICBPcHRpb25zID0gKF9fd2VicGFja19yZXF1aXJlX18oNSkuT3B0aW9ucyk7XG5cbmZ1bmN0aW9uIGpzX2JlYXV0aWZ5KGpzX3NvdXJjZV90ZXh0LCBvcHRpb25zKSB7XG4gIHZhciBiZWF1dGlmaWVyID0gbmV3IEJlYXV0aWZpZXIoanNfc291cmNlX3RleHQsIG9wdGlvbnMpO1xuICByZXR1cm4gYmVhdXRpZmllci5iZWF1dGlmeSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGpzX2JlYXV0aWZ5O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBPcHRpb25zKCk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIE91dHB1dCA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLk91dHB1dCk7XG52YXIgVG9rZW4gPSAoX193ZWJwYWNrX3JlcXVpcmVfXygzKS5Ub2tlbik7XG52YXIgYWNvcm4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xudmFyIE9wdGlvbnMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg1KS5PcHRpb25zKTtcbnZhciBUb2tlbml6ZXIgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg3KS5Ub2tlbml6ZXIpO1xudmFyIGxpbmVfc3RhcnRlcnMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg3KS5saW5lX3N0YXJ0ZXJzKTtcbnZhciBwb3NpdGlvbmFibGVfb3BlcmF0b3JzID0gKF9fd2VicGFja19yZXF1aXJlX18oNykucG9zaXRpb25hYmxlX29wZXJhdG9ycyk7XG52YXIgVE9LRU4gPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg3KS5UT0tFTik7XG5cblxuZnVuY3Rpb24gaW5fYXJyYXkod2hhdCwgYXJyKSB7XG4gIHJldHVybiBhcnIuaW5kZXhPZih3aGF0KSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIGx0cmltKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvXlxccysvZywgJycpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZU1hcEZyb21TdHJpbmdzKGxpc3QpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IGxpc3QubGVuZ3RoOyB4KyspIHtcbiAgICAvLyBtYWtlIHRoZSBtYXBwZWQgbmFtZXMgdW5kZXJzY29yZWQgaW5zdGVhZCBvZiBkYXNoXG4gICAgcmVzdWx0W2xpc3RbeF0ucmVwbGFjZSgvLS9nLCAnXycpXSA9IGxpc3RbeF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVzZXJ2ZWRfd29yZCh0b2tlbiwgd29yZCkge1xuICByZXR1cm4gdG9rZW4gJiYgdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQgJiYgdG9rZW4udGV4dCA9PT0gd29yZDtcbn1cblxuZnVuY3Rpb24gcmVzZXJ2ZWRfYXJyYXkodG9rZW4sIHdvcmRzKSB7XG4gIHJldHVybiB0b2tlbiAmJiB0b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCAmJiBpbl9hcnJheSh0b2tlbi50ZXh0LCB3b3Jkcyk7XG59XG4vLyBVbnN1cmUgb2Ygd2hhdCB0aGV5IG1lYW4sIGJ1dCB0aGV5IHdvcmsuIFdvcnRoIGNsZWFuaW5nIHVwIGluIGZ1dHVyZS5cbnZhciBzcGVjaWFsX3dvcmRzID0gWydjYXNlJywgJ3JldHVybicsICdkbycsICdpZicsICd0aHJvdycsICdlbHNlJywgJ2F3YWl0JywgJ2JyZWFrJywgJ2NvbnRpbnVlJywgJ2FzeW5jJ107XG5cbnZhciB2YWxpZFBvc2l0aW9uVmFsdWVzID0gWydiZWZvcmUtbmV3bGluZScsICdhZnRlci1uZXdsaW5lJywgJ3ByZXNlcnZlLW5ld2xpbmUnXTtcblxuLy8gR2VuZXJhdGUgbWFwIGZyb20gYXJyYXlcbnZhciBPUEVSQVRPUl9QT1NJVElPTiA9IGdlbmVyYXRlTWFwRnJvbVN0cmluZ3ModmFsaWRQb3NpdGlvblZhbHVlcyk7XG5cbnZhciBPUEVSQVRPUl9QT1NJVElPTl9CRUZPUkVfT1JfUFJFU0VSVkUgPSBbT1BFUkFUT1JfUE9TSVRJT04uYmVmb3JlX25ld2xpbmUsIE9QRVJBVE9SX1BPU0lUSU9OLnByZXNlcnZlX25ld2xpbmVdO1xuXG52YXIgTU9ERSA9IHtcbiAgQmxvY2tTdGF0ZW1lbnQ6ICdCbG9ja1N0YXRlbWVudCcsIC8vICdCTE9DSydcbiAgU3RhdGVtZW50OiAnU3RhdGVtZW50JywgLy8gJ1NUQVRFTUVOVCdcbiAgT2JqZWN0TGl0ZXJhbDogJ09iamVjdExpdGVyYWwnLCAvLyAnT0JKRUNUJyxcbiAgQXJyYXlMaXRlcmFsOiAnQXJyYXlMaXRlcmFsJywgLy8nW0VYUFJFU1NJT05dJyxcbiAgRm9ySW5pdGlhbGl6ZXI6ICdGb3JJbml0aWFsaXplcicsIC8vJyhGT1ItRVhQUkVTU0lPTiknLFxuICBDb25kaXRpb25hbDogJ0NvbmRpdGlvbmFsJywgLy8nKENPTkQtRVhQUkVTU0lPTiknLFxuICBFeHByZXNzaW9uOiAnRXhwcmVzc2lvbicgLy8nKEVYUFJFU1NJT04pJ1xufTtcblxuZnVuY3Rpb24gcmVtb3ZlX3JlZHVuZGFudF9pbmRlbnRhdGlvbihvdXRwdXQsIGZyYW1lKSB7XG4gIC8vIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgZWZmZWN0aXZlIGJ1dCBoYXMgc29tZSBpc3N1ZXM6XG4gIC8vICAgICAtIGNhbiBjYXVzZSBsaW5lIHdyYXAgdG8gaGFwcGVuIHRvbyBzb29uIGR1ZSB0byBpbmRlbnQgcmVtb3ZhbFxuICAvLyAgICAgICAgICAgYWZ0ZXIgd3JhcCBwb2ludHMgYXJlIGNhbGN1bGF0ZWRcbiAgLy8gVGhlc2UgaXNzdWVzIGFyZSBtaW5vciBjb21wYXJlZCB0byB1Z2x5IGluZGVudGF0aW9uLlxuXG4gIGlmIChmcmFtZS5tdWx0aWxpbmVfZnJhbWUgfHxcbiAgICBmcmFtZS5tb2RlID09PSBNT0RFLkZvckluaXRpYWxpemVyIHx8XG4gICAgZnJhbWUubW9kZSA9PT0gTU9ERS5Db25kaXRpb25hbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHJlbW92ZSBvbmUgaW5kZW50IGZyb20gZWFjaCBsaW5lIGluc2lkZSB0aGlzIHNlY3Rpb25cbiAgb3V0cHV0LnJlbW92ZV9pbmRlbnQoZnJhbWUuc3RhcnRfbGluZV9pbmRleCk7XG59XG5cbi8vIHdlIGNvdWxkIHVzZSBqdXN0IHN0cmluZy5zcGxpdCwgYnV0XG4vLyBJRSBkb2Vzbid0IGxpa2UgcmV0dXJuaW5nIGVtcHR5IHN0cmluZ3NcbmZ1bmN0aW9uIHNwbGl0X2xpbmVicmVha3Mocykge1xuICAvL3JldHVybiBzLnNwbGl0KC9cXHgwZFxceDBhfFxceDBhLyk7XG5cbiAgcyA9IHMucmVwbGFjZShhY29ybi5hbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG4gIHZhciBvdXQgPSBbXSxcbiAgICBpZHggPSBzLmluZGV4T2YoXCJcXG5cIik7XG4gIHdoaWxlIChpZHggIT09IC0xKSB7XG4gICAgb3V0LnB1c2gocy5zdWJzdHJpbmcoMCwgaWR4KSk7XG4gICAgcyA9IHMuc3Vic3RyaW5nKGlkeCArIDEpO1xuICAgIGlkeCA9IHMuaW5kZXhPZihcIlxcblwiKTtcbiAgfVxuICBpZiAocy5sZW5ndGgpIHtcbiAgICBvdXQucHVzaChzKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBpc19hcnJheShtb2RlKSB7XG4gIHJldHVybiBtb2RlID09PSBNT0RFLkFycmF5TGl0ZXJhbDtcbn1cblxuZnVuY3Rpb24gaXNfZXhwcmVzc2lvbihtb2RlKSB7XG4gIHJldHVybiBpbl9hcnJheShtb2RlLCBbTU9ERS5FeHByZXNzaW9uLCBNT0RFLkZvckluaXRpYWxpemVyLCBNT0RFLkNvbmRpdGlvbmFsXSk7XG59XG5cbmZ1bmN0aW9uIGFsbF9saW5lc19zdGFydF93aXRoKGxpbmVzLCBjKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGluZSA9IGxpbmVzW2ldLnRyaW0oKTtcbiAgICBpZiAobGluZS5jaGFyQXQoMCkgIT09IGMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGVhY2hfbGluZV9tYXRjaGVzX2luZGVudChsaW5lcywgaW5kZW50KSB7XG4gIHZhciBpID0gMCxcbiAgICBsZW4gPSBsaW5lcy5sZW5ndGgsXG4gICAgbGluZTtcbiAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAvLyBhbGxvdyBlbXB0eSBsaW5lcyB0byBwYXNzIHRocm91Z2hcbiAgICBpZiAobGluZSAmJiBsaW5lLmluZGV4T2YoaW5kZW50KSAhPT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG5mdW5jdGlvbiBCZWF1dGlmaWVyKHNvdXJjZV90ZXh0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLl9zb3VyY2VfdGV4dCA9IHNvdXJjZV90ZXh0IHx8ICcnO1xuXG4gIHRoaXMuX291dHB1dCA9IG51bGw7XG4gIHRoaXMuX3Rva2VucyA9IG51bGw7XG4gIHRoaXMuX2xhc3RfbGFzdF90ZXh0ID0gbnVsbDtcbiAgdGhpcy5fZmxhZ3MgPSBudWxsO1xuICB0aGlzLl9wcmV2aW91c19mbGFncyA9IG51bGw7XG5cbiAgdGhpcy5fZmxhZ19zdG9yZSA9IG51bGw7XG4gIHRoaXMuX29wdGlvbnMgPSBuZXcgT3B0aW9ucyhvcHRpb25zKTtcbn1cblxuQmVhdXRpZmllci5wcm90b3R5cGUuY3JlYXRlX2ZsYWdzID0gZnVuY3Rpb24oZmxhZ3NfYmFzZSwgbW9kZSkge1xuICB2YXIgbmV4dF9pbmRlbnRfbGV2ZWwgPSAwO1xuICBpZiAoZmxhZ3NfYmFzZSkge1xuICAgIG5leHRfaW5kZW50X2xldmVsID0gZmxhZ3NfYmFzZS5pbmRlbnRhdGlvbl9sZXZlbDtcbiAgICBpZiAoIXRoaXMuX291dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSAmJlxuICAgICAgZmxhZ3NfYmFzZS5saW5lX2luZGVudF9sZXZlbCA+IG5leHRfaW5kZW50X2xldmVsKSB7XG4gICAgICBuZXh0X2luZGVudF9sZXZlbCA9IGZsYWdzX2Jhc2UubGluZV9pbmRlbnRfbGV2ZWw7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5leHRfZmxhZ3MgPSB7XG4gICAgbW9kZTogbW9kZSxcbiAgICBwYXJlbnQ6IGZsYWdzX2Jhc2UsXG4gICAgbGFzdF90b2tlbjogZmxhZ3NfYmFzZSA/IGZsYWdzX2Jhc2UubGFzdF90b2tlbiA6IG5ldyBUb2tlbihUT0tFTi5TVEFSVF9CTE9DSywgJycpLCAvLyBsYXN0IHRva2VuIHRleHRcbiAgICBsYXN0X3dvcmQ6IGZsYWdzX2Jhc2UgPyBmbGFnc19iYXNlLmxhc3Rfd29yZCA6ICcnLCAvLyBsYXN0IFRPS0VOLldPUkQgcGFzc2VkXG4gICAgZGVjbGFyYXRpb25fc3RhdGVtZW50OiBmYWxzZSxcbiAgICBkZWNsYXJhdGlvbl9hc3NpZ25tZW50OiBmYWxzZSxcbiAgICBtdWx0aWxpbmVfZnJhbWU6IGZhbHNlLFxuICAgIGlubGluZV9mcmFtZTogZmFsc2UsXG4gICAgaWZfYmxvY2s6IGZhbHNlLFxuICAgIGVsc2VfYmxvY2s6IGZhbHNlLFxuICAgIGNsYXNzX3N0YXJ0X2Jsb2NrOiBmYWxzZSwgLy8gY2xhc3MgQSB7IElOU0lERSBIRVJFIH0gb3IgY2xhc3MgQiBleHRlbmRzIEMgeyBJTlNJREUgSEVSRSB9XG4gICAgZG9fYmxvY2s6IGZhbHNlLFxuICAgIGRvX3doaWxlOiBmYWxzZSxcbiAgICBpbXBvcnRfYmxvY2s6IGZhbHNlLFxuICAgIGluX2Nhc2Vfc3RhdGVtZW50OiBmYWxzZSwgLy8gc3dpdGNoKC4uKXsgSU5TSURFIEhFUkUgfVxuICAgIGluX2Nhc2U6IGZhbHNlLCAvLyB3ZSdyZSBvbiB0aGUgZXhhY3QgbGluZSB3aXRoIFwiY2FzZSAwOlwiXG4gICAgY2FzZV9ib2R5OiBmYWxzZSwgLy8gdGhlIGluZGVudGVkIGNhc2UtYWN0aW9uIGJsb2NrXG4gICAgY2FzZV9ibG9jazogZmFsc2UsIC8vIHRoZSBpbmRlbnRlZCBjYXNlLWFjdGlvbiBibG9jayBpcyB3cmFwcGVkIHdpdGgge31cbiAgICBpbmRlbnRhdGlvbl9sZXZlbDogbmV4dF9pbmRlbnRfbGV2ZWwsXG4gICAgYWxpZ25tZW50OiAwLFxuICAgIGxpbmVfaW5kZW50X2xldmVsOiBmbGFnc19iYXNlID8gZmxhZ3NfYmFzZS5saW5lX2luZGVudF9sZXZlbCA6IG5leHRfaW5kZW50X2xldmVsLFxuICAgIHN0YXJ0X2xpbmVfaW5kZXg6IHRoaXMuX291dHB1dC5nZXRfbGluZV9udW1iZXIoKSxcbiAgICB0ZXJuYXJ5X2RlcHRoOiAwXG4gIH07XG4gIHJldHVybiBuZXh0X2ZsYWdzO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24oc291cmNlX3RleHQpIHtcbiAgdmFyIGJhc2VJbmRlbnRTdHJpbmcgPSBzb3VyY2VfdGV4dC5tYXRjaCgvXltcXHQgXSovKVswXTtcblxuICB0aGlzLl9sYXN0X2xhc3RfdGV4dCA9ICcnOyAvLyBwcmUtbGFzdCB0b2tlbiB0ZXh0XG4gIHRoaXMuX291dHB1dCA9IG5ldyBPdXRwdXQodGhpcy5fb3B0aW9ucywgYmFzZUluZGVudFN0cmluZyk7XG5cbiAgLy8gSWYgdGVzdGluZyB0aGUgaWdub3JlIGRpcmVjdGl2ZSwgc3RhcnQgd2l0aCBvdXRwdXQgZGlzYWJsZSBzZXQgdG8gdHJ1ZVxuICB0aGlzLl9vdXRwdXQucmF3ID0gdGhpcy5fb3B0aW9ucy50ZXN0X291dHB1dF9yYXc7XG5cblxuICAvLyBTdGFjayBvZiBwYXJzaW5nL2Zvcm1hdHRpbmcgc3RhdGVzLCBpbmNsdWRpbmcgTU9ERS5cbiAgLy8gV2UgdG9rZW5pemUsIHBhcnNlLCBhbmQgb3V0cHV0IGluIGFuIGFsbW9zdCBwdXJlbHkgYSBmb3J3YXJkLW9ubHkgc3RyZWFtIG9mIHRva2VuIGlucHV0XG4gIC8vIGFuZCBmb3JtYXR0ZWQgb3V0cHV0LiAgVGhpcyBtYWtlcyB0aGUgYmVhdXRpZmllciBsZXNzIGFjY3VyYXRlIHRoYW4gZnVsbCBwYXJzZXJzXG4gIC8vIGJ1dCBhbHNvIGZhciBtb3JlIHRvbGVyYW50IG9mIHN5bnRheCBlcnJvcnMuXG4gIC8vXG4gIC8vIEZvciBleGFtcGxlLCB0aGUgZGVmYXVsdCBtb2RlIGlzIE1PREUuQmxvY2tTdGF0ZW1lbnQuIElmIHdlIHNlZSBhICd7JyB3ZSBwdXNoIGEgbmV3IGZyYW1lIG9mIHR5cGVcbiAgLy8gTU9ERS5CbG9ja1N0YXRlbWVudCBvbiB0aGUgdGhlIHN0YWNrLCBldmVuIHRob3VnaCBpdCBjb3VsZCBiZSBvYmplY3QgbGl0ZXJhbC4gIElmIHdlIGxhdGVyXG4gIC8vIGVuY291bnRlciBhIFwiOlwiLCB3ZSdsbCBzd2l0Y2ggdG8gdG8gTU9ERS5PYmplY3RMaXRlcmFsLiAgSWYgd2UgdGhlbiBzZWUgYSBcIjtcIixcbiAgLy8gbW9zdCBmdWxsIHBhcnNlcnMgd291bGQgZGllLCBidXQgdGhlIGJlYXV0aWZpZXIgZ3JhY2VmdWxseSBmYWxscyBiYWNrIHRvXG4gIC8vIE1PREUuQmxvY2tTdGF0ZW1lbnQgYW5kIGNvbnRpbnVlcyBvbi5cbiAgdGhpcy5fZmxhZ19zdG9yZSA9IFtdO1xuICB0aGlzLnNldF9tb2RlKE1PREUuQmxvY2tTdGF0ZW1lbnQpO1xuICB2YXIgdG9rZW5pemVyID0gbmV3IFRva2VuaXplcihzb3VyY2VfdGV4dCwgdGhpcy5fb3B0aW9ucyk7XG4gIHRoaXMuX3Rva2VucyA9IHRva2VuaXplci50b2tlbml6ZSgpO1xuICByZXR1cm4gc291cmNlX3RleHQ7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5iZWF1dGlmeSA9IGZ1bmN0aW9uKCkge1xuICAvLyBpZiBkaXNhYmxlZCwgcmV0dXJuIHRoZSBpbnB1dCB1bmNoYW5nZWQuXG4gIGlmICh0aGlzLl9vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZV90ZXh0O1xuICB9XG5cbiAgdmFyIHN3ZWV0X2NvZGU7XG4gIHZhciBzb3VyY2VfdGV4dCA9IHRoaXMuX3Jlc2V0KHRoaXMuX3NvdXJjZV90ZXh0KTtcblxuICB2YXIgZW9sID0gdGhpcy5fb3B0aW9ucy5lb2w7XG4gIGlmICh0aGlzLl9vcHRpb25zLmVvbCA9PT0gJ2F1dG8nKSB7XG4gICAgZW9sID0gJ1xcbic7XG4gICAgaWYgKHNvdXJjZV90ZXh0ICYmIGFjb3JuLmxpbmVCcmVhay50ZXN0KHNvdXJjZV90ZXh0IHx8ICcnKSkge1xuICAgICAgZW9sID0gc291cmNlX3RleHQubWF0Y2goYWNvcm4ubGluZUJyZWFrKVswXTtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudF90b2tlbiA9IHRoaXMuX3Rva2Vucy5uZXh0KCk7XG4gIHdoaWxlIChjdXJyZW50X3Rva2VuKSB7XG4gICAgdGhpcy5oYW5kbGVfdG9rZW4oY3VycmVudF90b2tlbik7XG5cbiAgICB0aGlzLl9sYXN0X2xhc3RfdGV4dCA9IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dDtcbiAgICB0aGlzLl9mbGFncy5sYXN0X3Rva2VuID0gY3VycmVudF90b2tlbjtcblxuICAgIGN1cnJlbnRfdG9rZW4gPSB0aGlzLl90b2tlbnMubmV4dCgpO1xuICB9XG5cbiAgc3dlZXRfY29kZSA9IHRoaXMuX291dHB1dC5nZXRfY29kZShlb2wpO1xuXG4gIHJldHVybiBzd2VldF9jb2RlO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX3Rva2VuID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0VYUFIpIHtcbiAgICB0aGlzLmhhbmRsZV9zdGFydF9leHByKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0VYUFIpIHtcbiAgICB0aGlzLmhhbmRsZV9lbmRfZXhwcihjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0JMT0NLKSB7XG4gICAgdGhpcy5oYW5kbGVfc3RhcnRfYmxvY2soY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfQkxPQ0spIHtcbiAgICB0aGlzLmhhbmRsZV9lbmRfYmxvY2soY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5XT1JEKSB7XG4gICAgdGhpcy5oYW5kbGVfd29yZChjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEKSB7XG4gICAgdGhpcy5oYW5kbGVfd29yZChjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNFTUlDT0xPTikge1xuICAgIHRoaXMuaGFuZGxlX3NlbWljb2xvbihjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUUklORykge1xuICAgIHRoaXMuaGFuZGxlX3N0cmluZyhjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVRVUFMUykge1xuICAgIHRoaXMuaGFuZGxlX2VxdWFscyhjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLk9QRVJBVE9SKSB7XG4gICAgdGhpcy5oYW5kbGVfb3BlcmF0b3IoY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5DT01NQSkge1xuICAgIHRoaXMuaGFuZGxlX2NvbW1hKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uQkxPQ0tfQ09NTUVOVCkge1xuICAgIHRoaXMuaGFuZGxlX2Jsb2NrX2NvbW1lbnQoY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1FTlQpIHtcbiAgICB0aGlzLmhhbmRsZV9jb21tZW50KGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5ET1QpIHtcbiAgICB0aGlzLmhhbmRsZV9kb3QoY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5FT0YpIHtcbiAgICB0aGlzLmhhbmRsZV9lb2YoY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5VTktOT1dOKSB7XG4gICAgdGhpcy5oYW5kbGVfdW5rbm93bihjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaGFuZGxlX3Vua25vd24oY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gIHZhciBuZXdsaW5lcyA9IGN1cnJlbnRfdG9rZW4ubmV3bGluZXM7XG4gIHZhciBrZWVwX3doaXRlc3BhY2UgPSB0aGlzLl9vcHRpb25zLmtlZXBfYXJyYXlfaW5kZW50YXRpb24gJiYgaXNfYXJyYXkodGhpcy5fZmxhZ3MubW9kZSk7XG5cbiAgaWYgKGN1cnJlbnRfdG9rZW4uY29tbWVudHNfYmVmb3JlKSB7XG4gICAgdmFyIGNvbW1lbnRfdG9rZW4gPSBjdXJyZW50X3Rva2VuLmNvbW1lbnRzX2JlZm9yZS5uZXh0KCk7XG4gICAgd2hpbGUgKGNvbW1lbnRfdG9rZW4pIHtcbiAgICAgIC8vIFRoZSBjbGVhbmVzdCBoYW5kbGluZyBvZiBpbmxpbmUgY29tbWVudHMgaXMgdG8gdHJlYXQgdGhlbSBhcyB0aG91Z2ggdGhleSBhcmVuJ3QgdGhlcmUuXG4gICAgICAvLyBKdXN0IGNvbnRpbnVlIGZvcm1hdHRpbmcgYW5kIHRoZSBiZWhhdmlvciBzaG91bGQgYmUgbG9naWNhbC5cbiAgICAgIC8vIEFsc28gaWdub3JlIHVua25vd24gdG9rZW5zLiAgQWdhaW4sIHRoaXMgc2hvdWxkIHJlc3VsdCBpbiBiZXR0ZXIgYmVoYXZpb3IuXG4gICAgICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjb21tZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgdGhpcy5oYW5kbGVfdG9rZW4oY29tbWVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgIGNvbW1lbnRfdG9rZW4gPSBjdXJyZW50X3Rva2VuLmNvbW1lbnRzX2JlZm9yZS5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGtlZXBfd2hpdGVzcGFjZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3bGluZXM7IGkgKz0gMSkge1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKGkgPiAwLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5tYXhfcHJlc2VydmVfbmV3bGluZXMgJiYgbmV3bGluZXMgPiB0aGlzLl9vcHRpb25zLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcykge1xuICAgICAgbmV3bGluZXMgPSB0aGlzLl9vcHRpb25zLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcykge1xuICAgICAgaWYgKG5ld2xpbmVzID4gMSkge1xuICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgbmV3bGluZXM7IGogKz0gMSkge1xuICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSh0cnVlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbnZhciBuZXdsaW5lX3Jlc3RyaWN0ZWRfdG9rZW5zID0gWydhc3luYycsICdicmVhaycsICdjb250aW51ZScsICdyZXR1cm4nLCAndGhyb3cnLCAneWllbGQnXTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4sIGZvcmNlX2xpbmV3cmFwKSB7XG4gIGZvcmNlX2xpbmV3cmFwID0gKGZvcmNlX2xpbmV3cmFwID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBmb3JjZV9saW5ld3JhcDtcblxuICAvLyBOZXZlciB3cmFwIHRoZSBmaXJzdCB0b2tlbiBvbiBhIGxpbmVcbiAgaWYgKHRoaXMuX291dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzaG91bGRQcmVzZXJ2ZU9yRm9yY2UgPSAodGhpcy5fb3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcyAmJiBjdXJyZW50X3Rva2VuLm5ld2xpbmVzKSB8fCBmb3JjZV9saW5ld3JhcDtcbiAgdmFyIG9wZXJhdG9yTG9naWNBcHBsaWVzID0gaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0LCBwb3NpdGlvbmFibGVfb3BlcmF0b3JzKSB8fFxuICAgIGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgcG9zaXRpb25hYmxlX29wZXJhdG9ycyk7XG5cbiAgaWYgKG9wZXJhdG9yTG9naWNBcHBsaWVzKSB7XG4gICAgdmFyIHNob3VsZFByaW50T3BlcmF0b3JOZXdsaW5lID0gKFxuICAgICAgICBpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIHBvc2l0aW9uYWJsZV9vcGVyYXRvcnMpICYmXG4gICAgICAgIGluX2FycmF5KHRoaXMuX29wdGlvbnMub3BlcmF0b3JfcG9zaXRpb24sIE9QRVJBVE9SX1BPU0lUSU9OX0JFRk9SRV9PUl9QUkVTRVJWRSlcbiAgICAgICkgfHxcbiAgICAgIGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgcG9zaXRpb25hYmxlX29wZXJhdG9ycyk7XG4gICAgc2hvdWxkUHJlc2VydmVPckZvcmNlID0gc2hvdWxkUHJlc2VydmVPckZvcmNlICYmIHNob3VsZFByaW50T3BlcmF0b3JOZXdsaW5lO1xuICB9XG5cbiAgaWYgKHNob3VsZFByZXNlcnZlT3JGb3JjZSkge1xuICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy53cmFwX2xpbmVfbGVuZ3RoKSB7XG4gICAgaWYgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIG5ld2xpbmVfcmVzdHJpY3RlZF90b2tlbnMpKSB7XG4gICAgICAvLyBUaGVzZSB0b2tlbnMgc2hvdWxkIG5ldmVyIGhhdmUgYSBuZXdsaW5lIGluc2VydGVkXG4gICAgICAvLyBiZXR3ZWVuIHRoZW0gYW5kIHRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbi5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fb3V0cHV0LnNldF93cmFwX3BvaW50KCk7XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLnByaW50X25ld2xpbmUgPSBmdW5jdGlvbihmb3JjZV9uZXdsaW5lLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgaWYgKCFwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ICE9PSAnOycgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ICE9PSAnLCcgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ICE9PSAnPScgJiYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSAhPT0gVE9LRU4uT1BFUkFUT1IgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnLS0nIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJysrJykpIHtcbiAgICAgIHZhciBuZXh0X3Rva2VuID0gdGhpcy5fdG9rZW5zLnBlZWsoKTtcbiAgICAgIHdoaWxlICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCAmJlxuICAgICAgICAhKHRoaXMuX2ZsYWdzLmlmX2Jsb2NrICYmIHJlc2VydmVkX3dvcmQobmV4dF90b2tlbiwgJ2Vsc2UnKSkgJiZcbiAgICAgICAgIXRoaXMuX2ZsYWdzLmRvX2Jsb2NrKSB7XG4gICAgICAgIHRoaXMucmVzdG9yZV9tb2RlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoZm9yY2VfbmV3bGluZSkpIHtcbiAgICB0aGlzLl9mbGFncy5tdWx0aWxpbmVfZnJhbWUgPSB0cnVlO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5wcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICBpZiAodGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgaWYgKHRoaXMuX29wdGlvbnMua2VlcF9hcnJheV9pbmRlbnRhdGlvbiAmJlxuICAgICAgY3VycmVudF90b2tlbi5uZXdsaW5lcyAmJlxuICAgICAgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ1snIHx8IGlzX2FycmF5KHRoaXMuX2ZsYWdzLm1vZGUpKSkge1xuICAgICAgdGhpcy5fb3V0cHV0LmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KC0xKTtcbiAgICAgIHRoaXMuX291dHB1dC5jdXJyZW50X2xpbmUucHVzaChjdXJyZW50X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlKTtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX291dHB1dC5zZXRfaW5kZW50KHRoaXMuX2ZsYWdzLmluZGVudGF0aW9uX2xldmVsLCB0aGlzLl9mbGFncy5hbGlnbm1lbnQpKSB7XG4gICAgICB0aGlzLl9mbGFncy5saW5lX2luZGVudF9sZXZlbCA9IHRoaXMuX2ZsYWdzLmluZGVudGF0aW9uX2xldmVsO1xuICAgIH1cbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUucHJpbnRfdG9rZW4gPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIGlmICh0aGlzLl9vdXRwdXQucmF3KSB7XG4gICAgdGhpcy5fb3V0cHV0LmFkZF9yYXdfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuX29wdGlvbnMuY29tbWFfZmlyc3QgJiYgY3VycmVudF90b2tlbi5wcmV2aW91cyAmJiBjdXJyZW50X3Rva2VuLnByZXZpb3VzLnR5cGUgPT09IFRPS0VOLkNPTU1BICYmXG4gICAgdGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgaWYgKHRoaXMuX291dHB1dC5wcmV2aW91c19saW5lLmxhc3QoKSA9PT0gJywnKSB7XG4gICAgICB2YXIgcG9wcGVkID0gdGhpcy5fb3V0cHV0LnByZXZpb3VzX2xpbmUucG9wKCk7XG4gICAgICAvLyBpZiB0aGUgY29tbWEgd2FzIGFscmVhZHkgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLFxuICAgICAgLy8gcHVsbCBiYWNrIG9udG8gdGhhdCBsaW5lIGFuZCByZXByaW50IHRoZSBpbmRlbnRhdGlvblxuICAgICAgaWYgKHRoaXMuX291dHB1dC5wcmV2aW91c19saW5lLmlzX2VtcHR5KCkpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnByZXZpb3VzX2xpbmUucHVzaChwb3BwZWQpO1xuICAgICAgICB0aGlzLl9vdXRwdXQudHJpbSh0cnVlKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0LmN1cnJlbnRfbGluZS5wb3AoKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnRyaW0oKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIHRoZSBjb21tYSBpbiBmcm9udCBvZiB0aGUgbmV4dCB0b2tlblxuICAgICAgdGhpcy5wcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgdGhpcy5fb3V0cHV0LmFkZF90b2tlbignLCcpO1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5wcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLl9vdXRwdXQubm9uX2JyZWFraW5nX3NwYWNlID0gdHJ1ZTtcbiAgdGhpcy5fb3V0cHV0LmFkZF90b2tlbihjdXJyZW50X3Rva2VuLnRleHQpO1xuICBpZiAodGhpcy5fb3V0cHV0LnByZXZpb3VzX3Rva2VuX3dyYXBwZWQpIHtcbiAgICB0aGlzLl9mbGFncy5tdWx0aWxpbmVfZnJhbWUgPSB0cnVlO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwgKz0gMTtcbiAgdGhpcy5fb3V0cHV0LnNldF9pbmRlbnQodGhpcy5fZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwsIHRoaXMuX2ZsYWdzLmFsaWdubWVudCk7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5kZWluZGVudCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwgPiAwICYmXG4gICAgKCghdGhpcy5fZmxhZ3MucGFyZW50KSB8fCB0aGlzLl9mbGFncy5pbmRlbnRhdGlvbl9sZXZlbCA+IHRoaXMuX2ZsYWdzLnBhcmVudC5pbmRlbnRhdGlvbl9sZXZlbCkpIHtcbiAgICB0aGlzLl9mbGFncy5pbmRlbnRhdGlvbl9sZXZlbCAtPSAxO1xuICAgIHRoaXMuX291dHB1dC5zZXRfaW5kZW50KHRoaXMuX2ZsYWdzLmluZGVudGF0aW9uX2xldmVsLCB0aGlzLl9mbGFncy5hbGlnbm1lbnQpO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5zZXRfbW9kZSA9IGZ1bmN0aW9uKG1vZGUpIHtcbiAgaWYgKHRoaXMuX2ZsYWdzKSB7XG4gICAgdGhpcy5fZmxhZ19zdG9yZS5wdXNoKHRoaXMuX2ZsYWdzKTtcbiAgICB0aGlzLl9wcmV2aW91c19mbGFncyA9IHRoaXMuX2ZsYWdzO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3ByZXZpb3VzX2ZsYWdzID0gdGhpcy5jcmVhdGVfZmxhZ3MobnVsbCwgbW9kZSk7XG4gIH1cblxuICB0aGlzLl9mbGFncyA9IHRoaXMuY3JlYXRlX2ZsYWdzKHRoaXMuX3ByZXZpb3VzX2ZsYWdzLCBtb2RlKTtcbiAgdGhpcy5fb3V0cHV0LnNldF9pbmRlbnQodGhpcy5fZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwsIHRoaXMuX2ZsYWdzLmFsaWdubWVudCk7XG59O1xuXG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLnJlc3RvcmVfbW9kZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmxhZ19zdG9yZS5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5fcHJldmlvdXNfZmxhZ3MgPSB0aGlzLl9mbGFncztcbiAgICB0aGlzLl9mbGFncyA9IHRoaXMuX2ZsYWdfc3RvcmUucG9wKCk7XG4gICAgaWYgKHRoaXMuX3ByZXZpb3VzX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSB7XG4gICAgICByZW1vdmVfcmVkdW5kYW50X2luZGVudGF0aW9uKHRoaXMuX291dHB1dCwgdGhpcy5fcHJldmlvdXNfZmxhZ3MpO1xuICAgIH1cbiAgICB0aGlzLl9vdXRwdXQuc2V0X2luZGVudCh0aGlzLl9mbGFncy5pbmRlbnRhdGlvbl9sZXZlbCwgdGhpcy5fZmxhZ3MuYWxpZ25tZW50KTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9mbGFncy5wYXJlbnQubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsICYmIHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50ICYmIChcbiAgICAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnOicgJiYgdGhpcy5fZmxhZ3MudGVybmFyeV9kZXB0aCA9PT0gMCkgfHwgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIFsnZ2V0JywgJ3NldCddKSkpO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuc3RhcnRfb2Zfc3RhdGVtZW50ID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICB2YXIgc3RhcnQgPSBmYWxzZTtcbiAgc3RhcnQgPSBzdGFydCB8fCByZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBbJ3ZhcicsICdsZXQnLCAnY29uc3QnXSkgJiYgY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5XT1JEO1xuICBzdGFydCA9IHN0YXJ0IHx8IHJlc2VydmVkX3dvcmQodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgJ2RvJyk7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgKCEodGhpcy5fZmxhZ3MucGFyZW50Lm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCAmJiB0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkpICYmIHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIG5ld2xpbmVfcmVzdHJpY3RlZF90b2tlbnMpICYmICFjdXJyZW50X3Rva2VuLm5ld2xpbmVzO1xuICBzdGFydCA9IHN0YXJ0IHx8IHJlc2VydmVkX3dvcmQodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgJ2Vsc2UnKSAmJlxuICAgICEocmVzZXJ2ZWRfd29yZChjdXJyZW50X3Rva2VuLCAnaWYnKSAmJiAhY3VycmVudF90b2tlbi5jb21tZW50c19iZWZvcmUpO1xuICBzdGFydCA9IHN0YXJ0IHx8ICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9FWFBSICYmICh0aGlzLl9wcmV2aW91c19mbGFncy5tb2RlID09PSBNT0RFLkZvckluaXRpYWxpemVyIHx8IHRoaXMuX3ByZXZpb3VzX2ZsYWdzLm1vZGUgPT09IE1PREUuQ29uZGl0aW9uYWwpKTtcbiAgc3RhcnQgPSBzdGFydCB8fCAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5XT1JEICYmIHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuQmxvY2tTdGF0ZW1lbnQgJiZcbiAgICAhdGhpcy5fZmxhZ3MuaW5fY2FzZSAmJlxuICAgICEoY3VycmVudF90b2tlbi50ZXh0ID09PSAnLS0nIHx8IGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJysrJykgJiZcbiAgICB0aGlzLl9sYXN0X2xhc3RfdGV4dCAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGN1cnJlbnRfdG9rZW4udHlwZSAhPT0gVE9LRU4uV09SRCAmJiBjdXJyZW50X3Rva2VuLnR5cGUgIT09IFRPS0VOLlJFU0VSVkVEKTtcbiAgc3RhcnQgPSBzdGFydCB8fCAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsICYmIChcbiAgICAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnOicgJiYgdGhpcy5fZmxhZ3MudGVybmFyeV9kZXB0aCA9PT0gMCkgfHwgcmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgWydnZXQnLCAnc2V0J10pKSk7XG5cbiAgaWYgKHN0YXJ0KSB7XG4gICAgdGhpcy5zZXRfbW9kZShNT0RFLlN0YXRlbWVudCk7XG4gICAgdGhpcy5pbmRlbnQoKTtcblxuICAgIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4sIHRydWUpO1xuXG4gICAgLy8gSXNzdWUgIzI3NjpcbiAgICAvLyBJZiBzdGFydGluZyBhIG5ldyBzdGF0ZW1lbnQgd2l0aCBbaWYsIGZvciwgd2hpbGUsIGRvXSwgcHVzaCB0byBhIG5ldyBsaW5lLlxuICAgIC8vIGlmIChhKSBpZiAoYikgaWYoYykgZCgpOyBlbHNlIGUoKTsgZWxzZSBmKCk7XG4gICAgaWYgKCF0aGlzLnN0YXJ0X29mX29iamVjdF9wcm9wZXJ0eSgpKSB7XG4gICAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbixcbiAgICAgICAgcmVzZXJ2ZWRfYXJyYXkoY3VycmVudF90b2tlbiwgWydkbycsICdmb3InLCAnaWYnLCAnd2hpbGUnXSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfc3RhcnRfZXhwciA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICBpZiAoIXRoaXMuc3RhcnRfb2Zfc3RhdGVtZW50KGN1cnJlbnRfdG9rZW4pKSB7XG4gICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gIH1cblxuICB2YXIgbmV4dF9tb2RlID0gTU9ERS5FeHByZXNzaW9uO1xuICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnWycpIHtcblxuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnKScpIHtcbiAgICAgIC8vIHRoaXMgaXMgYXJyYXkgaW5kZXggc3BlY2lmaWVyLCBicmVhayBpbW1lZGlhdGVseVxuICAgICAgLy8gYVt4XSwgZm4oKVt4XVxuICAgICAgaWYgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIGxpbmVfc3RhcnRlcnMpKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICAgIHRoaXMuc2V0X21vZGUobmV4dF9tb2RlKTtcbiAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5zcGFjZV9pbl9wYXJlbikge1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuZXh0X21vZGUgPSBNT0RFLkFycmF5TGl0ZXJhbDtcbiAgICBpZiAoaXNfYXJyYXkodGhpcy5fZmxhZ3MubW9kZSkpIHtcbiAgICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICdbJyB8fFxuICAgICAgICAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnLCcgJiYgKHRoaXMuX2xhc3RfbGFzdF90ZXh0ID09PSAnXScgfHwgdGhpcy5fbGFzdF9sYXN0X3RleHQgPT09ICd9JykpKSB7XG4gICAgICAgIC8vIF0sIFsgZ29lcyB0byBuZXcgbGluZVxuICAgICAgICAvLyB9LCBbIGdvZXMgdG8gbmV3IGxpbmVcbiAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmtlZXBfYXJyYXlfaW5kZW50YXRpb24pIHtcbiAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlLCBbVE9LRU4uU1RBUlRfRVhQUiwgVE9LRU4uRU5EX0VYUFIsIFRPS0VOLldPUkQsIFRPS0VOLk9QRVJBVE9SLCBUT0tFTi5ET1RdKSkge1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEKSB7XG4gICAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnZm9yJykge1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdGhpcy5fb3B0aW9ucy5zcGFjZV9iZWZvcmVfY29uZGl0aW9uYWw7XG4gICAgICAgIG5leHRfbW9kZSA9IE1PREUuRm9ySW5pdGlhbGl6ZXI7XG4gICAgICB9IGVsc2UgaWYgKGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCwgWydpZicsICd3aGlsZScsICdzd2l0Y2gnXSkpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRoaXMuX29wdGlvbnMuc3BhY2VfYmVmb3JlX2NvbmRpdGlvbmFsO1xuICAgICAgICBuZXh0X21vZGUgPSBNT0RFLkNvbmRpdGlvbmFsO1xuICAgICAgfSBlbHNlIGlmIChpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3dvcmQsIFsnYXdhaXQnLCAnYXN5bmMnXSkpIHtcbiAgICAgICAgLy8gU2hvdWxkIGJlIGEgc3BhY2UgYmV0d2VlbiBhd2FpdCBhbmQgYW4gSUlGRSwgb3IgYXN5bmMgYW5kIGFuIGFycm93IGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICdpbXBvcnQnICYmIGN1cnJlbnRfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUgPT09ICcnKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0LCBsaW5lX3N0YXJ0ZXJzKSB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICdjYXRjaCcpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVRVUFMUyB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLk9QRVJBVE9SKSB7XG4gICAgICAvLyBTdXBwb3J0IG9mIHRoaXMga2luZCBvZiBuZXdsaW5lIHByZXNlcnZhdGlvbi5cbiAgICAgIC8vIGEgPSAoYiAmJlxuICAgICAgLy8gICAgIChjIHx8IGQpKTtcbiAgICAgIGlmICghdGhpcy5zdGFydF9vZl9vYmplY3RfcHJvcGVydHkoKSkge1xuICAgICAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQpIHtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcblxuICAgICAgLy8gZnVuY3Rpb24gbmFtZSgpIHZzIGZ1bmN0aW9uIG5hbWUgKClcbiAgICAgIC8vIGZ1bmN0aW9uKiBuYW1lKCkgdnMgZnVuY3Rpb24qIG5hbWUgKClcbiAgICAgIC8vIGFzeW5jIG5hbWUoKSB2cyBhc3luYyBuYW1lICgpXG4gICAgICAvLyBJbiBFUzYsIHlvdSBjYW4gYWxzbyBkZWZpbmUgdGhlIG1ldGhvZCBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdFxuICAgICAgLy8gdmFyIG9iaiA9IHthOiBmdW5jdGlvbigpIHt9fVxuICAgICAgLy8gSXQgY2FuIGJlIGFiYnJldmlhdGVkXG4gICAgICAvLyB2YXIgb2JqID0ge2EoKSB7fX1cbiAgICAgIC8vIHZhciBvYmogPSB7IGEoKSB7fX0gdnMgdmFyIG9iaiA9IHsgYSAoKSB7fX1cbiAgICAgIC8vIHZhciBvYmogPSB7ICogYSgpIHt9fSB2cyB2YXIgb2JqID0geyAqIGEgKCkge319XG4gICAgICB2YXIgcGVla19iYWNrX3R3byA9IHRoaXMuX3Rva2Vucy5wZWVrKC0zKTtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLnNwYWNlX2FmdGVyX25hbWVkX2Z1bmN0aW9uICYmIHBlZWtfYmFja190d28pIHtcbiAgICAgICAgLy8gcGVlayBzdGFydHMgYXQgbmV4dCBjaGFyYWN0ZXIgc28gLTEgaXMgY3VycmVudCB0b2tlblxuICAgICAgICB2YXIgcGVla19iYWNrX3RocmVlID0gdGhpcy5fdG9rZW5zLnBlZWsoLTQpO1xuICAgICAgICBpZiAocmVzZXJ2ZWRfYXJyYXkocGVla19iYWNrX3R3bywgWydhc3luYycsICdmdW5jdGlvbiddKSB8fFxuICAgICAgICAgIChwZWVrX2JhY2tfdHdvLnRleHQgPT09ICcqJyAmJiByZXNlcnZlZF9hcnJheShwZWVrX2JhY2tfdGhyZWUsIFsnYXN5bmMnLCAnZnVuY3Rpb24nXSkpKSB7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsKSB7XG4gICAgICAgICAgaWYgKChwZWVrX2JhY2tfdHdvLnRleHQgPT09ICd7JyB8fCBwZWVrX2JhY2tfdHdvLnRleHQgPT09ICcsJykgfHxcbiAgICAgICAgICAgIChwZWVrX2JhY2tfdHdvLnRleHQgPT09ICcqJyAmJiAocGVla19iYWNrX3RocmVlLnRleHQgPT09ICd7JyB8fCBwZWVrX2JhY2tfdGhyZWUudGV4dCA9PT0gJywnKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5wYXJlbnQgJiYgdGhpcy5fZmxhZ3MucGFyZW50LmNsYXNzX3N0YXJ0X2Jsb2NrKSB7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3VwcG9ydCBwcmVzZXJ2aW5nIHdyYXBwZWQgYXJyb3cgZnVuY3Rpb24gZXhwcmVzc2lvbnNcbiAgICAgIC8vIGEuYignYycsXG4gICAgICAvLyAgICAgKCkgPT4gZC5lXG4gICAgICAvLyApXG4gICAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgfVxuXG4gICAgLy8gZnVuY3Rpb24oKSB2cyBmdW5jdGlvbiAoKVxuICAgIC8vIHlpZWxkKigpIHZzIHlpZWxkKiAoKVxuICAgIC8vIGZ1bmN0aW9uKigpIHZzIGZ1bmN0aW9uKiAoKVxuICAgIGlmICgodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCAmJiAodGhpcy5fZmxhZ3MubGFzdF93b3JkID09PSAnZnVuY3Rpb24nIHx8IHRoaXMuX2ZsYWdzLmxhc3Rfd29yZCA9PT0gJ3R5cGVvZicpKSB8fFxuICAgICAgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJyonICYmXG4gICAgICAgIChpbl9hcnJheSh0aGlzLl9sYXN0X2xhc3RfdGV4dCwgWydmdW5jdGlvbicsICd5aWVsZCddKSB8fFxuICAgICAgICAgICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwgJiYgaW5fYXJyYXkodGhpcy5fbGFzdF9sYXN0X3RleHQsIFsneycsICcsJ10pKSkpKSB7XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdGhpcy5fb3B0aW9ucy5zcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICc7JyB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0JMT0NLKSB7XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfRVhQUiB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0VYUFIgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfQkxPQ0sgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnLicgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5DT01NQSkge1xuICAgIC8vIGRvIG5vdGhpbmcgb24gKCggYW5kICkoIGFuZCBdWyBhbmQgXSggYW5kIC4oXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgd2hldGhlciBmb3JjaW5nIHRoaXMgaXMgcmVxdWlyZWQuICBSZXZpZXcgZmFpbGluZyB0ZXN0cyB3aGVuIHJlbW92ZWQuXG4gICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4sIGN1cnJlbnRfdG9rZW4ubmV3bGluZXMpO1xuICB9XG5cbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgdGhpcy5zZXRfbW9kZShuZXh0X21vZGUpO1xuICBpZiAodGhpcy5fb3B0aW9ucy5zcGFjZV9pbl9wYXJlbikge1xuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICB9XG5cbiAgLy8gSW4gYWxsIGNhc2VzLCBpZiB3ZSBuZXdsaW5lIHdoaWxlIGluc2lkZSBhbiBleHByZXNzaW9uIGl0IHNob3VsZCBiZSBpbmRlbnRlZC5cbiAgdGhpcy5pbmRlbnQoKTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9lbmRfZXhwciA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgLy8gc3RhdGVtZW50cyBpbnNpZGUgZXhwcmVzc2lvbnMgYXJlIG5vdCB2YWxpZCBzeW50YXgsIGJ1dC4uLlxuICAvLyBzdGF0ZW1lbnRzIG11c3QgYWxsIGJlIGNsb3NlZCB3aGVuIHRoZWlyIGNvbnRhaW5lciBjbG9zZXNcbiAgd2hpbGUgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSB7XG4gICAgdGhpcy5yZXN0b3JlX21vZGUoKTtcbiAgfVxuXG4gIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuXG4gIGlmICh0aGlzLl9mbGFncy5tdWx0aWxpbmVfZnJhbWUpIHtcbiAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbixcbiAgICAgIGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ10nICYmIGlzX2FycmF5KHRoaXMuX2ZsYWdzLm1vZGUpICYmICF0aGlzLl9vcHRpb25zLmtlZXBfYXJyYXlfaW5kZW50YXRpb24pO1xuICB9XG5cbiAgaWYgKHRoaXMuX29wdGlvbnMuc3BhY2VfaW5fcGFyZW4pIHtcbiAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9FWFBSICYmICF0aGlzLl9vcHRpb25zLnNwYWNlX2luX2VtcHR5X3BhcmVuKSB7XG4gICAgICAvLyAoKSBbXSBubyBpbm5lciBzcGFjZSBpbiBlbXB0eSBwYXJlbnMgbGlrZSB0aGVzZSwgZXZlciwgcmVmICMzMjBcbiAgICAgIHRoaXMuX291dHB1dC50cmltKCk7XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH1cbiAgfVxuICB0aGlzLmRlaW5kZW50KCk7XG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gIHRoaXMucmVzdG9yZV9tb2RlKCk7XG5cbiAgcmVtb3ZlX3JlZHVuZGFudF9pbmRlbnRhdGlvbih0aGlzLl9vdXRwdXQsIHRoaXMuX3ByZXZpb3VzX2ZsYWdzKTtcblxuICAvLyBkbyB7fSB3aGlsZSAoKSAvLyBubyBzdGF0ZW1lbnQgcmVxdWlyZWQgYWZ0ZXJcbiAgaWYgKHRoaXMuX2ZsYWdzLmRvX3doaWxlICYmIHRoaXMuX3ByZXZpb3VzX2ZsYWdzLm1vZGUgPT09IE1PREUuQ29uZGl0aW9uYWwpIHtcbiAgICB0aGlzLl9wcmV2aW91c19mbGFncy5tb2RlID0gTU9ERS5FeHByZXNzaW9uO1xuICAgIHRoaXMuX2ZsYWdzLmRvX2Jsb2NrID0gZmFsc2U7XG4gICAgdGhpcy5fZmxhZ3MuZG9fd2hpbGUgPSBmYWxzZTtcblxuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfc3RhcnRfYmxvY2sgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuXG4gIC8vIENoZWNrIGlmIHRoaXMgaXMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSBPYmplY3RMaXRlcmFsXG4gIHZhciBuZXh0X3Rva2VuID0gdGhpcy5fdG9rZW5zLnBlZWsoKTtcbiAgdmFyIHNlY29uZF90b2tlbiA9IHRoaXMuX3Rva2Vucy5wZWVrKDEpO1xuICBpZiAodGhpcy5fZmxhZ3MubGFzdF93b3JkID09PSAnc3dpdGNoJyAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9FWFBSKSB7XG4gICAgdGhpcy5zZXRfbW9kZShNT0RFLkJsb2NrU3RhdGVtZW50KTtcbiAgICB0aGlzLl9mbGFncy5pbl9jYXNlX3N0YXRlbWVudCA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MuY2FzZV9ib2R5KSB7XG4gICAgdGhpcy5zZXRfbW9kZShNT0RFLkJsb2NrU3RhdGVtZW50KTtcbiAgfSBlbHNlIGlmIChzZWNvbmRfdG9rZW4gJiYgKFxuICAgICAgKGluX2FycmF5KHNlY29uZF90b2tlbi50ZXh0LCBbJzonLCAnLCddKSAmJiBpbl9hcnJheShuZXh0X3Rva2VuLnR5cGUsIFtUT0tFTi5TVFJJTkcsIFRPS0VOLldPUkQsIFRPS0VOLlJFU0VSVkVEXSkpIHx8XG4gICAgICAoaW5fYXJyYXkobmV4dF90b2tlbi50ZXh0LCBbJ2dldCcsICdzZXQnLCAnLi4uJ10pICYmIGluX2FycmF5KHNlY29uZF90b2tlbi50eXBlLCBbVE9LRU4uV09SRCwgVE9LRU4uUkVTRVJWRURdKSlcbiAgICApKSB7XG4gICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBUeXBlU2NyaXB0LGJ1dCB3ZSBkaWRuJ3QgYnJlYWsgaXQgZm9yIGEgdmVyeSBsb25nIHRpbWUuXG4gICAgLy8gV2UnbGwgdHJ5IHRvIGtlZXAgbm90IGJyZWFraW5nIGl0LlxuICAgIGlmIChpbl9hcnJheSh0aGlzLl9sYXN0X2xhc3RfdGV4dCwgWydjbGFzcycsICdpbnRlcmZhY2UnXSkgJiYgIWluX2FycmF5KHNlY29uZF90b2tlbi50ZXh0LCBbJzonLCAnLCddKSkge1xuICAgICAgdGhpcy5zZXRfbW9kZShNT0RFLkJsb2NrU3RhdGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRfbW9kZShNT0RFLk9iamVjdExpdGVyYWwpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLk9QRVJBVE9SICYmIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJz0+Jykge1xuICAgIC8vIGFycm93IGZ1bmN0aW9uOiAocGFyYW0xLCBwYXJhbU4pID0+IHsgc3RhdGVtZW50cyB9XG4gICAgdGhpcy5zZXRfbW9kZShNT0RFLkJsb2NrU3RhdGVtZW50KTtcbiAgfSBlbHNlIGlmIChpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUsIFtUT0tFTi5FUVVBTFMsIFRPS0VOLlNUQVJUX0VYUFIsIFRPS0VOLkNPTU1BLCBUT0tFTi5PUEVSQVRPUl0pIHx8XG4gICAgcmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgWydyZXR1cm4nLCAndGhyb3cnLCAnaW1wb3J0JywgJ2RlZmF1bHQnXSlcbiAgKSB7XG4gICAgLy8gRGV0ZWN0aW5nIHNob3J0aGFuZCBmdW5jdGlvbiBzeW50YXggaXMgZGlmZmljdWx0IGJ5IHNjYW5uaW5nIGZvcndhcmQsXG4gICAgLy8gICAgIHNvIGNoZWNrIHRoZSBzdXJyb3VuZGluZyBjb250ZXh0LlxuICAgIC8vIElmIHRoZSBibG9jayBpcyBiZWluZyByZXR1cm5lZCwgaW1wb3J0ZWQsIGV4cG9ydCBkZWZhdWx0LCBwYXNzZWQgYXMgYXJnLFxuICAgIC8vICAgICBhc3NpZ25lZCB3aXRoID0gb3IgYXNzaWduZWQgaW4gYSBuZXN0ZWQgb2JqZWN0LCB0cmVhdCBhcyBhbiBPYmplY3RMaXRlcmFsLlxuICAgIHRoaXMuc2V0X21vZGUoTU9ERS5PYmplY3RMaXRlcmFsKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNldF9tb2RlKE1PREUuQmxvY2tTdGF0ZW1lbnQpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4pIHtcbiAgICBpZiAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi5wcmV2aW91cywgWydjbGFzcycsICdleHRlbmRzJ10pKSB7XG4gICAgICB0aGlzLl9mbGFncy5jbGFzc19zdGFydF9ibG9jayA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVtcHR5X2JyYWNlcyA9ICFuZXh0X3Rva2VuLmNvbW1lbnRzX2JlZm9yZSAmJiBuZXh0X3Rva2VuLnRleHQgPT09ICd9JztcbiAgdmFyIGVtcHR5X2Fub255bW91c19mdW5jdGlvbiA9IGVtcHR5X2JyYWNlcyAmJiB0aGlzLl9mbGFncy5sYXN0X3dvcmQgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9FWFBSO1xuXG4gIGlmICh0aGlzLl9vcHRpb25zLmJyYWNlX3ByZXNlcnZlX2lubGluZSkgLy8gY2hlY2sgZm9yIGlubGluZSwgc2V0IGlubGluZV9mcmFtZSBpZiBzb1xuICB7XG4gICAgLy8gc2VhcmNoIGZvcndhcmQgZm9yIGEgbmV3bGluZSB3YW50ZWQgaW5zaWRlIHRoaXMgYmxvY2tcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjaGVja190b2tlbiA9IG51bGw7XG4gICAgdGhpcy5fZmxhZ3MuaW5saW5lX2ZyYW1lID0gdHJ1ZTtcbiAgICBkbyB7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgY2hlY2tfdG9rZW4gPSB0aGlzLl90b2tlbnMucGVlayhpbmRleCAtIDEpO1xuICAgICAgaWYgKGNoZWNrX3Rva2VuLm5ld2xpbmVzKSB7XG4gICAgICAgIHRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IHdoaWxlIChjaGVja190b2tlbi50eXBlICE9PSBUT0tFTi5FT0YgJiZcbiAgICAgICEoY2hlY2tfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0JMT0NLICYmIGNoZWNrX3Rva2VuLm9wZW5lZCA9PT0gY3VycmVudF90b2tlbikpO1xuICB9XG5cbiAgaWYgKCh0aGlzLl9vcHRpb25zLmJyYWNlX3N0eWxlID09PSBcImV4cGFuZFwiIHx8XG4gICAgICAodGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJub25lXCIgJiYgY3VycmVudF90b2tlbi5uZXdsaW5lcykpICYmXG4gICAgIXRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgIT09IFRPS0VOLk9QRVJBVE9SICYmXG4gICAgICAoZW1wdHlfYW5vbnltb3VzX2Z1bmN0aW9uIHx8XG4gICAgICAgIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRVFVQUxTIHx8XG4gICAgICAgIChyZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBzcGVjaWFsX3dvcmRzKSAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgIT09ICdlbHNlJykpKSB7XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gIH0gZWxzZSB7IC8vIGNvbGxhcHNlIHx8IGlubGluZV9mcmFtZVxuICAgIGlmIChpc19hcnJheSh0aGlzLl9wcmV2aW91c19mbGFncy5tb2RlKSAmJiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9FWFBSIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUEpKSB7XG4gICAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5DT01NQSB8fCB0aGlzLl9vcHRpb25zLnNwYWNlX2luX3BhcmVuKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5DT01NQSB8fCAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9FWFBSICYmIHRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkpIHtcbiAgICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICB0aGlzLl9wcmV2aW91c19mbGFncy5tdWx0aWxpbmVfZnJhbWUgPSB0aGlzLl9wcmV2aW91c19mbGFncy5tdWx0aWxpbmVfZnJhbWUgfHwgdGhpcy5fZmxhZ3MubXVsdGlsaW5lX2ZyYW1lO1xuICAgICAgICB0aGlzLl9mbGFncy5tdWx0aWxpbmVfZnJhbWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSAhPT0gVE9LRU4uT1BFUkFUT1IgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlICE9PSBUT0tFTi5TVEFSVF9FWFBSKSB7XG4gICAgICBpZiAoaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlLCBbVE9LRU4uU1RBUlRfQkxPQ0ssIFRPS0VOLlNFTUlDT0xPTl0pICYmICF0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgdGhpcy5pbmRlbnQoKTtcblxuICAvLyBFeGNlcHQgZm9yIHNwZWNpZmljIGNhc2VzLCBvcGVuIGJyYWNlcyBhcmUgZm9sbG93ZWQgYnkgYSBuZXcgbGluZS5cbiAgaWYgKCFlbXB0eV9icmFjZXMgJiYgISh0aGlzLl9vcHRpb25zLmJyYWNlX3ByZXNlcnZlX2lubGluZSAmJiB0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUpKSB7XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9lbmRfYmxvY2sgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIC8vIHN0YXRlbWVudHMgbXVzdCBhbGwgYmUgY2xvc2VkIHdoZW4gdGhlaXIgY29udGFpbmVyIGNsb3Nlc1xuICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcblxuICB3aGlsZSAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpIHtcbiAgICB0aGlzLnJlc3RvcmVfbW9kZSgpO1xuICB9XG5cbiAgdmFyIGVtcHR5X2JyYWNlcyA9IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfQkxPQ0s7XG5cbiAgaWYgKHRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSAmJiAhZW1wdHlfYnJhY2VzKSB7IC8vIHRyeSBpbmxpbmVfZnJhbWUgKG9ubHkgc2V0IGlmIHRoaXMuX29wdGlvbnMuYnJhY2VzLXByZXNlcnZlLWlubGluZSkgZmlyc3RcbiAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmJyYWNlX3N0eWxlID09PSBcImV4cGFuZFwiKSB7XG4gICAgaWYgKCFlbXB0eV9icmFjZXMpIHtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBza2lwIHt9XG4gICAgaWYgKCFlbXB0eV9icmFjZXMpIHtcbiAgICAgIGlmIChpc19hcnJheSh0aGlzLl9mbGFncy5tb2RlKSAmJiB0aGlzLl9vcHRpb25zLmtlZXBfYXJyYXlfaW5kZW50YXRpb24pIHtcbiAgICAgICAgLy8gd2UgUkVBTExZIG5lZWQgYSBuZXdsaW5lIGhlcmUsIGJ1dCBuZXdsaW5lciB3b3VsZCBza2lwIHRoYXRcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5rZWVwX2FycmF5X2luZGVudGF0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgICB0aGlzLl9vcHRpb25zLmtlZXBfYXJyYXlfaW5kZW50YXRpb24gPSB0cnVlO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGhpcy5yZXN0b3JlX21vZGUoKTtcbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV93b3JkID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCkge1xuICAgIGlmIChpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnc2V0JywgJ2dldCddKSAmJiB0aGlzLl9mbGFncy5tb2RlICE9PSBNT0RFLk9iamVjdExpdGVyYWwpIHtcbiAgICAgIGN1cnJlbnRfdG9rZW4udHlwZSA9IFRPS0VOLldPUkQ7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICdpbXBvcnQnICYmIGluX2FycmF5KHRoaXMuX3Rva2Vucy5wZWVrKCkudGV4dCwgWycoJywgJy4nXSkpIHtcbiAgICAgIGN1cnJlbnRfdG9rZW4udHlwZSA9IFRPS0VOLldPUkQ7XG4gICAgfSBlbHNlIGlmIChpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnYXMnLCAnZnJvbSddKSAmJiAhdGhpcy5fZmxhZ3MuaW1wb3J0X2Jsb2NrKSB7XG4gICAgICBjdXJyZW50X3Rva2VuLnR5cGUgPSBUT0tFTi5XT1JEO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsKSB7XG4gICAgICB2YXIgbmV4dF90b2tlbiA9IHRoaXMuX3Rva2Vucy5wZWVrKCk7XG4gICAgICBpZiAobmV4dF90b2tlbi50ZXh0ID09PSAnOicpIHtcbiAgICAgICAgY3VycmVudF90b2tlbi50eXBlID0gVE9LRU4uV09SRDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5zdGFydF9vZl9zdGF0ZW1lbnQoY3VycmVudF90b2tlbikpIHtcbiAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gICAgaWYgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIFsndmFyJywgJ2xldCcsICdjb25zdCddKSAmJiBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQpIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmRlY2xhcmF0aW9uX3N0YXRlbWVudCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4ubmV3bGluZXMgJiYgIWlzX2V4cHJlc3Npb24odGhpcy5fZmxhZ3MubW9kZSkgJiZcbiAgICAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlICE9PSBUT0tFTi5PUEVSQVRPUiB8fCAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnLS0nIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJysrJykpICYmXG4gICAgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlICE9PSBUT0tFTi5FUVVBTFMgJiZcbiAgICAodGhpcy5fb3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcyB8fCAhcmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgWyd2YXInLCAnbGV0JywgJ2NvbnN0JywgJ3NldCcsICdnZXQnXSkpKSB7XG4gICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gIH1cblxuICBpZiAodGhpcy5fZmxhZ3MuZG9fYmxvY2sgJiYgIXRoaXMuX2ZsYWdzLmRvX3doaWxlKSB7XG4gICAgaWYgKHJlc2VydmVkX3dvcmQoY3VycmVudF90b2tlbiwgJ3doaWxlJykpIHtcbiAgICAgIC8vIGRvIHt9ICMjIHdoaWxlICgpXG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2ZsYWdzLmRvX3doaWxlID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZG8ge30gc2hvdWxkIGFsd2F5cyBoYXZlIHdoaWxlIGFzIHRoZSBuZXh0IHdvcmQuXG4gICAgICAvLyBpZiB3ZSBkb24ndCBzZWUgdGhlIGV4cGVjdGVkIHdoaWxlLCByZWNvdmVyXG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICAgIHRoaXMuX2ZsYWdzLmRvX2Jsb2NrID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgbWF5IGJlIGZvbGxvd2VkIGJ5IGVsc2UsIG9yIG5vdFxuICAvLyBCYXJlL2lubGluZSBpZnMgYXJlIHRyaWNreVxuICAvLyBOZWVkIHRvIHVud2luZCB0aGUgbW9kZXMgY29ycmVjdGx5OiBpZiAoYSkgaWYgKGIpIGMoKTsgZWxzZSBkKCk7IGVsc2UgZSgpO1xuICBpZiAodGhpcy5fZmxhZ3MuaWZfYmxvY2spIHtcbiAgICBpZiAoIXRoaXMuX2ZsYWdzLmVsc2VfYmxvY2sgJiYgcmVzZXJ2ZWRfd29yZChjdXJyZW50X3Rva2VuLCAnZWxzZScpKSB7XG4gICAgICB0aGlzLl9mbGFncy5lbHNlX2Jsb2NrID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSB7XG4gICAgICAgIHRoaXMucmVzdG9yZV9tb2RlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9mbGFncy5pZl9ibG9jayA9IGZhbHNlO1xuICAgICAgdGhpcy5fZmxhZ3MuZWxzZV9ibG9jayA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9mbGFncy5pbl9jYXNlX3N0YXRlbWVudCAmJiByZXNlcnZlZF9hcnJheShjdXJyZW50X3Rva2VuLCBbJ2Nhc2UnLCAnZGVmYXVsdCddKSkge1xuICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgIGlmICghdGhpcy5fZmxhZ3MuY2FzZV9ibG9jayAmJiAodGhpcy5fZmxhZ3MuY2FzZV9ib2R5IHx8IHRoaXMuX29wdGlvbnMuanNsaW50X2hhcHB5KSkge1xuICAgICAgLy8gc3dpdGNoIGNhc2VzIGZvbGxvd2luZyBvbmUgYW5vdGhlclxuICAgICAgdGhpcy5kZWluZGVudCgpO1xuICAgIH1cbiAgICB0aGlzLl9mbGFncy5jYXNlX2JvZHkgPSBmYWxzZTtcblxuICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgdGhpcy5fZmxhZ3MuaW5fY2FzZSA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUEgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9FWFBSIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRVFVQUxTIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uT1BFUkFUT1IpIHtcbiAgICBpZiAoIXRoaXMuc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5KCkgJiYgIShcbiAgICAgICAgLy8gc3RhcnQgb2Ygb2JqZWN0IHByb3BlcnR5IGlzIGRpZmZlcmVudCBmb3IgbnVtZXJpYyB2YWx1ZXMgd2l0aCArLy0gcHJlZml4IG9wZXJhdG9yc1xuICAgICAgICBpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIFsnKycsICctJ10pICYmIHRoaXMuX2xhc3RfbGFzdF90ZXh0ID09PSAnOicgJiYgdGhpcy5fZmxhZ3MucGFyZW50Lm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCkpIHtcbiAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmVzZXJ2ZWRfd29yZChjdXJyZW50X3Rva2VuLCAnZnVuY3Rpb24nKSkge1xuICAgIGlmIChpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIFsnfScsICc7J10pIHx8XG4gICAgICAodGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpICYmICEoaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0LCBbJygnLCAnWycsICd7JywgJzonLCAnPScsICcsJ10pIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uT1BFUkFUT1IpKSkge1xuICAgICAgLy8gbWFrZSBzdXJlIHRoZXJlIGlzIGEgbmljZSBjbGVhbiBzcGFjZSBvZiBhdCBsZWFzdCBvbmUgYmxhbmsgbGluZVxuICAgICAgLy8gYmVmb3JlIGEgbmV3IGZ1bmN0aW9uIGRlZmluaXRpb25cbiAgICAgIGlmICghdGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfYmxhbmtsaW5lKCkgJiYgIWN1cnJlbnRfdG9rZW4uY29tbWVudHNfYmVmb3JlKSB7XG4gICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgICB0aGlzLnByaW50X25ld2xpbmUodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uV09SRCkge1xuICAgICAgaWYgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIFsnZ2V0JywgJ3NldCcsICduZXcnLCAnZXhwb3J0J10pIHx8XG4gICAgICAgIHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIG5ld2xpbmVfcmVzdHJpY3RlZF90b2tlbnMpKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChyZXNlcnZlZF93b3JkKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sICdkZWZhdWx0JykgJiYgdGhpcy5fbGFzdF9sYXN0X3RleHQgPT09ICdleHBvcnQnKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICdkZWNsYXJlJykge1xuICAgICAgICAvLyBhY2NvbW9kYXRlcyBUeXBlc2NyaXB0IGRlY2xhcmUgZnVuY3Rpb24gZm9ybWF0dGluZ1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5PUEVSQVRPUiB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICc9Jykge1xuICAgICAgLy8gZm9vID0gZnVuY3Rpb25cbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2ZsYWdzLm11bHRpbGluZV9mcmFtZSAmJiAoaXNfZXhwcmVzc2lvbih0aGlzLl9mbGFncy5tb2RlKSB8fCBpc19hcnJheSh0aGlzLl9mbGFncy5tb2RlKSkpIHtcbiAgICAgIC8vIChmdW5jdGlvblxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgIHRoaXMuX2ZsYWdzLmxhc3Rfd29yZCA9IGN1cnJlbnRfdG9rZW4udGV4dDtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcHJlZml4ID0gJ05PTkUnO1xuXG4gIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9CTE9DSykge1xuXG4gICAgaWYgKHRoaXMuX3ByZXZpb3VzX2ZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgcHJlZml4ID0gJ1NQQUNFJztcbiAgICB9IGVsc2UgaWYgKCFyZXNlcnZlZF9hcnJheShjdXJyZW50X3Rva2VuLCBbJ2Vsc2UnLCAnY2F0Y2gnLCAnZmluYWxseScsICdmcm9tJ10pKSB7XG4gICAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLmJyYWNlX3N0eWxlID09PSBcImV4cGFuZFwiIHx8XG4gICAgICAgIHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwiZW5kLWV4cGFuZFwiIHx8XG4gICAgICAgICh0aGlzLl9vcHRpb25zLmJyYWNlX3N0eWxlID09PSBcIm5vbmVcIiAmJiBjdXJyZW50X3Rva2VuLm5ld2xpbmVzKSkge1xuICAgICAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVmaXggPSAnU1BBQ0UnO1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TRU1JQ09MT04gJiYgdGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5CbG9ja1N0YXRlbWVudCkge1xuICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIGJlIGZvciBTVEFURU1FTlQgYXMgd2VsbD9cbiAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TRU1JQ09MT04gJiYgaXNfZXhwcmVzc2lvbih0aGlzLl9mbGFncy5tb2RlKSkge1xuICAgIHByZWZpeCA9ICdTUEFDRSc7XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVFJJTkcpIHtcbiAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQgfHxcbiAgICAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnKicgJiZcbiAgICAgIChpbl9hcnJheSh0aGlzLl9sYXN0X2xhc3RfdGV4dCwgWydmdW5jdGlvbicsICd5aWVsZCddKSB8fFxuICAgICAgICAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsICYmIGluX2FycmF5KHRoaXMuX2xhc3RfbGFzdF90ZXh0LCBbJ3snLCAnLCddKSkpKSkge1xuICAgIHByZWZpeCA9ICdTUEFDRSc7XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9CTE9DSykge1xuICAgIGlmICh0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICAgIHByZWZpeCA9ICdTUEFDRSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfRVhQUikge1xuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgfVxuXG4gIGlmIChyZXNlcnZlZF9hcnJheShjdXJyZW50X3Rva2VuLCBsaW5lX3N0YXJ0ZXJzKSAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgIT09ICcpJykge1xuICAgIGlmICh0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnZWxzZScgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnZXhwb3J0Jykge1xuICAgICAgcHJlZml4ID0gJ1NQQUNFJztcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZml4ID0gJ05FV0xJTkUnO1xuICAgIH1cblxuICB9XG5cbiAgaWYgKHJlc2VydmVkX2FycmF5KGN1cnJlbnRfdG9rZW4sIFsnZWxzZScsICdjYXRjaCcsICdmaW5hbGx5J10pKSB7XG4gICAgaWYgKCghKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0JMT0NLICYmIHRoaXMuX3ByZXZpb3VzX2ZsYWdzLm1vZGUgPT09IE1PREUuQmxvY2tTdGF0ZW1lbnQpIHx8XG4gICAgICAgIHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwiZXhwYW5kXCIgfHxcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJlbmQtZXhwYW5kXCIgfHxcbiAgICAgICAgKHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwibm9uZVwiICYmIGN1cnJlbnRfdG9rZW4ubmV3bGluZXMpKSAmJlxuICAgICAgIXRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX291dHB1dC50cmltKHRydWUpO1xuICAgICAgdmFyIGxpbmUgPSB0aGlzLl9vdXRwdXQuY3VycmVudF9saW5lO1xuICAgICAgLy8gSWYgd2UgdHJpbW1lZCBhbmQgdGhlcmUncyBzb21ldGhpbmcgb3RoZXIgdGhhbiBhIGNsb3NlIGJsb2NrIGJlZm9yZSB1c1xuICAgICAgLy8gcHV0IGEgbmV3bGluZSBiYWNrIGluLiAgSGFuZGxlcyAnfSAvLyBjb21tZW50JyBzY2VuYXJpby5cbiAgICAgIGlmIChsaW5lLmxhc3QoKSAhPT0gJ30nKSB7XG4gICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gJ05FV0xJTkUnKSB7XG4gICAgaWYgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIHNwZWNpYWxfd29yZHMpKSB7XG4gICAgICAvLyBubyBuZXdsaW5lIGJldHdlZW4gJ3JldHVybiBubm4nXG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ2RlY2xhcmUnICYmIHJlc2VydmVkX2FycmF5KGN1cnJlbnRfdG9rZW4sIFsndmFyJywgJ2xldCcsICdjb25zdCddKSkge1xuICAgICAgLy8gYWNjb21vZGF0ZXMgVHlwZXNjcmlwdCBkZWNsYXJlIGZvcm1hdHRpbmdcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlICE9PSBUT0tFTi5FTkRfRVhQUikge1xuICAgICAgaWYgKCh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgIT09IFRPS0VOLlNUQVJUX0VYUFIgfHwgIXJlc2VydmVkX2FycmF5KGN1cnJlbnRfdG9rZW4sIFsndmFyJywgJ2xldCcsICdjb25zdCddKSkgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ICE9PSAnOicpIHtcbiAgICAgICAgLy8gbm8gbmVlZCB0byBmb3JjZSBuZXdsaW5lIG9uICd2YXInOiBmb3IgKHZhciB4ID0gMC4uLilcbiAgICAgICAgaWYgKHJlc2VydmVkX3dvcmQoY3VycmVudF90b2tlbiwgJ2lmJykgJiYgcmVzZXJ2ZWRfd29yZChjdXJyZW50X3Rva2VuLnByZXZpb3VzLCAnZWxzZScpKSB7XG4gICAgICAgICAgLy8gbm8gbmV3bGluZSBmb3IgfSBlbHNlIGlmIHtcbiAgICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVzZXJ2ZWRfYXJyYXkoY3VycmVudF90b2tlbiwgbGluZV9zdGFydGVycykgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ICE9PSAnKScpIHtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5tdWx0aWxpbmVfZnJhbWUgJiYgaXNfYXJyYXkodGhpcy5fZmxhZ3MubW9kZSkgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnLCcgJiYgdGhpcy5fbGFzdF9sYXN0X3RleHQgPT09ICd9Jykge1xuICAgIHRoaXMucHJpbnRfbmV3bGluZSgpOyAvLyB9LCBpbiBsaXN0cyBnZXQgYSBuZXdsaW5lIHRyZWF0bWVudFxuICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gJ1NQQUNFJykge1xuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICB9XG4gIGlmIChjdXJyZW50X3Rva2VuLnByZXZpb3VzICYmIChjdXJyZW50X3Rva2VuLnByZXZpb3VzLnR5cGUgPT09IFRPS0VOLldPUkQgfHwgY3VycmVudF90b2tlbi5wcmV2aW91cy50eXBlID09PSBUT0tFTi5SRVNFUlZFRCkpIHtcbiAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgfVxuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLl9mbGFncy5sYXN0X3dvcmQgPSBjdXJyZW50X3Rva2VuLnRleHQ7XG5cbiAgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQpIHtcbiAgICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnZG8nKSB7XG4gICAgICB0aGlzLl9mbGFncy5kb19ibG9jayA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICdpZicpIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmlmX2Jsb2NrID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ2ltcG9ydCcpIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmltcG9ydF9ibG9jayA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5pbXBvcnRfYmxvY2sgJiYgcmVzZXJ2ZWRfd29yZChjdXJyZW50X3Rva2VuLCAnZnJvbScpKSB7XG4gICAgICB0aGlzLl9mbGFncy5pbXBvcnRfYmxvY2sgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9zZW1pY29sb24gPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIGlmICh0aGlzLnN0YXJ0X29mX3N0YXRlbWVudChjdXJyZW50X3Rva2VuKSkge1xuICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgICAvLyBTZW1pY29sb24gY2FuIGJlIHRoZSBzdGFydCAoYW5kIGVuZCkgb2YgYSBzdGF0ZW1lbnRcbiAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gIH1cblxuICB2YXIgbmV4dF90b2tlbiA9IHRoaXMuX3Rva2Vucy5wZWVrKCk7XG4gIHdoaWxlICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCAmJlxuICAgICEodGhpcy5fZmxhZ3MuaWZfYmxvY2sgJiYgcmVzZXJ2ZWRfd29yZChuZXh0X3Rva2VuLCAnZWxzZScpKSAmJlxuICAgICF0aGlzLl9mbGFncy5kb19ibG9jaykge1xuICAgIHRoaXMucmVzdG9yZV9tb2RlKCk7XG4gIH1cblxuICAvLyBoYWNreSBidXQgZWZmZWN0aXZlIGZvciB0aGUgbW9tZW50XG4gIGlmICh0aGlzLl9mbGFncy5pbXBvcnRfYmxvY2spIHtcbiAgICB0aGlzLl9mbGFncy5pbXBvcnRfYmxvY2sgPSBmYWxzZTtcbiAgfVxuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX3N0cmluZyA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dC5zdGFydHNXaXRoKFwiYFwiKSAmJiBjdXJyZW50X3Rva2VuLm5ld2xpbmVzID09PSAwICYmIGN1cnJlbnRfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUgPT09ICcnICYmIChjdXJyZW50X3Rva2VuLnByZXZpb3VzLnRleHQgPT09ICcpJyB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQpKSB7XG4gICAgLy9Db25kaXRpb25hbCBmb3IgZGV0ZWN0aWduIGJhY2t0aWNrIHN0cmluZ3NcbiAgfSBlbHNlIGlmICh0aGlzLnN0YXJ0X29mX3N0YXRlbWVudChjdXJyZW50X3Rva2VuKSkge1xuICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgICAvLyBPbmUgZGlmZmVyZW5jZSAtIHN0cmluZ3Mgd2FudCBhdCBsZWFzdCBhIHNwYWNlIGJlZm9yZVxuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uV09SRCB8fCB0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5DT01NQSB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0VYUFIgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5FUVVBTFMgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5PUEVSQVRPUikge1xuICAgICAgaWYgKCF0aGlzLnN0YXJ0X29mX29iamVjdF9wcm9wZXJ0eSgpKSB7XG4gICAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKChjdXJyZW50X3Rva2VuLnRleHQuc3RhcnRzV2l0aChcImBcIikgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfRVhQUiAmJiAoY3VycmVudF90b2tlbi5wcmV2aW91cy50ZXh0ID09PSAnXScgfHwgY3VycmVudF90b2tlbi5wcmV2aW91cy50ZXh0ID09PSAnKScpICYmIGN1cnJlbnRfdG9rZW4ubmV3bGluZXMgPT09IDApKSB7XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgfVxuICB9XG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfZXF1YWxzID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICBpZiAodGhpcy5zdGFydF9vZl9zdGF0ZW1lbnQoY3VycmVudF90b2tlbikpIHtcbiAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gIH1cblxuICBpZiAodGhpcy5fZmxhZ3MuZGVjbGFyYXRpb25fc3RhdGVtZW50KSB7XG4gICAgLy8ganVzdCBnb3QgYW4gJz0nIGluIGEgdmFyLWxpbmUsIGRpZmZlcmVudCBmb3JtYXR0aW5nL2xpbmUtYnJlYWtpbmcsIGV0YyB3aWxsIG5vdyBiZSBkb25lXG4gICAgdGhpcy5fZmxhZ3MuZGVjbGFyYXRpb25fYXNzaWdubWVudCA9IHRydWU7XG4gIH1cbiAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX2NvbW1hID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuLCB0cnVlKTtcblxuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgaWYgKHRoaXMuX2ZsYWdzLmRlY2xhcmF0aW9uX3N0YXRlbWVudCkge1xuICAgIGlmIChpc19leHByZXNzaW9uKHRoaXMuX2ZsYWdzLnBhcmVudC5tb2RlKSkge1xuICAgICAgLy8gZG8gbm90IGJyZWFrIG9uIGNvbW1hLCBmb3IodmFyIGEgPSAxLCBiID0gMilcbiAgICAgIHRoaXMuX2ZsYWdzLmRlY2xhcmF0aW9uX2Fzc2lnbm1lbnQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZmxhZ3MuZGVjbGFyYXRpb25fYXNzaWdubWVudCkge1xuICAgICAgdGhpcy5fZmxhZ3MuZGVjbGFyYXRpb25fYXNzaWdubWVudCA9IGZhbHNlO1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuY29tbWFfZmlyc3QpIHtcbiAgICAgIC8vIGZvciBjb21tYS1maXJzdCwgd2Ugd2FudCB0byBhbGxvdyBhIG5ld2xpbmUgYmVmb3JlIHRoZSBjb21tYVxuICAgICAgLy8gdG8gdHVybiBpbnRvIGEgbmV3bGluZSBhZnRlciB0aGUgY29tbWEsIHdoaWNoIHdlIHdpbGwgZml4dXAgbGF0ZXJcbiAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsIHx8XG4gICAgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50ICYmIHRoaXMuX2ZsYWdzLnBhcmVudC5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwpKSB7XG4gICAgaWYgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSB7XG4gICAgICB0aGlzLnJlc3RvcmVfbW9kZSgpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5jb21tYV9maXJzdCkge1xuICAgIC8vIEVYUFIgb3IgRE9fQkxPQ0tcbiAgICAvLyBmb3IgY29tbWEtZmlyc3QsIHdlIHdhbnQgdG8gYWxsb3cgYSBuZXdsaW5lIGJlZm9yZSB0aGUgY29tbWFcbiAgICAvLyB0byB0dXJuIGludG8gYSBuZXdsaW5lIGFmdGVyIHRoZSBjb21tYSwgd2hpY2ggd2Ugd2lsbCBmaXh1cCBsYXRlclxuICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX29wZXJhdG9yID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICB2YXIgaXNHZW5lcmF0b3JBc3RlcmlzayA9IGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJyonICYmXG4gICAgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIFsnZnVuY3Rpb24nLCAneWllbGQnXSkgfHxcbiAgICAgIChpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUsIFtUT0tFTi5TVEFSVF9CTE9DSywgVE9LRU4uQ09NTUEsIFRPS0VOLkVORF9CTE9DSywgVE9LRU4uU0VNSUNPTE9OXSkpXG4gICAgKTtcbiAgdmFyIGlzVW5hcnkgPSBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnLScsICcrJ10pICYmIChcbiAgICBpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUsIFtUT0tFTi5TVEFSVF9CTE9DSywgVE9LRU4uU1RBUlRfRVhQUiwgVE9LRU4uRVFVQUxTLCBUT0tFTi5PUEVSQVRPUl0pIHx8XG4gICAgaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0LCBsaW5lX3N0YXJ0ZXJzKSB8fFxuICAgIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJywnXG4gICk7XG5cbiAgaWYgKHRoaXMuc3RhcnRfb2Zfc3RhdGVtZW50KGN1cnJlbnRfdG9rZW4pKSB7XG4gICAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICB9IGVsc2Uge1xuICAgIHZhciBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MgPSAhaXNHZW5lcmF0b3JBc3RlcmlzaztcbiAgICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICB9XG5cbiAgLy8gaGFjayBmb3IgYWN0aW9uc2NyaXB0J3MgaW1wb3J0IC4qO1xuICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnKicgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5ET1QpIHtcbiAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICc6OicpIHtcbiAgICAvLyBubyBzcGFjZXMgYXJvdW5kIGV4b3RpYyBuYW1lc3BhY2luZyBzeW50YXggb3BlcmF0b3JcbiAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnLScsICcrJ10pICYmIHRoaXMuc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5KCkpIHtcbiAgICAvLyBudW1lcmljIHZhbHVlIHdpdGggKy8tIHN5bWJvbCBpbiBmcm9udCBhcyBhIHByb3BlcnR5XG4gICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBBbGxvdyBsaW5lIHdyYXBwaW5nIGJldHdlZW4gb3BlcmF0b3JzIHdoZW4gb3BlcmF0b3JfcG9zaXRpb24gaXNcbiAgLy8gICBzZXQgdG8gYmVmb3JlIG9yIHByZXNlcnZlXG4gIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLk9QRVJBVE9SICYmIGluX2FycmF5KHRoaXMuX29wdGlvbnMub3BlcmF0b3JfcG9zaXRpb24sIE9QRVJBVE9SX1BPU0lUSU9OX0JFRk9SRV9PUl9QUkVTRVJWRSkpIHtcbiAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gIH1cblxuICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnOicgJiYgdGhpcy5fZmxhZ3MuaW5fY2FzZSkge1xuICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG5cbiAgICB0aGlzLl9mbGFncy5pbl9jYXNlID0gZmFsc2U7XG4gICAgdGhpcy5fZmxhZ3MuY2FzZV9ib2R5ID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5fdG9rZW5zLnBlZWsoKS50eXBlICE9PSBUT0tFTi5TVEFSVF9CTE9DSykge1xuICAgICAgdGhpcy5pbmRlbnQoKTtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgdGhpcy5fZmxhZ3MuY2FzZV9ibG9jayA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mbGFncy5jYXNlX2Jsb2NrID0gdHJ1ZTtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc3BhY2VfYmVmb3JlID0gdHJ1ZTtcbiAgdmFyIHNwYWNlX2FmdGVyID0gdHJ1ZTtcbiAgdmFyIGluX3Rlcm5hcnkgPSBmYWxzZTtcbiAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJzonKSB7XG4gICAgaWYgKHRoaXMuX2ZsYWdzLnRlcm5hcnlfZGVwdGggPT09IDApIHtcbiAgICAgIC8vIENvbG9uIGlzIGludmFsaWQgamF2YXNjcmlwdCBvdXRzaWRlIG9mIHRlcm5hcnkgYW5kIG9iamVjdCwgYnV0IGRvIG91ciBiZXN0IHRvIGd1ZXNzIHdoYXQgd2FzIG1lYW50LlxuICAgICAgc3BhY2VfYmVmb3JlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2ZsYWdzLnRlcm5hcnlfZGVwdGggLT0gMTtcbiAgICAgIGluX3Rlcm5hcnkgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICc/Jykge1xuICAgIHRoaXMuX2ZsYWdzLnRlcm5hcnlfZGVwdGggKz0gMTtcbiAgfVxuXG4gIC8vIGxldCdzIGhhbmRsZSB0aGUgb3BlcmF0b3JfcG9zaXRpb24gb3B0aW9uIHByaW9yIHRvIGFueSBjb25mbGljdGluZyBsb2dpY1xuICBpZiAoIWlzVW5hcnkgJiYgIWlzR2VuZXJhdG9yQXN0ZXJpc2sgJiYgdGhpcy5fb3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcyAmJiBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIHBvc2l0aW9uYWJsZV9vcGVyYXRvcnMpKSB7XG4gICAgdmFyIGlzQ29sb24gPSBjdXJyZW50X3Rva2VuLnRleHQgPT09ICc6JztcbiAgICB2YXIgaXNUZXJuYXJ5Q29sb24gPSAoaXNDb2xvbiAmJiBpbl90ZXJuYXJ5KTtcbiAgICB2YXIgaXNPdGhlckNvbG9uID0gKGlzQ29sb24gJiYgIWluX3Rlcm5hcnkpO1xuXG4gICAgc3dpdGNoICh0aGlzLl9vcHRpb25zLm9wZXJhdG9yX3Bvc2l0aW9uKSB7XG4gICAgICBjYXNlIE9QRVJBVE9SX1BPU0lUSU9OLmJlZm9yZV9uZXdsaW5lOlxuICAgICAgICAvLyBpZiB0aGUgY3VycmVudCB0b2tlbiBpcyA6IGFuZCBpdCdzIG5vdCBhIHRlcm5hcnkgc3RhdGVtZW50IHRoZW4gd2Ugc2V0IHNwYWNlX2JlZm9yZSB0byBmYWxzZVxuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gIWlzT3RoZXJDb2xvbjtcblxuICAgICAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuXG4gICAgICAgIGlmICghaXNDb2xvbiB8fCBpc1Rlcm5hcnlDb2xvbikge1xuICAgICAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgT1BFUkFUT1JfUE9TSVRJT04uYWZ0ZXJfbmV3bGluZTpcbiAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgdG9rZW4gaXMgYW55dGhpbmcgYnV0IGNvbG9uLCBvciAodmlhIGRlZHVjdGlvbikgaXQncyBhIGNvbG9uIGFuZCBpbiBhIHRlcm5hcnkgc3RhdGVtZW50LFxuICAgICAgICAvLyAgIHRoZW4gcHJpbnQgYSBuZXdsaW5lLlxuXG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuXG4gICAgICAgIGlmICghaXNDb2xvbiB8fCBpc1Rlcm5hcnlDb2xvbikge1xuICAgICAgICAgIGlmICh0aGlzLl90b2tlbnMucGVlaygpLm5ld2xpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG5cbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBPUEVSQVRPUl9QT1NJVElPTi5wcmVzZXJ2ZV9uZXdsaW5lOlxuICAgICAgICBpZiAoIWlzT3RoZXJDb2xvbikge1xuICAgICAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIGp1c3QgYWRkZWQgYSBuZXdsaW5lLCBvciB0aGUgY3VycmVudCB0b2tlbiBpcyA6IGFuZCBpdCdzIG5vdCBhIHRlcm5hcnkgc3RhdGVtZW50LFxuICAgICAgICAvLyAgIHRoZW4gd2Ugc2V0IHNwYWNlX2JlZm9yZSB0byBmYWxzZVxuICAgICAgICBzcGFjZV9iZWZvcmUgPSAhKHRoaXMuX291dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSB8fCBpc090aGVyQ29sb24pO1xuXG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBzcGFjZV9iZWZvcmU7XG4gICAgICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzR2VuZXJhdG9yQXN0ZXJpc2spIHtcbiAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgc3BhY2VfYmVmb3JlID0gZmFsc2U7XG4gICAgdmFyIG5leHRfdG9rZW4gPSB0aGlzLl90b2tlbnMucGVlaygpO1xuICAgIHNwYWNlX2FmdGVyID0gbmV4dF90b2tlbiAmJiBpbl9hcnJheShuZXh0X3Rva2VuLnR5cGUsIFtUT0tFTi5XT1JELCBUT0tFTi5SRVNFUlZFRF0pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJy4uLicpIHtcbiAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgc3BhY2VfYmVmb3JlID0gdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9CTE9DSztcbiAgICBzcGFjZV9hZnRlciA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWyctLScsICcrKycsICchJywgJ34nXSkgfHwgaXNVbmFyeSkge1xuICAgIC8vIHVuYXJ5IG9wZXJhdG9ycyAoYW5kIGJpbmFyeSArLy0gcHJldGVuZGluZyB0byBiZSB1bmFyeSkgc3BlY2lhbCBjYXNlc1xuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1BIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUikge1xuICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgIH1cblxuICAgIHNwYWNlX2JlZm9yZSA9IGZhbHNlO1xuICAgIHNwYWNlX2FmdGVyID0gZmFsc2U7XG5cbiAgICAvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtNy45LjFcbiAgICAvLyBpZiB0aGVyZSBpcyBhIG5ld2xpbmUgYmV0d2VlbiAtLSBvciArKyBhbmQgYW55dGhpbmcgZWxzZSB3ZSBzaG91bGQgcHJlc2VydmUgaXQuXG4gICAgaWYgKGN1cnJlbnRfdG9rZW4ubmV3bGluZXMgJiYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJy0tJyB8fCBjdXJyZW50X3Rva2VuLnRleHQgPT09ICcrKycgfHwgY3VycmVudF90b2tlbi50ZXh0ID09PSAnficpKSB7XG4gICAgICB2YXIgbmV3X2xpbmVfbmVlZGVkID0gcmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgc3BlY2lhbF93b3JkcykgJiYgY3VycmVudF90b2tlbi5uZXdsaW5lcztcbiAgICAgIGlmIChuZXdfbGluZV9uZWVkZWQgJiYgKHRoaXMuX3ByZXZpb3VzX2ZsYWdzLmlmX2Jsb2NrIHx8IHRoaXMuX3ByZXZpb3VzX2ZsYWdzLmVsc2VfYmxvY2spKSB7XG4gICAgICAgIHRoaXMucmVzdG9yZV9tb2RlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUobmV3X2xpbmVfbmVlZGVkLCB0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnOycgJiYgaXNfZXhwcmVzc2lvbih0aGlzLl9mbGFncy5tb2RlKSkge1xuICAgICAgLy8gZm9yICg7OyArK2kpXG4gICAgICAvLyAgICAgICAgXl5eXG4gICAgICBzcGFjZV9iZWZvcmUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEKSB7XG4gICAgICBzcGFjZV9iZWZvcmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfRVhQUikge1xuICAgICAgc3BhY2VfYmVmb3JlID0gISh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICddJyAmJiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnLS0nIHx8IGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJysrJykpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5PUEVSQVRPUikge1xuICAgICAgLy8gYSsrICsgKytiO1xuICAgICAgLy8gYSAtIC1iXG4gICAgICBzcGFjZV9iZWZvcmUgPSBpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnLS0nLCAnLScsICcrKycsICcrJ10pICYmIGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCwgWyctLScsICctJywgJysrJywgJysnXSk7XG4gICAgICAvLyArIGFuZCAtIGFyZSBub3QgdW5hcnkgd2hlbiBwcmVjZWVkZWQgYnkgLS0gb3IgKysgb3BlcmF0b3JcbiAgICAgIC8vIGEtLSArIGJcbiAgICAgIC8vIGEgKiArYlxuICAgICAgLy8gYSAtIC1iXG4gICAgICBpZiAoaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJysnLCAnLSddKSAmJiBpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIFsnLS0nLCAnKysnXSkpIHtcbiAgICAgICAgc3BhY2VfYWZ0ZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuXG4gICAgaWYgKCgodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5CbG9ja1N0YXRlbWVudCAmJiAhdGhpcy5fZmxhZ3MuaW5saW5lX2ZyYW1lKSB8fCB0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkgJiZcbiAgICAgICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICd7JyB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICc7JykpIHtcbiAgICAgIC8vIHsgZm9vOyAtLWkgfVxuICAgICAgLy8gZm9vKCk7IC0tYmFyO1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gfHwgc3BhY2VfYmVmb3JlO1xuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gc3BhY2VfYWZ0ZXI7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfYmxvY2tfY29tbWVudCA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICBpZiAodGhpcy5fb3V0cHV0LnJhdykge1xuICAgIHRoaXMuX291dHB1dC5hZGRfcmF3X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgIGlmIChjdXJyZW50X3Rva2VuLmRpcmVjdGl2ZXMgJiYgY3VycmVudF90b2tlbi5kaXJlY3RpdmVzLnByZXNlcnZlID09PSAnZW5kJykge1xuICAgICAgLy8gSWYgd2UncmUgdGVzdGluZyB0aGUgcmF3IG91dHB1dCBiZWhhdmlvciwgZG8gbm90IGFsbG93IGEgZGlyZWN0aXZlIHRvIHR1cm4gaXQgb2ZmLlxuICAgICAgdGhpcy5fb3V0cHV0LnJhdyA9IHRoaXMuX29wdGlvbnMudGVzdF9vdXRwdXRfcmF3O1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY3VycmVudF90b2tlbi5kaXJlY3RpdmVzKSB7XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgaWYgKGN1cnJlbnRfdG9rZW4uZGlyZWN0aXZlcy5wcmVzZXJ2ZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgdGhpcy5fb3V0cHV0LnJhdyA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaW5saW5lIGJsb2NrXG4gIGlmICghYWNvcm4ubmV3bGluZS50ZXN0KGN1cnJlbnRfdG9rZW4udGV4dCkgJiYgIWN1cnJlbnRfdG9rZW4ubmV3bGluZXMpIHtcbiAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnByaW50X2Jsb2NrX2NvbW1tZW50KGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLnByaW50X2Jsb2NrX2NvbW1tZW50ID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gIHZhciBsaW5lcyA9IHNwbGl0X2xpbmVicmVha3MoY3VycmVudF90b2tlbi50ZXh0KTtcbiAgdmFyIGo7IC8vIGl0ZXJhdG9yIGZvciB0aGlzIGNhc2VcbiAgdmFyIGphdmFkb2MgPSBmYWxzZTtcbiAgdmFyIHN0YXJsZXNzID0gZmFsc2U7XG4gIHZhciBsYXN0SW5kZW50ID0gY3VycmVudF90b2tlbi53aGl0ZXNwYWNlX2JlZm9yZTtcbiAgdmFyIGxhc3RJbmRlbnRMZW5ndGggPSBsYXN0SW5kZW50Lmxlbmd0aDtcblxuICAvLyBibG9jayBjb21tZW50IHN0YXJ0cyB3aXRoIGEgbmV3IGxpbmVcbiAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuXG4gIC8vIGZpcnN0IGxpbmUgYWx3YXlzIGluZGVudGVkXG4gIHRoaXMucHJpbnRfdG9rZW5fbGluZV9pbmRlbnRhdGlvbihjdXJyZW50X3Rva2VuKTtcbiAgdGhpcy5fb3V0cHV0LmFkZF90b2tlbihsaW5lc1swXSk7XG4gIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcblxuXG4gIGlmIChsaW5lcy5sZW5ndGggPiAxKSB7XG4gICAgbGluZXMgPSBsaW5lcy5zbGljZSgxKTtcbiAgICBqYXZhZG9jID0gYWxsX2xpbmVzX3N0YXJ0X3dpdGgobGluZXMsICcqJyk7XG4gICAgc3Rhcmxlc3MgPSBlYWNoX2xpbmVfbWF0Y2hlc19pbmRlbnQobGluZXMsIGxhc3RJbmRlbnQpO1xuXG4gICAgaWYgKGphdmFkb2MpIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmFsaWdubWVudCA9IDE7XG4gICAgfVxuXG4gICAgZm9yIChqID0gMDsgaiA8IGxpbmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAoamF2YWRvYykge1xuICAgICAgICAvLyBqYXZhZG9jOiByZWZvcm1hdCBhbmQgcmUtaW5kZW50XG4gICAgICAgIHRoaXMucHJpbnRfdG9rZW5fbGluZV9pbmRlbnRhdGlvbihjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0LmFkZF90b2tlbihsdHJpbShsaW5lc1tqXSkpO1xuICAgICAgfSBlbHNlIGlmIChzdGFybGVzcyAmJiBsaW5lc1tqXSkge1xuICAgICAgICAvLyBzdGFybGVzczogcmUtaW5kZW50IG5vbi1lbXB0eSBjb250ZW50LCBhdm9pZGluZyB0cmltXG4gICAgICAgIHRoaXMucHJpbnRfdG9rZW5fbGluZV9pbmRlbnRhdGlvbihjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0LmFkZF90b2tlbihsaW5lc1tqXS5zdWJzdHJpbmcobGFzdEluZGVudExlbmd0aCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm9ybWFsIGNvbW1lbnRzIG91dHB1dCByYXdcbiAgICAgICAgdGhpcy5fb3V0cHV0LmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KC0xKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0LmFkZF90b2tlbihsaW5lc1tqXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGZvciBjb21tZW50cyBvbiB0aGVpciBvd24gbGluZSBvciAgbW9yZSB0aGFuIG9uZSBsaW5lLCBtYWtlIHN1cmUgdGhlcmUncyBhIG5ldyBsaW5lIGFmdGVyXG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgfVxuXG4gICAgdGhpcy5fZmxhZ3MuYWxpZ25tZW50ID0gMDtcbiAgfVxufTtcblxuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfY29tbWVudCA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICBpZiAoY3VycmVudF90b2tlbi5uZXdsaW5lcykge1xuICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9vdXRwdXQudHJpbSh0cnVlKTtcbiAgfVxuXG4gIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfZG90ID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICBpZiAodGhpcy5zdGFydF9vZl9zdGF0ZW1lbnQoY3VycmVudF90b2tlbikpIHtcbiAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbiwgdHJ1ZSk7XG4gIH1cblxuICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0Lm1hdGNoKCdeWzAtOV0rJCcpKSB7XG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gIH1cblxuICBpZiAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgc3BlY2lhbF93b3JkcykpIHtcbiAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gYWxsb3cgcHJlc2VydmVkIG5ld2xpbmVzIGJlZm9yZSBkb3RzIGluIGdlbmVyYWxcbiAgICAvLyBmb3JjZSBuZXdsaW5lcyBvbiBkb3RzIGFmdGVyIGNsb3NlIHBhcmVuIHdoZW4gYnJlYWtfY2hhaW5lZCAtIGZvciBiYXIoKS5iYXooKVxuICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuLFxuICAgICAgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnKScgJiYgdGhpcy5fb3B0aW9ucy5icmVha19jaGFpbmVkX21ldGhvZHMpO1xuICB9XG5cbiAgLy8gT25seSB1bmluZGVudCBjaGFpbmVkIG1ldGhvZCBkb3QgaWYgdGhpcyBkb3Qgc3RhcnRzIGEgbmV3IGxpbmUuXG4gIC8vIE90aGVyd2lzZSB0aGUgYXV0b21hdGljIGV4dHJhIGluZGVudGF0aW9uIHJlbW92YWwgd2lsbCBoYW5kbGUgdGhlIG92ZXIgaW5kZW50XG4gIGlmICh0aGlzLl9vcHRpb25zLnVuaW5kZW50X2NoYWluZWRfbWV0aG9kcyAmJiB0aGlzLl9vdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICB0aGlzLmRlaW5kZW50KCk7XG4gIH1cblxuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX3Vua25vd24gPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcblxuICBpZiAoY3VycmVudF90b2tlbi50ZXh0W2N1cnJlbnRfdG9rZW4udGV4dC5sZW5ndGggLSAxXSA9PT0gJ1xcbicpIHtcbiAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9lb2YgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIC8vIFVud2luZCBhbnkgb3BlbiBzdGF0ZW1lbnRzXG4gIHdoaWxlICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkge1xuICAgIHRoaXMucmVzdG9yZV9tb2RlKCk7XG4gIH1cbiAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CZWF1dGlmaWVyID0gQmVhdXRpZmllcjtcblxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gT3V0cHV0TGluZShwYXJlbnQpIHtcbiAgdGhpcy5fX3BhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IDA7XG4gIC8vIHVzZSBpbmRlbnRfY291bnQgYXMgYSBtYXJrZXIgZm9yIHRoaXMuX19saW5lcyB0aGF0IGhhdmUgcHJlc2VydmVkIGluZGVudGF0aW9uXG4gIHRoaXMuX19pbmRlbnRfY291bnQgPSAtMTtcbiAgdGhpcy5fX2FsaWdubWVudF9jb3VudCA9IDA7XG4gIHRoaXMuX193cmFwX3BvaW50X2luZGV4ID0gMDtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50ID0gMDtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50ID0gLTE7XG4gIHRoaXMuX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCA9IDA7XG5cbiAgdGhpcy5fX2l0ZW1zID0gW107XG59XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmNsb25lX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsaW5lID0gbmV3IE91dHB1dExpbmUodGhpcy5fX3BhcmVudCk7XG4gIGxpbmUuc2V0X2luZGVudCh0aGlzLl9faW5kZW50X2NvdW50LCB0aGlzLl9fYWxpZ25tZW50X2NvdW50KTtcbiAgcmV0dXJuIGxpbmU7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5pdGVtID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiB0aGlzLl9faXRlbXNbdGhpcy5fX2l0ZW1zLmxlbmd0aCArIGluZGV4XTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZW1zW2luZGV4XTtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuaGFzX21hdGNoID0gZnVuY3Rpb24ocGF0dGVybikge1xuICBmb3IgKHZhciBsYXN0Q2hlY2tlZE91dHB1dCA9IHRoaXMuX19pdGVtcy5sZW5ndGggLSAxOyBsYXN0Q2hlY2tlZE91dHB1dCA+PSAwOyBsYXN0Q2hlY2tlZE91dHB1dC0tKSB7XG4gICAgaWYgKHRoaXMuX19pdGVtc1tsYXN0Q2hlY2tlZE91dHB1dF0ubWF0Y2gocGF0dGVybikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5zZXRfaW5kZW50ID0gZnVuY3Rpb24oaW5kZW50LCBhbGlnbm1lbnQpIHtcbiAgaWYgKHRoaXMuaXNfZW1wdHkoKSkge1xuICAgIHRoaXMuX19pbmRlbnRfY291bnQgPSBpbmRlbnQgfHwgMDtcbiAgICB0aGlzLl9fYWxpZ25tZW50X2NvdW50ID0gYWxpZ25tZW50IHx8IDA7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IHRoaXMuX19wYXJlbnQuZ2V0X2luZGVudF9zaXplKHRoaXMuX19pbmRlbnRfY291bnQsIHRoaXMuX19hbGlnbm1lbnRfY291bnQpO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fc2V0X3dyYXBfcG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX19wYXJlbnQud3JhcF9saW5lX2xlbmd0aCkge1xuICAgIHRoaXMuX193cmFwX3BvaW50X2luZGV4ID0gdGhpcy5fX2l0ZW1zLmxlbmd0aDtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQgPSB0aGlzLl9fY2hhcmFjdGVyX2NvdW50O1xuICAgIHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCA9IHRoaXMuX19wYXJlbnQubmV4dF9saW5lLl9faW5kZW50X2NvdW50O1xuICAgIHRoaXMuX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCA9IHRoaXMuX19wYXJlbnQubmV4dF9saW5lLl9fYWxpZ25tZW50X2NvdW50O1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fc2hvdWxkX3dyYXAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX193cmFwX3BvaW50X2luZGV4ICYmXG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA+IHRoaXMuX19wYXJlbnQud3JhcF9saW5lX2xlbmd0aCAmJlxuICAgIHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudCA+IHRoaXMuX19wYXJlbnQubmV4dF9saW5lLl9fY2hhcmFjdGVyX2NvdW50O1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX2FsbG93X3dyYXAgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3Nob3VsZF93cmFwKCkpIHtcbiAgICB0aGlzLl9fcGFyZW50LmFkZF9uZXdfbGluZSgpO1xuICAgIHZhciBuZXh0ID0gdGhpcy5fX3BhcmVudC5jdXJyZW50X2xpbmU7XG4gICAgbmV4dC5zZXRfaW5kZW50KHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCwgdGhpcy5fX3dyYXBfcG9pbnRfYWxpZ25tZW50X2NvdW50KTtcbiAgICBuZXh0Ll9faXRlbXMgPSB0aGlzLl9faXRlbXMuc2xpY2UodGhpcy5fX3dyYXBfcG9pbnRfaW5kZXgpO1xuICAgIHRoaXMuX19pdGVtcyA9IHRoaXMuX19pdGVtcy5zbGljZSgwLCB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCk7XG5cbiAgICBuZXh0Ll9fY2hhcmFjdGVyX2NvdW50ICs9IHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLSB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQ7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudDtcblxuICAgIGlmIChuZXh0Ll9faXRlbXNbMF0gPT09IFwiIFwiKSB7XG4gICAgICBuZXh0Ll9faXRlbXMuc3BsaWNlKDAsIDEpO1xuICAgICAgbmV4dC5fX2NoYXJhY3Rlcl9jb3VudCAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5pc19lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX2l0ZW1zLmxlbmd0aCA9PT0gMDtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZW1zW3RoaXMuX19pdGVtcy5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgdGhpcy5fX2l0ZW1zLnB1c2goaXRlbSk7XG4gIHZhciBsYXN0X25ld2xpbmVfaW5kZXggPSBpdGVtLmxhc3RJbmRleE9mKCdcXG4nKTtcbiAgaWYgKGxhc3RfbmV3bGluZV9pbmRleCAhPT0gLTEpIHtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID0gaXRlbS5sZW5ndGggLSBsYXN0X25ld2xpbmVfaW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCArPSBpdGVtLmxlbmd0aDtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtID0gbnVsbDtcbiAgaWYgKCF0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICBpdGVtID0gdGhpcy5fX2l0ZW1zLnBvcCgpO1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLT0gaXRlbS5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9yZW1vdmVfaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9faW5kZW50X2NvdW50ID4gMCkge1xuICAgIHRoaXMuX19pbmRlbnRfY291bnQgLT0gMTtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50IC09IHRoaXMuX19wYXJlbnQuaW5kZW50X3NpemU7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9yZW1vdmVfd3JhcF9pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCA+IDApIHtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQgLT0gMTtcbiAgfVxufTtcbk91dHB1dExpbmUucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbigpIHtcbiAgd2hpbGUgKHRoaXMubGFzdCgpID09PSAnICcpIHtcbiAgICB0aGlzLl9faXRlbXMucG9wKCk7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCAtPSAxO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICBpZiAodGhpcy5fX3BhcmVudC5pbmRlbnRfZW1wdHlfbGluZXMpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX19wYXJlbnQuZ2V0X2luZGVudF9zdHJpbmcodGhpcy5fX2luZGVudF9jb3VudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHRoaXMuX19wYXJlbnQuZ2V0X2luZGVudF9zdHJpbmcodGhpcy5fX2luZGVudF9jb3VudCwgdGhpcy5fX2FsaWdubWVudF9jb3VudCk7XG4gICAgcmVzdWx0ICs9IHRoaXMuX19pdGVtcy5qb2luKCcnKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gSW5kZW50U3RyaW5nQ2FjaGUob3B0aW9ucywgYmFzZUluZGVudFN0cmluZykge1xuICB0aGlzLl9fY2FjaGUgPSBbJyddO1xuICB0aGlzLl9faW5kZW50X3NpemUgPSBvcHRpb25zLmluZGVudF9zaXplO1xuICB0aGlzLl9faW5kZW50X3N0cmluZyA9IG9wdGlvbnMuaW5kZW50X2NoYXI7XG4gIGlmICghb3B0aW9ucy5pbmRlbnRfd2l0aF90YWJzKSB7XG4gICAgdGhpcy5fX2luZGVudF9zdHJpbmcgPSBuZXcgQXJyYXkob3B0aW9ucy5pbmRlbnRfc2l6ZSArIDEpLmpvaW4ob3B0aW9ucy5pbmRlbnRfY2hhcik7XG4gIH1cblxuICAvLyBTZXQgdG8gbnVsbCB0byBjb250aW51ZSBzdXBwb3J0IGZvciBhdXRvIGRldGVjdGlvbiBvZiBiYXNlIGluZGVudFxuICBiYXNlSW5kZW50U3RyaW5nID0gYmFzZUluZGVudFN0cmluZyB8fCAnJztcbiAgaWYgKG9wdGlvbnMuaW5kZW50X2xldmVsID4gMCkge1xuICAgIGJhc2VJbmRlbnRTdHJpbmcgPSBuZXcgQXJyYXkob3B0aW9ucy5pbmRlbnRfbGV2ZWwgKyAxKS5qb2luKHRoaXMuX19pbmRlbnRfc3RyaW5nKTtcbiAgfVxuXG4gIHRoaXMuX19iYXNlX3N0cmluZyA9IGJhc2VJbmRlbnRTdHJpbmc7XG4gIHRoaXMuX19iYXNlX3N0cmluZ19sZW5ndGggPSBiYXNlSW5kZW50U3RyaW5nLmxlbmd0aDtcbn1cblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLmdldF9pbmRlbnRfc2l6ZSA9IGZ1bmN0aW9uKGluZGVudCwgY29sdW1uKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9fYmFzZV9zdHJpbmdfbGVuZ3RoO1xuICBjb2x1bW4gPSBjb2x1bW4gfHwgMDtcbiAgaWYgKGluZGVudCA8IDApIHtcbiAgICByZXN1bHQgPSAwO1xuICB9XG4gIHJlc3VsdCArPSBpbmRlbnQgKiB0aGlzLl9faW5kZW50X3NpemU7XG4gIHJlc3VsdCArPSBjb2x1bW47XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5JbmRlbnRTdHJpbmdDYWNoZS5wcm90b3R5cGUuZ2V0X2luZGVudF9zdHJpbmcgPSBmdW5jdGlvbihpbmRlbnRfbGV2ZWwsIGNvbHVtbikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fX2Jhc2Vfc3RyaW5nO1xuICBjb2x1bW4gPSBjb2x1bW4gfHwgMDtcbiAgaWYgKGluZGVudF9sZXZlbCA8IDApIHtcbiAgICBpbmRlbnRfbGV2ZWwgPSAwO1xuICAgIHJlc3VsdCA9ICcnO1xuICB9XG4gIGNvbHVtbiArPSBpbmRlbnRfbGV2ZWwgKiB0aGlzLl9faW5kZW50X3NpemU7XG4gIHRoaXMuX19lbnN1cmVfY2FjaGUoY29sdW1uKTtcbiAgcmVzdWx0ICs9IHRoaXMuX19jYWNoZVtjb2x1bW5dO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLl9fZW5zdXJlX2NhY2hlID0gZnVuY3Rpb24oY29sdW1uKSB7XG4gIHdoaWxlIChjb2x1bW4gPj0gdGhpcy5fX2NhY2hlLmxlbmd0aCkge1xuICAgIHRoaXMuX19hZGRfY29sdW1uKCk7XG4gIH1cbn07XG5cbkluZGVudFN0cmluZ0NhY2hlLnByb3RvdHlwZS5fX2FkZF9jb2x1bW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvbHVtbiA9IHRoaXMuX19jYWNoZS5sZW5ndGg7XG4gIHZhciBpbmRlbnQgPSAwO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGlzLl9faW5kZW50X3NpemUgJiYgY29sdW1uID49IHRoaXMuX19pbmRlbnRfc2l6ZSkge1xuICAgIGluZGVudCA9IE1hdGguZmxvb3IoY29sdW1uIC8gdGhpcy5fX2luZGVudF9zaXplKTtcbiAgICBjb2x1bW4gLT0gaW5kZW50ICogdGhpcy5fX2luZGVudF9zaXplO1xuICAgIHJlc3VsdCA9IG5ldyBBcnJheShpbmRlbnQgKyAxKS5qb2luKHRoaXMuX19pbmRlbnRfc3RyaW5nKTtcbiAgfVxuICBpZiAoY29sdW1uKSB7XG4gICAgcmVzdWx0ICs9IG5ldyBBcnJheShjb2x1bW4gKyAxKS5qb2luKCcgJyk7XG4gIH1cblxuICB0aGlzLl9fY2FjaGUucHVzaChyZXN1bHQpO1xufTtcblxuZnVuY3Rpb24gT3V0cHV0KG9wdGlvbnMsIGJhc2VJbmRlbnRTdHJpbmcpIHtcbiAgdGhpcy5fX2luZGVudF9jYWNoZSA9IG5ldyBJbmRlbnRTdHJpbmdDYWNoZShvcHRpb25zLCBiYXNlSW5kZW50U3RyaW5nKTtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5fZW5kX3dpdGhfbmV3bGluZSA9IG9wdGlvbnMuZW5kX3dpdGhfbmV3bGluZTtcbiAgdGhpcy5pbmRlbnRfc2l6ZSA9IG9wdGlvbnMuaW5kZW50X3NpemU7XG4gIHRoaXMud3JhcF9saW5lX2xlbmd0aCA9IG9wdGlvbnMud3JhcF9saW5lX2xlbmd0aDtcbiAgdGhpcy5pbmRlbnRfZW1wdHlfbGluZXMgPSBvcHRpb25zLmluZGVudF9lbXB0eV9saW5lcztcbiAgdGhpcy5fX2xpbmVzID0gW107XG4gIHRoaXMucHJldmlvdXNfbGluZSA9IG51bGw7XG4gIHRoaXMuY3VycmVudF9saW5lID0gbnVsbDtcbiAgdGhpcy5uZXh0X2xpbmUgPSBuZXcgT3V0cHV0TGluZSh0aGlzKTtcbiAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UgPSBmYWxzZTtcbiAgdGhpcy5wcmV2aW91c190b2tlbl93cmFwcGVkID0gZmFsc2U7XG4gIC8vIGluaXRpYWxpemVcbiAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG59XG5cbk91dHB1dC5wcm90b3R5cGUuX19hZGRfb3V0cHV0bGluZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnByZXZpb3VzX2xpbmUgPSB0aGlzLmN1cnJlbnRfbGluZTtcbiAgdGhpcy5jdXJyZW50X2xpbmUgPSB0aGlzLm5leHRfbGluZS5jbG9uZV9lbXB0eSgpO1xuICB0aGlzLl9fbGluZXMucHVzaCh0aGlzLmN1cnJlbnRfbGluZSk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9saW5lX251bWJlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX2xpbmVzLmxlbmd0aDtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0X2luZGVudF9zdHJpbmcgPSBmdW5jdGlvbihpbmRlbnQsIGNvbHVtbikge1xuICByZXR1cm4gdGhpcy5fX2luZGVudF9jYWNoZS5nZXRfaW5kZW50X3N0cmluZyhpbmRlbnQsIGNvbHVtbik7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9pbmRlbnRfc2l6ZSA9IGZ1bmN0aW9uKGluZGVudCwgY29sdW1uKSB7XG4gIHJldHVybiB0aGlzLl9faW5kZW50X2NhY2hlLmdldF9pbmRlbnRfc2l6ZShpbmRlbnQsIGNvbHVtbik7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmlzX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5wcmV2aW91c19saW5lICYmIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmFkZF9uZXdfbGluZSA9IGZ1bmN0aW9uKGZvcmNlX25ld2xpbmUpIHtcbiAgLy8gbmV2ZXIgbmV3bGluZSBhdCB0aGUgc3RhcnQgb2YgZmlsZVxuICAvLyBvdGhlcndpc2UsIG5ld2xpbmUgb25seSBpZiB3ZSBkaWRuJ3QganVzdCBhZGQgb25lIG9yIHdlJ3JlIGZvcmNlZFxuICBpZiAodGhpcy5pc19lbXB0eSgpIHx8XG4gICAgKCFmb3JjZV9uZXdsaW5lICYmIHRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaWYgcmF3IG91dHB1dCBpcyBlbmFibGVkLCBkb24ndCBwcmludCBhZGRpdGlvbmFsIG5ld2xpbmVzLFxuICAvLyBidXQgc3RpbGwgcmV0dXJuIFRydWUgYXMgdGhvdWdoIHlvdSBoYWRcbiAgaWYgKCF0aGlzLnJhdykge1xuICAgIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5nZXRfY29kZSA9IGZ1bmN0aW9uKGVvbCkge1xuICB0aGlzLnRyaW0odHJ1ZSk7XG5cbiAgLy8gaGFuZGxlIHNvbWUgZWRnZSBjYXNlcyB3aGVyZSB0aGUgbGFzdCB0b2tlbnNcbiAgLy8gaGFzIHRleHQgdGhhdCBlbmRzIHdpdGggbmV3bGluZShzKVxuICB2YXIgbGFzdF9pdGVtID0gdGhpcy5jdXJyZW50X2xpbmUucG9wKCk7XG4gIGlmIChsYXN0X2l0ZW0pIHtcbiAgICBpZiAobGFzdF9pdGVtW2xhc3RfaXRlbS5sZW5ndGggLSAxXSA9PT0gJ1xcbicpIHtcbiAgICAgIGxhc3RfaXRlbSA9IGxhc3RfaXRlbS5yZXBsYWNlKC9cXG4rJC9nLCAnJyk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2gobGFzdF9pdGVtKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9lbmRfd2l0aF9uZXdsaW5lKSB7XG4gICAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG4gIH1cblxuICB2YXIgc3dlZXRfY29kZSA9IHRoaXMuX19saW5lcy5qb2luKCdcXG4nKTtcblxuICBpZiAoZW9sICE9PSAnXFxuJykge1xuICAgIHN3ZWV0X2NvZGUgPSBzd2VldF9jb2RlLnJlcGxhY2UoL1tcXG5dL2csIGVvbCk7XG4gIH1cbiAgcmV0dXJuIHN3ZWV0X2NvZGU7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnNldF93cmFwX3BvaW50ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY3VycmVudF9saW5lLl9zZXRfd3JhcF9wb2ludCgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5zZXRfaW5kZW50ID0gZnVuY3Rpb24oaW5kZW50LCBhbGlnbm1lbnQpIHtcbiAgaW5kZW50ID0gaW5kZW50IHx8IDA7XG4gIGFsaWdubWVudCA9IGFsaWdubWVudCB8fCAwO1xuXG4gIC8vIE5leHQgbGluZSBzdG9yZXMgYWxpZ25tZW50IHZhbHVlc1xuICB0aGlzLm5leHRfbGluZS5zZXRfaW5kZW50KGluZGVudCwgYWxpZ25tZW50KTtcblxuICAvLyBOZXZlciBpbmRlbnQgeW91ciBmaXJzdCBvdXRwdXQgaW5kZW50IGF0IHRoZSBzdGFydCBvZiB0aGUgZmlsZVxuICBpZiAodGhpcy5fX2xpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KGluZGVudCwgYWxpZ25tZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQoKTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5hZGRfcmF3X3Rva2VuID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCB0b2tlbi5uZXdsaW5lczsgeCsrKSB7XG4gICAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG4gIH1cbiAgdGhpcy5jdXJyZW50X2xpbmUuc2V0X2luZGVudCgtMSk7XG4gIHRoaXMuY3VycmVudF9saW5lLnB1c2godG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUpO1xuICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHRva2VuLnRleHQpO1xuICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICB0aGlzLm5vbl9icmVha2luZ19zcGFjZSA9IGZhbHNlO1xuICB0aGlzLnByZXZpb3VzX3Rva2VuX3dyYXBwZWQgPSBmYWxzZTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuYWRkX3Rva2VuID0gZnVuY3Rpb24ocHJpbnRhYmxlX3Rva2VuKSB7XG4gIHRoaXMuX19hZGRfc3BhY2VfYmVmb3JlX3Rva2VuKCk7XG4gIHRoaXMuY3VycmVudF9saW5lLnB1c2gocHJpbnRhYmxlX3Rva2VuKTtcbiAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UgPSBmYWxzZTtcbiAgdGhpcy5wcmV2aW91c190b2tlbl93cmFwcGVkID0gdGhpcy5jdXJyZW50X2xpbmUuX2FsbG93X3dyYXAoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuX19hZGRfc3BhY2VfYmVmb3JlX3Rva2VuID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiAmJiAhdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgIGlmICghdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UpIHtcbiAgICAgIHRoaXMuc2V0X3dyYXBfcG9pbnQoKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCgnICcpO1xuICB9XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnJlbW92ZV9pbmRlbnQgPSBmdW5jdGlvbihpbmRleCkge1xuICB2YXIgb3V0cHV0X2xlbmd0aCA9IHRoaXMuX19saW5lcy5sZW5ndGg7XG4gIHdoaWxlIChpbmRleCA8IG91dHB1dF9sZW5ndGgpIHtcbiAgICB0aGlzLl9fbGluZXNbaW5kZXhdLl9yZW1vdmVfaW5kZW50KCk7XG4gICAgaW5kZXgrKztcbiAgfVxuICB0aGlzLmN1cnJlbnRfbGluZS5fcmVtb3ZlX3dyYXBfaW5kZW50KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbihlYXRfbmV3bGluZXMpIHtcbiAgZWF0X25ld2xpbmVzID0gKGVhdF9uZXdsaW5lcyA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogZWF0X25ld2xpbmVzO1xuXG4gIHRoaXMuY3VycmVudF9saW5lLnRyaW0oKTtcblxuICB3aGlsZSAoZWF0X25ld2xpbmVzICYmIHRoaXMuX19saW5lcy5sZW5ndGggPiAxICYmXG4gICAgdGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKSkge1xuICAgIHRoaXMuX19saW5lcy5wb3AoKTtcbiAgICB0aGlzLmN1cnJlbnRfbGluZSA9IHRoaXMuX19saW5lc1t0aGlzLl9fbGluZXMubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5jdXJyZW50X2xpbmUudHJpbSgpO1xuICB9XG5cbiAgdGhpcy5wcmV2aW91c19saW5lID0gdGhpcy5fX2xpbmVzLmxlbmd0aCA+IDEgP1xuICAgIHRoaXMuX19saW5lc1t0aGlzLl9fbGluZXMubGVuZ3RoIC0gMl0gOiBudWxsO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5qdXN0X2FkZGVkX25ld2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmp1c3RfYWRkZWRfYmxhbmtsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmlzX2VtcHR5KCkgfHxcbiAgICAodGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKSAmJiB0aGlzLnByZXZpb3VzX2xpbmUuaXNfZW1wdHkoKSk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmVuc3VyZV9lbXB0eV9saW5lX2Fib3ZlID0gZnVuY3Rpb24oc3RhcnRzX3dpdGgsIGVuZHNfd2l0aCkge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fbGluZXMubGVuZ3RoIC0gMjtcbiAgd2hpbGUgKGluZGV4ID49IDApIHtcbiAgICB2YXIgcG90ZW50aWFsRW1wdHlMaW5lID0gdGhpcy5fX2xpbmVzW2luZGV4XTtcbiAgICBpZiAocG90ZW50aWFsRW1wdHlMaW5lLmlzX2VtcHR5KCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAocG90ZW50aWFsRW1wdHlMaW5lLml0ZW0oMCkuaW5kZXhPZihzdGFydHNfd2l0aCkgIT09IDAgJiZcbiAgICAgIHBvdGVudGlhbEVtcHR5TGluZS5pdGVtKC0xKSAhPT0gZW5kc193aXRoKSB7XG4gICAgICB0aGlzLl9fbGluZXMuc3BsaWNlKGluZGV4ICsgMSwgMCwgbmV3IE91dHB1dExpbmUodGhpcykpO1xuICAgICAgdGhpcy5wcmV2aW91c19saW5lID0gdGhpcy5fX2xpbmVzW3RoaXMuX19saW5lcy5sZW5ndGggLSAyXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleC0tO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5PdXRwdXQgPSBPdXRwdXQ7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gVG9rZW4odHlwZSwgdGV4dCwgbmV3bGluZXMsIHdoaXRlc3BhY2VfYmVmb3JlKSB7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMudGV4dCA9IHRleHQ7XG5cbiAgLy8gY29tbWVudHNfYmVmb3JlIGFyZVxuICAvLyBjb21tZW50cyB0aGF0IGhhdmUgYSBuZXcgbGluZSBiZWZvcmUgdGhlbVxuICAvLyBhbmQgbWF5IG9yIG1heSBub3QgaGF2ZSBhIG5ld2xpbmUgYWZ0ZXJcbiAgLy8gdGhpcyBpcyBhIHNldCBvZiBjb21tZW50cyBiZWZvcmVcbiAgdGhpcy5jb21tZW50c19iZWZvcmUgPSBudWxsOyAvKiBpbmxpbmUgY29tbWVudCovXG5cblxuICAvLyB0aGlzLmNvbW1lbnRzX2FmdGVyID0gIG5ldyBUb2tlblN0cmVhbSgpOyAvLyBubyBuZXcgbGluZSBiZWZvcmUgYW5kIG5ld2xpbmUgYWZ0ZXJcbiAgdGhpcy5uZXdsaW5lcyA9IG5ld2xpbmVzIHx8IDA7XG4gIHRoaXMud2hpdGVzcGFjZV9iZWZvcmUgPSB3aGl0ZXNwYWNlX2JlZm9yZSB8fCAnJztcbiAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbiAgdGhpcy5vcGVuZWQgPSBudWxsO1xuICB0aGlzLmNsb3NlZCA9IG51bGw7XG4gIHRoaXMuZGlyZWN0aXZlcyA9IG51bGw7XG59XG5cblxubW9kdWxlLmV4cG9ydHMuVG9rZW4gPSBUb2tlbjtcblxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG4vKiBqc2hpbnQgbm9kZTogdHJ1ZSwgY3VybHk6IGZhbHNlICovXG4vLyBQYXJ0cyBvZiB0aGlzIHNlY3Rpb24gb2YgY29kZSBpcyB0YWtlbiBmcm9tIGFjb3JuLlxuLy9cbi8vIEFjb3JuIHdhcyB3cml0dGVuIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVFxuLy8gbGljZW5zZS4gVGhlIFVuaWNvZGUgcmVnZXhwcyAoZm9yIGlkZW50aWZpZXJzIGFuZCB3aGl0ZXNwYWNlKSB3ZXJlXG4vLyB0YWtlbiBmcm9tIFtFc3ByaW1hXShodHRwOi8vZXNwcmltYS5vcmcpIGJ5IEFyaXlhIEhpZGF5YXQuXG4vL1xuLy8gR2l0IHJlcG9zaXRvcmllcyBmb3IgQWNvcm4gYXJlIGF2YWlsYWJsZSBhdFxuLy9cbi8vICAgICBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2dpdC9hY29yblxuLy8gICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL2Fjb3JuLmdpdFxuXG4vLyAjIyBDaGFyYWN0ZXIgY2F0ZWdvcmllc1xuXG5cblxuXG4vLyBhY29ybiB1c2VkIGNoYXIgY29kZXMgdG8gc3F1ZWV6ZSB0aGUgbGFzdCBiaXQgb2YgcGVyZm9ybWFuY2Ugb3V0XG4vLyBCZWF1dGlmaWVyIGlzIG9rYXkgd2l0aG91dCB0aGF0LCBzbyB3ZSdyZSB1c2luZyByZWdleFxuLy8gcGVybWl0ICMgKDIzKSwgJCAoMzYpLCBhbmQgQCAoNjQpLiBAIGlzIHVzZWQgaW4gRVM3IGRlY29yYXRvcnMuXG4vLyA2NSB0aHJvdWdoIDkxIGFyZSB1cHBlcmNhc2UgbGV0dGVycy5cbi8vIHBlcm1pdCBfICg5NSkuXG4vLyA5NyB0aHJvdWdoIDEyMyBhcmUgbG93ZXJjYXNlIGxldHRlcnMuXG52YXIgYmFzZUFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBcIlxcXFx4MjNcXFxceDI0XFxcXHg0MFxcXFx4NDEtXFxcXHg1YVxcXFx4NWZcXFxceDYxLVxcXFx4N2FcIjtcblxuLy8gaW5zaWRlIGFuIGlkZW50aWZpZXIgQCBpcyBub3QgYWxsb3dlZCBidXQgMC05IGFyZS5cbnZhciBiYXNlQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxcXFx4MjRcXFxceDMwLVxcXFx4MzlcXFxceDQxLVxcXFx4NWFcXFxceDVmXFxcXHg2MS1cXFxceDdhXCI7XG5cbi8vIEJpZyB1Z2x5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBtYXRjaCBjaGFyYWN0ZXJzIGluIHRoZVxuLy8gd2hpdGVzcGFjZSwgaWRlbnRpZmllciwgYW5kIGlkZW50aWZpZXItc3RhcnQgY2F0ZWdvcmllcy4gVGhlc2Vcbi8vIGFyZSBvbmx5IGFwcGxpZWQgd2hlbiBhIGNoYXJhY3RlciBpcyBmb3VuZCB0byBhY3R1YWxseSBoYXZlIGFcbi8vIGNvZGUgcG9pbnQgYWJvdmUgMTI4LlxudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBcIlxcXFx4YWFcXFxceGI1XFxcXHhiYVxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhmNlxcXFx4ZjgtXFxcXHUwMmMxXFxcXHUwMmM2LVxcXFx1MDJkMVxcXFx1MDJlMC1cXFxcdTAyZTRcXFxcdTAyZWNcXFxcdTAyZWVcXFxcdTAzNzAtXFxcXHUwMzc0XFxcXHUwMzc2XFxcXHUwMzc3XFxcXHUwMzdhLVxcXFx1MDM3ZFxcXFx1MDM4NlxcXFx1MDM4OC1cXFxcdTAzOGFcXFxcdTAzOGNcXFxcdTAzOGUtXFxcXHUwM2ExXFxcXHUwM2EzLVxcXFx1MDNmNVxcXFx1MDNmNy1cXFxcdTA0ODFcXFxcdTA0OGEtXFxcXHUwNTI3XFxcXHUwNTMxLVxcXFx1MDU1NlxcXFx1MDU1OVxcXFx1MDU2MS1cXFxcdTA1ODdcXFxcdTA1ZDAtXFxcXHUwNWVhXFxcXHUwNWYwLVxcXFx1MDVmMlxcXFx1MDYyMC1cXFxcdTA2NGFcXFxcdTA2NmVcXFxcdTA2NmZcXFxcdTA2NzEtXFxcXHUwNmQzXFxcXHUwNmQ1XFxcXHUwNmU1XFxcXHUwNmU2XFxcXHUwNmVlXFxcXHUwNmVmXFxcXHUwNmZhLVxcXFx1MDZmY1xcXFx1MDZmZlxcXFx1MDcxMFxcXFx1MDcxMi1cXFxcdTA3MmZcXFxcdTA3NGQtXFxcXHUwN2E1XFxcXHUwN2IxXFxcXHUwN2NhLVxcXFx1MDdlYVxcXFx1MDdmNFxcXFx1MDdmNVxcXFx1MDdmYVxcXFx1MDgwMC1cXFxcdTA4MTVcXFxcdTA4MWFcXFxcdTA4MjRcXFxcdTA4MjhcXFxcdTA4NDAtXFxcXHUwODU4XFxcXHUwOGEwXFxcXHUwOGEyLVxcXFx1MDhhY1xcXFx1MDkwNC1cXFxcdTA5MzlcXFxcdTA5M2RcXFxcdTA5NTBcXFxcdTA5NTgtXFxcXHUwOTYxXFxcXHUwOTcxLVxcXFx1MDk3N1xcXFx1MDk3OS1cXFxcdTA5N2ZcXFxcdTA5ODUtXFxcXHUwOThjXFxcXHUwOThmXFxcXHUwOTkwXFxcXHUwOTkzLVxcXFx1MDlhOFxcXFx1MDlhYS1cXFxcdTA5YjBcXFxcdTA5YjJcXFxcdTA5YjYtXFxcXHUwOWI5XFxcXHUwOWJkXFxcXHUwOWNlXFxcXHUwOWRjXFxcXHUwOWRkXFxcXHUwOWRmLVxcXFx1MDllMVxcXFx1MDlmMFxcXFx1MDlmMVxcXFx1MGEwNS1cXFxcdTBhMGFcXFxcdTBhMGZcXFxcdTBhMTBcXFxcdTBhMTMtXFxcXHUwYTI4XFxcXHUwYTJhLVxcXFx1MGEzMFxcXFx1MGEzMlxcXFx1MGEzM1xcXFx1MGEzNVxcXFx1MGEzNlxcXFx1MGEzOFxcXFx1MGEzOVxcXFx1MGE1OS1cXFxcdTBhNWNcXFxcdTBhNWVcXFxcdTBhNzItXFxcXHUwYTc0XFxcXHUwYTg1LVxcXFx1MGE4ZFxcXFx1MGE4Zi1cXFxcdTBhOTFcXFxcdTBhOTMtXFxcXHUwYWE4XFxcXHUwYWFhLVxcXFx1MGFiMFxcXFx1MGFiMlxcXFx1MGFiM1xcXFx1MGFiNS1cXFxcdTBhYjlcXFxcdTBhYmRcXFxcdTBhZDBcXFxcdTBhZTBcXFxcdTBhZTFcXFxcdTBiMDUtXFxcXHUwYjBjXFxcXHUwYjBmXFxcXHUwYjEwXFxcXHUwYjEzLVxcXFx1MGIyOFxcXFx1MGIyYS1cXFxcdTBiMzBcXFxcdTBiMzJcXFxcdTBiMzNcXFxcdTBiMzUtXFxcXHUwYjM5XFxcXHUwYjNkXFxcXHUwYjVjXFxcXHUwYjVkXFxcXHUwYjVmLVxcXFx1MGI2MVxcXFx1MGI3MVxcXFx1MGI4M1xcXFx1MGI4NS1cXFxcdTBiOGFcXFxcdTBiOGUtXFxcXHUwYjkwXFxcXHUwYjkyLVxcXFx1MGI5NVxcXFx1MGI5OVxcXFx1MGI5YVxcXFx1MGI5Y1xcXFx1MGI5ZVxcXFx1MGI5ZlxcXFx1MGJhM1xcXFx1MGJhNFxcXFx1MGJhOC1cXFxcdTBiYWFcXFxcdTBiYWUtXFxcXHUwYmI5XFxcXHUwYmQwXFxcXHUwYzA1LVxcXFx1MGMwY1xcXFx1MGMwZS1cXFxcdTBjMTBcXFxcdTBjMTItXFxcXHUwYzI4XFxcXHUwYzJhLVxcXFx1MGMzM1xcXFx1MGMzNS1cXFxcdTBjMzlcXFxcdTBjM2RcXFxcdTBjNThcXFxcdTBjNTlcXFxcdTBjNjBcXFxcdTBjNjFcXFxcdTBjODUtXFxcXHUwYzhjXFxcXHUwYzhlLVxcXFx1MGM5MFxcXFx1MGM5Mi1cXFxcdTBjYThcXFxcdTBjYWEtXFxcXHUwY2IzXFxcXHUwY2I1LVxcXFx1MGNiOVxcXFx1MGNiZFxcXFx1MGNkZVxcXFx1MGNlMFxcXFx1MGNlMVxcXFx1MGNmMVxcXFx1MGNmMlxcXFx1MGQwNS1cXFxcdTBkMGNcXFxcdTBkMGUtXFxcXHUwZDEwXFxcXHUwZDEyLVxcXFx1MGQzYVxcXFx1MGQzZFxcXFx1MGQ0ZVxcXFx1MGQ2MFxcXFx1MGQ2MVxcXFx1MGQ3YS1cXFxcdTBkN2ZcXFxcdTBkODUtXFxcXHUwZDk2XFxcXHUwZDlhLVxcXFx1MGRiMVxcXFx1MGRiMy1cXFxcdTBkYmJcXFxcdTBkYmRcXFxcdTBkYzAtXFxcXHUwZGM2XFxcXHUwZTAxLVxcXFx1MGUzMFxcXFx1MGUzMlxcXFx1MGUzM1xcXFx1MGU0MC1cXFxcdTBlNDZcXFxcdTBlODFcXFxcdTBlODJcXFxcdTBlODRcXFxcdTBlODdcXFxcdTBlODhcXFxcdTBlOGFcXFxcdTBlOGRcXFxcdTBlOTQtXFxcXHUwZTk3XFxcXHUwZTk5LVxcXFx1MGU5ZlxcXFx1MGVhMS1cXFxcdTBlYTNcXFxcdTBlYTVcXFxcdTBlYTdcXFxcdTBlYWFcXFxcdTBlYWJcXFxcdTBlYWQtXFxcXHUwZWIwXFxcXHUwZWIyXFxcXHUwZWIzXFxcXHUwZWJkXFxcXHUwZWMwLVxcXFx1MGVjNFxcXFx1MGVjNlxcXFx1MGVkYy1cXFxcdTBlZGZcXFxcdTBmMDBcXFxcdTBmNDAtXFxcXHUwZjQ3XFxcXHUwZjQ5LVxcXFx1MGY2Y1xcXFx1MGY4OC1cXFxcdTBmOGNcXFxcdTEwMDAtXFxcXHUxMDJhXFxcXHUxMDNmXFxcXHUxMDUwLVxcXFx1MTA1NVxcXFx1MTA1YS1cXFxcdTEwNWRcXFxcdTEwNjFcXFxcdTEwNjVcXFxcdTEwNjZcXFxcdTEwNmUtXFxcXHUxMDcwXFxcXHUxMDc1LVxcXFx1MTA4MVxcXFx1MTA4ZVxcXFx1MTBhMC1cXFxcdTEwYzVcXFxcdTEwYzdcXFxcdTEwY2RcXFxcdTEwZDAtXFxcXHUxMGZhXFxcXHUxMGZjLVxcXFx1MTI0OFxcXFx1MTI0YS1cXFxcdTEyNGRcXFxcdTEyNTAtXFxcXHUxMjU2XFxcXHUxMjU4XFxcXHUxMjVhLVxcXFx1MTI1ZFxcXFx1MTI2MC1cXFxcdTEyODhcXFxcdTEyOGEtXFxcXHUxMjhkXFxcXHUxMjkwLVxcXFx1MTJiMFxcXFx1MTJiMi1cXFxcdTEyYjVcXFxcdTEyYjgtXFxcXHUxMmJlXFxcXHUxMmMwXFxcXHUxMmMyLVxcXFx1MTJjNVxcXFx1MTJjOC1cXFxcdTEyZDZcXFxcdTEyZDgtXFxcXHUxMzEwXFxcXHUxMzEyLVxcXFx1MTMxNVxcXFx1MTMxOC1cXFxcdTEzNWFcXFxcdTEzODAtXFxcXHUxMzhmXFxcXHUxM2EwLVxcXFx1MTNmNFxcXFx1MTQwMS1cXFxcdTE2NmNcXFxcdTE2NmYtXFxcXHUxNjdmXFxcXHUxNjgxLVxcXFx1MTY5YVxcXFx1MTZhMC1cXFxcdTE2ZWFcXFxcdTE2ZWUtXFxcXHUxNmYwXFxcXHUxNzAwLVxcXFx1MTcwY1xcXFx1MTcwZS1cXFxcdTE3MTFcXFxcdTE3MjAtXFxcXHUxNzMxXFxcXHUxNzQwLVxcXFx1MTc1MVxcXFx1MTc2MC1cXFxcdTE3NmNcXFxcdTE3NmUtXFxcXHUxNzcwXFxcXHUxNzgwLVxcXFx1MTdiM1xcXFx1MTdkN1xcXFx1MTdkY1xcXFx1MTgyMC1cXFxcdTE4NzdcXFxcdTE4ODAtXFxcXHUxOGE4XFxcXHUxOGFhXFxcXHUxOGIwLVxcXFx1MThmNVxcXFx1MTkwMC1cXFxcdTE5MWNcXFxcdTE5NTAtXFxcXHUxOTZkXFxcXHUxOTcwLVxcXFx1MTk3NFxcXFx1MTk4MC1cXFxcdTE5YWJcXFxcdTE5YzEtXFxcXHUxOWM3XFxcXHUxYTAwLVxcXFx1MWExNlxcXFx1MWEyMC1cXFxcdTFhNTRcXFxcdTFhYTdcXFxcdTFiMDUtXFxcXHUxYjMzXFxcXHUxYjQ1LVxcXFx1MWI0YlxcXFx1MWI4My1cXFxcdTFiYTBcXFxcdTFiYWVcXFxcdTFiYWZcXFxcdTFiYmEtXFxcXHUxYmU1XFxcXHUxYzAwLVxcXFx1MWMyM1xcXFx1MWM0ZC1cXFxcdTFjNGZcXFxcdTFjNWEtXFxcXHUxYzdkXFxcXHUxY2U5LVxcXFx1MWNlY1xcXFx1MWNlZS1cXFxcdTFjZjFcXFxcdTFjZjVcXFxcdTFjZjZcXFxcdTFkMDAtXFxcXHUxZGJmXFxcXHUxZTAwLVxcXFx1MWYxNVxcXFx1MWYxOC1cXFxcdTFmMWRcXFxcdTFmMjAtXFxcXHUxZjQ1XFxcXHUxZjQ4LVxcXFx1MWY0ZFxcXFx1MWY1MC1cXFxcdTFmNTdcXFxcdTFmNTlcXFxcdTFmNWJcXFxcdTFmNWRcXFxcdTFmNWYtXFxcXHUxZjdkXFxcXHUxZjgwLVxcXFx1MWZiNFxcXFx1MWZiNi1cXFxcdTFmYmNcXFxcdTFmYmVcXFxcdTFmYzItXFxcXHUxZmM0XFxcXHUxZmM2LVxcXFx1MWZjY1xcXFx1MWZkMC1cXFxcdTFmZDNcXFxcdTFmZDYtXFxcXHUxZmRiXFxcXHUxZmUwLVxcXFx1MWZlY1xcXFx1MWZmMi1cXFxcdTFmZjRcXFxcdTFmZjYtXFxcXHUxZmZjXFxcXHUyMDcxXFxcXHUyMDdmXFxcXHUyMDkwLVxcXFx1MjA5Y1xcXFx1MjEwMlxcXFx1MjEwN1xcXFx1MjEwYS1cXFxcdTIxMTNcXFxcdTIxMTVcXFxcdTIxMTktXFxcXHUyMTFkXFxcXHUyMTI0XFxcXHUyMTI2XFxcXHUyMTI4XFxcXHUyMTJhLVxcXFx1MjEyZFxcXFx1MjEyZi1cXFxcdTIxMzlcXFxcdTIxM2MtXFxcXHUyMTNmXFxcXHUyMTQ1LVxcXFx1MjE0OVxcXFx1MjE0ZVxcXFx1MjE2MC1cXFxcdTIxODhcXFxcdTJjMDAtXFxcXHUyYzJlXFxcXHUyYzMwLVxcXFx1MmM1ZVxcXFx1MmM2MC1cXFxcdTJjZTRcXFxcdTJjZWItXFxcXHUyY2VlXFxcXHUyY2YyXFxcXHUyY2YzXFxcXHUyZDAwLVxcXFx1MmQyNVxcXFx1MmQyN1xcXFx1MmQyZFxcXFx1MmQzMC1cXFxcdTJkNjdcXFxcdTJkNmZcXFxcdTJkODAtXFxcXHUyZDk2XFxcXHUyZGEwLVxcXFx1MmRhNlxcXFx1MmRhOC1cXFxcdTJkYWVcXFxcdTJkYjAtXFxcXHUyZGI2XFxcXHUyZGI4LVxcXFx1MmRiZVxcXFx1MmRjMC1cXFxcdTJkYzZcXFxcdTJkYzgtXFxcXHUyZGNlXFxcXHUyZGQwLVxcXFx1MmRkNlxcXFx1MmRkOC1cXFxcdTJkZGVcXFxcdTJlMmZcXFxcdTMwMDUtXFxcXHUzMDA3XFxcXHUzMDIxLVxcXFx1MzAyOVxcXFx1MzAzMS1cXFxcdTMwMzVcXFxcdTMwMzgtXFxcXHUzMDNjXFxcXHUzMDQxLVxcXFx1MzA5NlxcXFx1MzA5ZC1cXFxcdTMwOWZcXFxcdTMwYTEtXFxcXHUzMGZhXFxcXHUzMGZjLVxcXFx1MzBmZlxcXFx1MzEwNS1cXFxcdTMxMmRcXFxcdTMxMzEtXFxcXHUzMThlXFxcXHUzMWEwLVxcXFx1MzFiYVxcXFx1MzFmMC1cXFxcdTMxZmZcXFxcdTM0MDAtXFxcXHU0ZGI1XFxcXHU0ZTAwLVxcXFx1OWZjY1xcXFx1YTAwMC1cXFxcdWE0OGNcXFxcdWE0ZDAtXFxcXHVhNGZkXFxcXHVhNTAwLVxcXFx1YTYwY1xcXFx1YTYxMC1cXFxcdWE2MWZcXFxcdWE2MmFcXFxcdWE2MmJcXFxcdWE2NDAtXFxcXHVhNjZlXFxcXHVhNjdmLVxcXFx1YTY5N1xcXFx1YTZhMC1cXFxcdWE2ZWZcXFxcdWE3MTctXFxcXHVhNzFmXFxcXHVhNzIyLVxcXFx1YTc4OFxcXFx1YTc4Yi1cXFxcdWE3OGVcXFxcdWE3OTAtXFxcXHVhNzkzXFxcXHVhN2EwLVxcXFx1YTdhYVxcXFx1YTdmOC1cXFxcdWE4MDFcXFxcdWE4MDMtXFxcXHVhODA1XFxcXHVhODA3LVxcXFx1YTgwYVxcXFx1YTgwYy1cXFxcdWE4MjJcXFxcdWE4NDAtXFxcXHVhODczXFxcXHVhODgyLVxcXFx1YThiM1xcXFx1YThmMi1cXFxcdWE4ZjdcXFxcdWE4ZmJcXFxcdWE5MGEtXFxcXHVhOTI1XFxcXHVhOTMwLVxcXFx1YTk0NlxcXFx1YTk2MC1cXFxcdWE5N2NcXFxcdWE5ODQtXFxcXHVhOWIyXFxcXHVhOWNmXFxcXHVhYTAwLVxcXFx1YWEyOFxcXFx1YWE0MC1cXFxcdWFhNDJcXFxcdWFhNDQtXFxcXHVhYTRiXFxcXHVhYTYwLVxcXFx1YWE3NlxcXFx1YWE3YVxcXFx1YWE4MC1cXFxcdWFhYWZcXFxcdWFhYjFcXFxcdWFhYjVcXFxcdWFhYjZcXFxcdWFhYjktXFxcXHVhYWJkXFxcXHVhYWMwXFxcXHVhYWMyXFxcXHVhYWRiLVxcXFx1YWFkZFxcXFx1YWFlMC1cXFxcdWFhZWFcXFxcdWFhZjItXFxcXHVhYWY0XFxcXHVhYjAxLVxcXFx1YWIwNlxcXFx1YWIwOS1cXFxcdWFiMGVcXFxcdWFiMTEtXFxcXHVhYjE2XFxcXHVhYjIwLVxcXFx1YWIyNlxcXFx1YWIyOC1cXFxcdWFiMmVcXFxcdWFiYzAtXFxcXHVhYmUyXFxcXHVhYzAwLVxcXFx1ZDdhM1xcXFx1ZDdiMC1cXFxcdWQ3YzZcXFxcdWQ3Y2ItXFxcXHVkN2ZiXFxcXHVmOTAwLVxcXFx1ZmE2ZFxcXFx1ZmE3MC1cXFxcdWZhZDlcXFxcdWZiMDAtXFxcXHVmYjA2XFxcXHVmYjEzLVxcXFx1ZmIxN1xcXFx1ZmIxZFxcXFx1ZmIxZi1cXFxcdWZiMjhcXFxcdWZiMmEtXFxcXHVmYjM2XFxcXHVmYjM4LVxcXFx1ZmIzY1xcXFx1ZmIzZVxcXFx1ZmI0MFxcXFx1ZmI0MVxcXFx1ZmI0M1xcXFx1ZmI0NFxcXFx1ZmI0Ni1cXFxcdWZiYjFcXFxcdWZiZDMtXFxcXHVmZDNkXFxcXHVmZDUwLVxcXFx1ZmQ4ZlxcXFx1ZmQ5Mi1cXFxcdWZkYzdcXFxcdWZkZjAtXFxcXHVmZGZiXFxcXHVmZTcwLVxcXFx1ZmU3NFxcXFx1ZmU3Ni1cXFxcdWZlZmNcXFxcdWZmMjEtXFxcXHVmZjNhXFxcXHVmZjQxLVxcXFx1ZmY1YVxcXFx1ZmY2Ni1cXFxcdWZmYmVcXFxcdWZmYzItXFxcXHVmZmM3XFxcXHVmZmNhLVxcXFx1ZmZjZlxcXFx1ZmZkMi1cXFxcdWZmZDdcXFxcdWZmZGEtXFxcXHVmZmRjXCI7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxcXFx1MDMwMC1cXFxcdTAzNmZcXFxcdTA0ODMtXFxcXHUwNDg3XFxcXHUwNTkxLVxcXFx1MDViZFxcXFx1MDViZlxcXFx1MDVjMVxcXFx1MDVjMlxcXFx1MDVjNFxcXFx1MDVjNVxcXFx1MDVjN1xcXFx1MDYxMC1cXFxcdTA2MWFcXFxcdTA2MjAtXFxcXHUwNjQ5XFxcXHUwNjcyLVxcXFx1MDZkM1xcXFx1MDZlNy1cXFxcdTA2ZThcXFxcdTA2ZmItXFxcXHUwNmZjXFxcXHUwNzMwLVxcXFx1MDc0YVxcXFx1MDgwMC1cXFxcdTA4MTRcXFxcdTA4MWItXFxcXHUwODIzXFxcXHUwODI1LVxcXFx1MDgyN1xcXFx1MDgyOS1cXFxcdTA4MmRcXFxcdTA4NDAtXFxcXHUwODU3XFxcXHUwOGU0LVxcXFx1MDhmZVxcXFx1MDkwMC1cXFxcdTA5MDNcXFxcdTA5M2EtXFxcXHUwOTNjXFxcXHUwOTNlLVxcXFx1MDk0ZlxcXFx1MDk1MS1cXFxcdTA5NTdcXFxcdTA5NjItXFxcXHUwOTYzXFxcXHUwOTY2LVxcXFx1MDk2ZlxcXFx1MDk4MS1cXFxcdTA5ODNcXFxcdTA5YmNcXFxcdTA5YmUtXFxcXHUwOWM0XFxcXHUwOWM3XFxcXHUwOWM4XFxcXHUwOWQ3XFxcXHUwOWRmLVxcXFx1MDllMFxcXFx1MGEwMS1cXFxcdTBhMDNcXFxcdTBhM2NcXFxcdTBhM2UtXFxcXHUwYTQyXFxcXHUwYTQ3XFxcXHUwYTQ4XFxcXHUwYTRiLVxcXFx1MGE0ZFxcXFx1MGE1MVxcXFx1MGE2Ni1cXFxcdTBhNzFcXFxcdTBhNzVcXFxcdTBhODEtXFxcXHUwYTgzXFxcXHUwYWJjXFxcXHUwYWJlLVxcXFx1MGFjNVxcXFx1MGFjNy1cXFxcdTBhYzlcXFxcdTBhY2ItXFxcXHUwYWNkXFxcXHUwYWUyLVxcXFx1MGFlM1xcXFx1MGFlNi1cXFxcdTBhZWZcXFxcdTBiMDEtXFxcXHUwYjAzXFxcXHUwYjNjXFxcXHUwYjNlLVxcXFx1MGI0NFxcXFx1MGI0N1xcXFx1MGI0OFxcXFx1MGI0Yi1cXFxcdTBiNGRcXFxcdTBiNTZcXFxcdTBiNTdcXFxcdTBiNWYtXFxcXHUwYjYwXFxcXHUwYjY2LVxcXFx1MGI2ZlxcXFx1MGI4MlxcXFx1MGJiZS1cXFxcdTBiYzJcXFxcdTBiYzYtXFxcXHUwYmM4XFxcXHUwYmNhLVxcXFx1MGJjZFxcXFx1MGJkN1xcXFx1MGJlNi1cXFxcdTBiZWZcXFxcdTBjMDEtXFxcXHUwYzAzXFxcXHUwYzQ2LVxcXFx1MGM0OFxcXFx1MGM0YS1cXFxcdTBjNGRcXFxcdTBjNTVcXFxcdTBjNTZcXFxcdTBjNjItXFxcXHUwYzYzXFxcXHUwYzY2LVxcXFx1MGM2ZlxcXFx1MGM4MlxcXFx1MGM4M1xcXFx1MGNiY1xcXFx1MGNiZS1cXFxcdTBjYzRcXFxcdTBjYzYtXFxcXHUwY2M4XFxcXHUwY2NhLVxcXFx1MGNjZFxcXFx1MGNkNVxcXFx1MGNkNlxcXFx1MGNlMi1cXFxcdTBjZTNcXFxcdTBjZTYtXFxcXHUwY2VmXFxcXHUwZDAyXFxcXHUwZDAzXFxcXHUwZDQ2LVxcXFx1MGQ0OFxcXFx1MGQ1N1xcXFx1MGQ2Mi1cXFxcdTBkNjNcXFxcdTBkNjYtXFxcXHUwZDZmXFxcXHUwZDgyXFxcXHUwZDgzXFxcXHUwZGNhXFxcXHUwZGNmLVxcXFx1MGRkNFxcXFx1MGRkNlxcXFx1MGRkOC1cXFxcdTBkZGZcXFxcdTBkZjJcXFxcdTBkZjNcXFxcdTBlMzQtXFxcXHUwZTNhXFxcXHUwZTQwLVxcXFx1MGU0NVxcXFx1MGU1MC1cXFxcdTBlNTlcXFxcdTBlYjQtXFxcXHUwZWI5XFxcXHUwZWM4LVxcXFx1MGVjZFxcXFx1MGVkMC1cXFxcdTBlZDlcXFxcdTBmMThcXFxcdTBmMTlcXFxcdTBmMjAtXFxcXHUwZjI5XFxcXHUwZjM1XFxcXHUwZjM3XFxcXHUwZjM5XFxcXHUwZjQxLVxcXFx1MGY0N1xcXFx1MGY3MS1cXFxcdTBmODRcXFxcdTBmODYtXFxcXHUwZjg3XFxcXHUwZjhkLVxcXFx1MGY5N1xcXFx1MGY5OS1cXFxcdTBmYmNcXFxcdTBmYzZcXFxcdTEwMDAtXFxcXHUxMDI5XFxcXHUxMDQwLVxcXFx1MTA0OVxcXFx1MTA2Ny1cXFxcdTEwNmRcXFxcdTEwNzEtXFxcXHUxMDc0XFxcXHUxMDgyLVxcXFx1MTA4ZFxcXFx1MTA4Zi1cXFxcdTEwOWRcXFxcdTEzNWQtXFxcXHUxMzVmXFxcXHUxNzBlLVxcXFx1MTcxMFxcXFx1MTcyMC1cXFxcdTE3MzBcXFxcdTE3NDAtXFxcXHUxNzUwXFxcXHUxNzcyXFxcXHUxNzczXFxcXHUxNzgwLVxcXFx1MTdiMlxcXFx1MTdkZFxcXFx1MTdlMC1cXFxcdTE3ZTlcXFxcdTE4MGItXFxcXHUxODBkXFxcXHUxODEwLVxcXFx1MTgxOVxcXFx1MTkyMC1cXFxcdTE5MmJcXFxcdTE5MzAtXFxcXHUxOTNiXFxcXHUxOTUxLVxcXFx1MTk2ZFxcXFx1MTliMC1cXFxcdTE5YzBcXFxcdTE5YzgtXFxcXHUxOWM5XFxcXHUxOWQwLVxcXFx1MTlkOVxcXFx1MWEwMC1cXFxcdTFhMTVcXFxcdTFhMjAtXFxcXHUxYTUzXFxcXHUxYTYwLVxcXFx1MWE3Y1xcXFx1MWE3Zi1cXFxcdTFhODlcXFxcdTFhOTAtXFxcXHUxYTk5XFxcXHUxYjQ2LVxcXFx1MWI0YlxcXFx1MWI1MC1cXFxcdTFiNTlcXFxcdTFiNmItXFxcXHUxYjczXFxcXHUxYmIwLVxcXFx1MWJiOVxcXFx1MWJlNi1cXFxcdTFiZjNcXFxcdTFjMDAtXFxcXHUxYzIyXFxcXHUxYzQwLVxcXFx1MWM0OVxcXFx1MWM1Yi1cXFxcdTFjN2RcXFxcdTFjZDAtXFxcXHUxY2QyXFxcXHUxZDAwLVxcXFx1MWRiZVxcXFx1MWUwMS1cXFxcdTFmMTVcXFxcdTIwMGNcXFxcdTIwMGRcXFxcdTIwM2ZcXFxcdTIwNDBcXFxcdTIwNTRcXFxcdTIwZDAtXFxcXHUyMGRjXFxcXHUyMGUxXFxcXHUyMGU1LVxcXFx1MjBmMFxcXFx1MmQ4MS1cXFxcdTJkOTZcXFxcdTJkZTAtXFxcXHUyZGZmXFxcXHUzMDIxLVxcXFx1MzAyOFxcXFx1MzA5OVxcXFx1MzA5YVxcXFx1YTY0MC1cXFxcdWE2NmRcXFxcdWE2NzQtXFxcXHVhNjdkXFxcXHVhNjlmXFxcXHVhNmYwLVxcXFx1YTZmMVxcXFx1YTdmOC1cXFxcdWE4MDBcXFxcdWE4MDZcXFxcdWE4MGJcXFxcdWE4MjMtXFxcXHVhODI3XFxcXHVhODgwLVxcXFx1YTg4MVxcXFx1YThiNC1cXFxcdWE4YzRcXFxcdWE4ZDAtXFxcXHVhOGQ5XFxcXHVhOGYzLVxcXFx1YThmN1xcXFx1YTkwMC1cXFxcdWE5MDlcXFxcdWE5MjYtXFxcXHVhOTJkXFxcXHVhOTMwLVxcXFx1YTk0NVxcXFx1YTk4MC1cXFxcdWE5ODNcXFxcdWE5YjMtXFxcXHVhOWMwXFxcXHVhYTAwLVxcXFx1YWEyN1xcXFx1YWE0MC1cXFxcdWFhNDFcXFxcdWFhNGMtXFxcXHVhYTRkXFxcXHVhYTUwLVxcXFx1YWE1OVxcXFx1YWE3YlxcXFx1YWFlMC1cXFxcdWFhZTlcXFxcdWFhZjItXFxcXHVhYWYzXFxcXHVhYmMwLVxcXFx1YWJlMVxcXFx1YWJlY1xcXFx1YWJlZFxcXFx1YWJmMC1cXFxcdWFiZjlcXFxcdWZiMjAtXFxcXHVmYjI4XFxcXHVmZTAwLVxcXFx1ZmUwZlxcXFx1ZmUyMC1cXFxcdWZlMjZcXFxcdWZlMzNcXFxcdWZlMzRcXFxcdWZlNGQtXFxcXHVmZTRmXFxcXHVmZjEwLVxcXFx1ZmYxOVxcXFx1ZmYzZlwiO1xuLy92YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIFwiXVwiKTtcbi8vdmFyIG5vbkFTQ0lJaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl1cIik7XG5cbnZhciB1bmljb2RlRXNjYXBlT3JDb2RlUG9pbnQgPSBcIlxcXFxcXFxcdVswLTlhLWZBLUZdezR9fFxcXFxcXFxcdVxcXFx7WzAtOWEtZkEtRl0rXFxcXH1cIjtcbnZhciBpZGVudGlmaWVyU3RhcnQgPSBcIig/OlwiICsgdW5pY29kZUVzY2FwZU9yQ29kZVBvaW50ICsgXCJ8W1wiICsgYmFzZUFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgXCJdKVwiO1xudmFyIGlkZW50aWZpZXJDaGFycyA9IFwiKD86XCIgKyB1bmljb2RlRXNjYXBlT3JDb2RlUG9pbnQgKyBcInxbXCIgKyBiYXNlQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl0pKlwiO1xuXG5leHBvcnRzLmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKGlkZW50aWZpZXJTdGFydCArIGlkZW50aWZpZXJDaGFycywgJ2cnKTtcbmV4cG9ydHMuaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChpZGVudGlmaWVyU3RhcnQpO1xuZXhwb3J0cy5pZGVudGlmaWVyTWF0Y2ggPSBuZXcgUmVnRXhwKFwiKD86XCIgKyB1bmljb2RlRXNjYXBlT3JDb2RlUG9pbnQgKyBcInxbXCIgKyBiYXNlQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl0pK1wiKTtcblxudmFyIG5vbkFTQ0lJd2hpdGVzcGFjZSA9IC9bXFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS87IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4vLyBXaGV0aGVyIGEgc2luZ2xlIGNoYXJhY3RlciBkZW5vdGVzIGEgbmV3bGluZS5cblxuZXhwb3J0cy5uZXdsaW5lID0gL1tcXG5cXHJcXHUyMDI4XFx1MjAyOV0vO1xuXG4vLyBNYXRjaGVzIGEgd2hvbGUgbGluZSBicmVhayAod2hlcmUgQ1JMRiBpcyBjb25zaWRlcmVkIGEgc2luZ2xlXG4vLyBsaW5lIGJyZWFrKS4gVXNlZCB0byBjb3VudCBsaW5lcy5cblxuLy8gaW4gamF2YXNjcmlwdCwgdGhlc2UgdHdvIGRpZmZlclxuLy8gaW4gcHl0aG9uIHRoZXkgYXJlIHRoZSBzYW1lLCBkaWZmZXJlbnQgbWV0aG9kcyBhcmUgY2FsbGVkIG9uIHRoZW1cbmV4cG9ydHMubGluZUJyZWFrID0gbmV3IFJlZ0V4cCgnXFxyXFxufCcgKyBleHBvcnRzLm5ld2xpbmUuc291cmNlKTtcbmV4cG9ydHMuYWxsTGluZUJyZWFrcyA9IG5ldyBSZWdFeHAoZXhwb3J0cy5saW5lQnJlYWsuc291cmNlLCAnZycpO1xuXG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIEJhc2VPcHRpb25zID0gKF9fd2VicGFja19yZXF1aXJlX18oNikuT3B0aW9ucyk7XG5cbnZhciB2YWxpZFBvc2l0aW9uVmFsdWVzID0gWydiZWZvcmUtbmV3bGluZScsICdhZnRlci1uZXdsaW5lJywgJ3ByZXNlcnZlLW5ld2xpbmUnXTtcblxuZnVuY3Rpb24gT3B0aW9ucyhvcHRpb25zKSB7XG4gIEJhc2VPcHRpb25zLmNhbGwodGhpcywgb3B0aW9ucywgJ2pzJyk7XG5cbiAgLy8gY29tcGF0aWJpbGl0eSwgcmVcbiAgdmFyIHJhd19icmFjZV9zdHlsZSA9IHRoaXMucmF3X29wdGlvbnMuYnJhY2Vfc3R5bGUgfHwgbnVsbDtcbiAgaWYgKHJhd19icmFjZV9zdHlsZSA9PT0gXCJleHBhbmQtc3RyaWN0XCIpIHsgLy9ncmFjZWZ1bCBoYW5kbGluZyBvZiBkZXByZWNhdGVkIG9wdGlvblxuICAgIHRoaXMucmF3X29wdGlvbnMuYnJhY2Vfc3R5bGUgPSBcImV4cGFuZFwiO1xuICB9IGVsc2UgaWYgKHJhd19icmFjZV9zdHlsZSA9PT0gXCJjb2xsYXBzZS1wcmVzZXJ2ZS1pbmxpbmVcIikgeyAvL2dyYWNlZnVsIGhhbmRsaW5nIG9mIGRlcHJlY2F0ZWQgb3B0aW9uXG4gICAgdGhpcy5yYXdfb3B0aW9ucy5icmFjZV9zdHlsZSA9IFwiY29sbGFwc2UscHJlc2VydmUtaW5saW5lXCI7XG4gIH0gZWxzZSBpZiAodGhpcy5yYXdfb3B0aW9ucy5icmFjZXNfb25fb3duX2xpbmUgIT09IHVuZGVmaW5lZCkgeyAvL2dyYWNlZnVsIGhhbmRsaW5nIG9mIGRlcHJlY2F0ZWQgb3B0aW9uXG4gICAgdGhpcy5yYXdfb3B0aW9ucy5icmFjZV9zdHlsZSA9IHRoaXMucmF3X29wdGlvbnMuYnJhY2VzX29uX293bl9saW5lID8gXCJleHBhbmRcIiA6IFwiY29sbGFwc2VcIjtcbiAgICAvLyB9IGVsc2UgaWYgKCFyYXdfYnJhY2Vfc3R5bGUpIHsgLy9Ob3RoaW5nIGV4aXN0cyB0byBzZXQgaXRcbiAgICAvLyAgIHJhd19icmFjZV9zdHlsZSA9IFwiY29sbGFwc2VcIjtcbiAgfVxuXG4gIC8vcHJlc2VydmUtaW5saW5lIGluIGRlbGltaXRlZCBzdHJpbmcgd2lsbCB0cmlnZ2VyIGJyYWNlX3ByZXNlcnZlX2lubGluZSwgZXZlcnl0aGluZ1xuICAvL2Vsc2UgaXMgY29uc2lkZXJlZCBhIGJyYWNlX3N0eWxlIGFuZCB0aGUgbGFzdCBvbmUgb25seSB3aWxsIGhhdmUgYW4gZWZmZWN0XG5cbiAgdmFyIGJyYWNlX3N0eWxlX3NwbGl0ID0gdGhpcy5fZ2V0X3NlbGVjdGlvbl9saXN0KCdicmFjZV9zdHlsZScsIFsnY29sbGFwc2UnLCAnZXhwYW5kJywgJ2VuZC1leHBhbmQnLCAnbm9uZScsICdwcmVzZXJ2ZS1pbmxpbmUnXSk7XG5cbiAgdGhpcy5icmFjZV9wcmVzZXJ2ZV9pbmxpbmUgPSBmYWxzZTsgLy9EZWZhdWx0cyBpbiBjYXNlIG9uZSBvciBvdGhlciB3YXMgbm90IHNwZWNpZmllZCBpbiBtZXRhLW9wdGlvblxuICB0aGlzLmJyYWNlX3N0eWxlID0gXCJjb2xsYXBzZVwiO1xuXG4gIGZvciAodmFyIGJzID0gMDsgYnMgPCBicmFjZV9zdHlsZV9zcGxpdC5sZW5ndGg7IGJzKyspIHtcbiAgICBpZiAoYnJhY2Vfc3R5bGVfc3BsaXRbYnNdID09PSBcInByZXNlcnZlLWlubGluZVwiKSB7XG4gICAgICB0aGlzLmJyYWNlX3ByZXNlcnZlX2lubGluZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYnJhY2Vfc3R5bGUgPSBicmFjZV9zdHlsZV9zcGxpdFtic107XG4gICAgfVxuICB9XG5cbiAgdGhpcy51bmluZGVudF9jaGFpbmVkX21ldGhvZHMgPSB0aGlzLl9nZXRfYm9vbGVhbigndW5pbmRlbnRfY2hhaW5lZF9tZXRob2RzJyk7XG4gIHRoaXMuYnJlYWtfY2hhaW5lZF9tZXRob2RzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2JyZWFrX2NoYWluZWRfbWV0aG9kcycpO1xuICB0aGlzLnNwYWNlX2luX3BhcmVuID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3NwYWNlX2luX3BhcmVuJyk7XG4gIHRoaXMuc3BhY2VfaW5fZW1wdHlfcGFyZW4gPSB0aGlzLl9nZXRfYm9vbGVhbignc3BhY2VfaW5fZW1wdHlfcGFyZW4nKTtcbiAgdGhpcy5qc2xpbnRfaGFwcHkgPSB0aGlzLl9nZXRfYm9vbGVhbignanNsaW50X2hhcHB5Jyk7XG4gIHRoaXMuc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbiA9IHRoaXMuX2dldF9ib29sZWFuKCdzcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uJyk7XG4gIHRoaXMuc3BhY2VfYWZ0ZXJfbmFtZWRfZnVuY3Rpb24gPSB0aGlzLl9nZXRfYm9vbGVhbignc3BhY2VfYWZ0ZXJfbmFtZWRfZnVuY3Rpb24nKTtcbiAgdGhpcy5rZWVwX2FycmF5X2luZGVudGF0aW9uID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2tlZXBfYXJyYXlfaW5kZW50YXRpb24nKTtcbiAgdGhpcy5zcGFjZV9iZWZvcmVfY29uZGl0aW9uYWwgPSB0aGlzLl9nZXRfYm9vbGVhbignc3BhY2VfYmVmb3JlX2NvbmRpdGlvbmFsJywgdHJ1ZSk7XG4gIHRoaXMudW5lc2NhcGVfc3RyaW5ncyA9IHRoaXMuX2dldF9ib29sZWFuKCd1bmVzY2FwZV9zdHJpbmdzJyk7XG4gIHRoaXMuZTR4ID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2U0eCcpO1xuICB0aGlzLmNvbW1hX2ZpcnN0ID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2NvbW1hX2ZpcnN0Jyk7XG4gIHRoaXMub3BlcmF0b3JfcG9zaXRpb24gPSB0aGlzLl9nZXRfc2VsZWN0aW9uKCdvcGVyYXRvcl9wb3NpdGlvbicsIHZhbGlkUG9zaXRpb25WYWx1ZXMpO1xuXG4gIC8vIEZvciB0ZXN0aW5nIG9mIGJlYXV0aWZ5IHByZXNlcnZlOnN0YXJ0IGRpcmVjdGl2ZVxuICB0aGlzLnRlc3Rfb3V0cHV0X3JhdyA9IHRoaXMuX2dldF9ib29sZWFuKCd0ZXN0X291dHB1dF9yYXcnKTtcblxuICAvLyBmb3JjZSB0aGlzLl9vcHRpb25zLnNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24gdG8gdHJ1ZSBpZiB0aGlzLl9vcHRpb25zLmpzbGludF9oYXBweVxuICBpZiAodGhpcy5qc2xpbnRfaGFwcHkpIHtcbiAgICB0aGlzLnNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24gPSB0cnVlO1xuICB9XG5cbn1cbk9wdGlvbnMucHJvdG90eXBlID0gbmV3IEJhc2VPcHRpb25zKCk7XG5cblxuXG5tb2R1bGUuZXhwb3J0cy5PcHRpb25zID0gT3B0aW9ucztcblxuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBPcHRpb25zKG9wdGlvbnMsIG1lcmdlX2NoaWxkX2ZpZWxkKSB7XG4gIHRoaXMucmF3X29wdGlvbnMgPSBfbWVyZ2VPcHRzKG9wdGlvbnMsIG1lcmdlX2NoaWxkX2ZpZWxkKTtcblxuICAvLyBTdXBwb3J0IHBhc3NpbmcgdGhlIHNvdXJjZSB0ZXh0IGJhY2sgd2l0aCBubyBjaGFuZ2VcbiAgdGhpcy5kaXNhYmxlZCA9IHRoaXMuX2dldF9ib29sZWFuKCdkaXNhYmxlZCcpO1xuXG4gIHRoaXMuZW9sID0gdGhpcy5fZ2V0X2NoYXJhY3RlcnMoJ2VvbCcsICdhdXRvJyk7XG4gIHRoaXMuZW5kX3dpdGhfbmV3bGluZSA9IHRoaXMuX2dldF9ib29sZWFuKCdlbmRfd2l0aF9uZXdsaW5lJyk7XG4gIHRoaXMuaW5kZW50X3NpemUgPSB0aGlzLl9nZXRfbnVtYmVyKCdpbmRlbnRfc2l6ZScsIDQpO1xuICB0aGlzLmluZGVudF9jaGFyID0gdGhpcy5fZ2V0X2NoYXJhY3RlcnMoJ2luZGVudF9jaGFyJywgJyAnKTtcbiAgdGhpcy5pbmRlbnRfbGV2ZWwgPSB0aGlzLl9nZXRfbnVtYmVyKCdpbmRlbnRfbGV2ZWwnKTtcblxuICB0aGlzLnByZXNlcnZlX25ld2xpbmVzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3ByZXNlcnZlX25ld2xpbmVzJywgdHJ1ZSk7XG4gIHRoaXMubWF4X3ByZXNlcnZlX25ld2xpbmVzID0gdGhpcy5fZ2V0X251bWJlcignbWF4X3ByZXNlcnZlX25ld2xpbmVzJywgMzI3ODYpO1xuICBpZiAoIXRoaXMucHJlc2VydmVfbmV3bGluZXMpIHtcbiAgICB0aGlzLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyA9IDA7XG4gIH1cblxuICB0aGlzLmluZGVudF93aXRoX3RhYnMgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X3dpdGhfdGFicycsIHRoaXMuaW5kZW50X2NoYXIgPT09ICdcXHQnKTtcbiAgaWYgKHRoaXMuaW5kZW50X3dpdGhfdGFicykge1xuICAgIHRoaXMuaW5kZW50X2NoYXIgPSAnXFx0JztcblxuICAgIC8vIGluZGVudF9zaXplIGJlaGF2aW9yIGNoYW5nZWQgYWZ0ZXIgMS44LjZcbiAgICAvLyBJdCB1c2VkIHRvIGJlIHRoYXQgaW5kZW50X3NpemUgd291bGQgYmVcbiAgICAvLyBzZXQgdG8gMSBmb3IgaW5kZW50X3dpdGhfdGFicy4gVGhhdCBpcyBubyBsb25nZXIgbmVlZGVkIGFuZFxuICAgIC8vIGFjdHVhbGx5IGRvZXNuJ3QgbWFrZSBzZW5zZSAtIHdoeSBub3QgdXNlIHNwYWNlcz8gRnVydGhlcixcbiAgICAvLyB0aGF0IG1pZ2h0IHByb2R1Y2UgdW5leHBlY3RlZCBiZWhhdmlvciAtIHRhYnMgYmVpbmcgdXNlZFxuICAgIC8vIGZvciBzaW5nbGUtY29sdW1uIGFsaWdubWVudC4gU28sIHdoZW4gaW5kZW50X3dpdGhfdGFicyBpcyB0cnVlXG4gICAgLy8gYW5kIGluZGVudF9zaXplIGlzIDEsIHJlc2V0IGluZGVudF9zaXplIHRvIDQuXG4gICAgaWYgKHRoaXMuaW5kZW50X3NpemUgPT09IDEpIHtcbiAgICAgIHRoaXMuaW5kZW50X3NpemUgPSA0O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXQgd2l0aCAxLjMueFxuICB0aGlzLndyYXBfbGluZV9sZW5ndGggPSB0aGlzLl9nZXRfbnVtYmVyKCd3cmFwX2xpbmVfbGVuZ3RoJywgdGhpcy5fZ2V0X251bWJlcignbWF4X2NoYXInKSk7XG5cbiAgdGhpcy5pbmRlbnRfZW1wdHlfbGluZXMgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X2VtcHR5X2xpbmVzJyk7XG5cbiAgLy8gdmFsaWQgdGVtcGxhdGluZyBsYW5ndWFnZXMgWydkamFuZ28nLCAnZXJiJywgJ2hhbmRsZWJhcnMnLCAncGhwJywgJ3NtYXJ0eScsICdhbmd1bGFyJ11cbiAgLy8gRm9yIG5vdywgJ2F1dG8nID0gYWxsIG9mZiBmb3IgamF2YXNjcmlwdCwgYWxsIGV4Y2VwdCBhbmd1bGFyIG9uIGZvciBodG1sIChhbmQgaW5saW5lIGphdmFzY3JpcHQvY3NzKS5cbiAgLy8gb3RoZXIgdmFsdWVzIGlnbm9yZWRcbiAgdGhpcy50ZW1wbGF0aW5nID0gdGhpcy5fZ2V0X3NlbGVjdGlvbl9saXN0KCd0ZW1wbGF0aW5nJywgWydhdXRvJywgJ25vbmUnLCAnYW5ndWxhcicsICdkamFuZ28nLCAnZXJiJywgJ2hhbmRsZWJhcnMnLCAncGhwJywgJ3NtYXJ0eSddLCBbJ2F1dG8nXSk7XG59XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfYXJyYXkgPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICB2YXIgcmVzdWx0ID0gZGVmYXVsdF92YWx1ZSB8fCBbXTtcbiAgaWYgKHR5cGVvZiBvcHRpb25fdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKG9wdGlvbl92YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9uX3ZhbHVlLmNvbmNhdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlLmNvbmNhdCgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9uX3ZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IG9wdGlvbl92YWx1ZS5zcGxpdCgvW15hLXpBLVowLTlfXFwvXFwtXSsvKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9ib29sZWFuID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgb3B0aW9uX3ZhbHVlID0gdGhpcy5yYXdfb3B0aW9uc1tuYW1lXTtcbiAgdmFyIHJlc3VsdCA9IG9wdGlvbl92YWx1ZSA9PT0gdW5kZWZpbmVkID8gISFkZWZhdWx0X3ZhbHVlIDogISFvcHRpb25fdmFsdWU7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X2NoYXJhY3RlcnMgPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICB2YXIgcmVzdWx0ID0gZGVmYXVsdF92YWx1ZSB8fCAnJztcbiAgaWYgKHR5cGVvZiBvcHRpb25fdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlLnJlcGxhY2UoL1xcXFxyLywgJ1xccicpLnJlcGxhY2UoL1xcXFxuLywgJ1xcbicpLnJlcGxhY2UoL1xcXFx0LywgJ1xcdCcpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X251bWJlciA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIGRlZmF1bHRfdmFsdWUgPSBwYXJzZUludChkZWZhdWx0X3ZhbHVlLCAxMCk7XG4gIGlmIChpc05hTihkZWZhdWx0X3ZhbHVlKSkge1xuICAgIGRlZmF1bHRfdmFsdWUgPSAwO1xuICB9XG4gIHZhciByZXN1bHQgPSBwYXJzZUludChvcHRpb25fdmFsdWUsIDEwKTtcbiAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBkZWZhdWx0X3ZhbHVlO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X3NlbGVjdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIHNlbGVjdGlvbl9saXN0LCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9nZXRfc2VsZWN0aW9uX2xpc3QobmFtZSwgc2VsZWN0aW9uX2xpc3QsIGRlZmF1bHRfdmFsdWUpO1xuICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW52YWxpZCBPcHRpb24gVmFsdWU6IFRoZSBvcHRpb24gJ1wiICsgbmFtZSArIFwiJyBjYW4gb25seSBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XFxuXCIgK1xuICAgICAgc2VsZWN0aW9uX2xpc3QgKyBcIlxcbllvdSBwYXNzZWQgaW46ICdcIiArIHRoaXMucmF3X29wdGlvbnNbbmFtZV0gKyBcIidcIik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0WzBdO1xufTtcblxuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X3NlbGVjdGlvbl9saXN0ID0gZnVuY3Rpb24obmFtZSwgc2VsZWN0aW9uX2xpc3QsIGRlZmF1bHRfdmFsdWUpIHtcbiAgaWYgKCFzZWxlY3Rpb25fbGlzdCB8fCBzZWxlY3Rpb25fbGlzdC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWxlY3Rpb24gbGlzdCBjYW5ub3QgYmUgZW1wdHkuXCIpO1xuICB9XG5cbiAgZGVmYXVsdF92YWx1ZSA9IGRlZmF1bHRfdmFsdWUgfHwgW3NlbGVjdGlvbl9saXN0WzBdXTtcbiAgaWYgKCF0aGlzLl9pc192YWxpZF9zZWxlY3Rpb24oZGVmYXVsdF92YWx1ZSwgc2VsZWN0aW9uX2xpc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBEZWZhdWx0IFZhbHVlIVwiKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB0aGlzLl9nZXRfYXJyYXkobmFtZSwgZGVmYXVsdF92YWx1ZSk7XG4gIGlmICghdGhpcy5faXNfdmFsaWRfc2VsZWN0aW9uKHJlc3VsdCwgc2VsZWN0aW9uX2xpc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJbnZhbGlkIE9wdGlvbiBWYWx1ZTogVGhlIG9wdGlvbiAnXCIgKyBuYW1lICsgXCInIGNhbiBjb250YWluIG9ubHkgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XFxuXCIgK1xuICAgICAgc2VsZWN0aW9uX2xpc3QgKyBcIlxcbllvdSBwYXNzZWQgaW46ICdcIiArIHRoaXMucmF3X29wdGlvbnNbbmFtZV0gKyBcIidcIik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2lzX3ZhbGlkX3NlbGVjdGlvbiA9IGZ1bmN0aW9uKHJlc3VsdCwgc2VsZWN0aW9uX2xpc3QpIHtcbiAgcmV0dXJuIHJlc3VsdC5sZW5ndGggJiYgc2VsZWN0aW9uX2xpc3QubGVuZ3RoICYmXG4gICAgIXJlc3VsdC5zb21lKGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIHNlbGVjdGlvbl9saXN0LmluZGV4T2YoaXRlbSkgPT09IC0xOyB9KTtcbn07XG5cblxuLy8gbWVyZ2VzIGNoaWxkIG9wdGlvbnMgdXAgd2l0aCB0aGUgcGFyZW50IG9wdGlvbnMgb2JqZWN0XG4vLyBFeGFtcGxlOiBvYmogPSB7YTogMSwgYjoge2E6IDJ9fVxuLy8gICAgICAgICAgbWVyZ2VPcHRzKG9iaiwgJ2InKVxuLy9cbi8vICAgICAgICAgIFJldHVybnM6IHthOiAyfVxuZnVuY3Rpb24gX21lcmdlT3B0cyhhbGxPcHRpb25zLCBjaGlsZEZpZWxkTmFtZSkge1xuICB2YXIgZmluYWxPcHRzID0ge307XG4gIGFsbE9wdGlvbnMgPSBfbm9ybWFsaXplT3B0cyhhbGxPcHRpb25zKTtcbiAgdmFyIG5hbWU7XG5cbiAgZm9yIChuYW1lIGluIGFsbE9wdGlvbnMpIHtcbiAgICBpZiAobmFtZSAhPT0gY2hpbGRGaWVsZE5hbWUpIHtcbiAgICAgIGZpbmFsT3B0c1tuYW1lXSA9IGFsbE9wdGlvbnNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgLy9tZXJnZSBpbiB0aGUgcGVyIHR5cGUgc2V0dGluZ3MgZm9yIHRoZSBjaGlsZEZpZWxkTmFtZVxuICBpZiAoY2hpbGRGaWVsZE5hbWUgJiYgYWxsT3B0aW9uc1tjaGlsZEZpZWxkTmFtZV0pIHtcbiAgICBmb3IgKG5hbWUgaW4gYWxsT3B0aW9uc1tjaGlsZEZpZWxkTmFtZV0pIHtcbiAgICAgIGZpbmFsT3B0c1tuYW1lXSA9IGFsbE9wdGlvbnNbY2hpbGRGaWVsZE5hbWVdW25hbWVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmluYWxPcHRzO1xufVxuXG5mdW5jdGlvbiBfbm9ybWFsaXplT3B0cyhvcHRpb25zKSB7XG4gIHZhciBjb252ZXJ0ZWRPcHRzID0ge307XG4gIHZhciBrZXk7XG5cbiAgZm9yIChrZXkgaW4gb3B0aW9ucykge1xuICAgIHZhciBuZXdLZXkgPSBrZXkucmVwbGFjZSgvLS9nLCBcIl9cIik7XG4gICAgY29udmVydGVkT3B0c1tuZXdLZXldID0gb3B0aW9uc1trZXldO1xuICB9XG4gIHJldHVybiBjb252ZXJ0ZWRPcHRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5PcHRpb25zID0gT3B0aW9ucztcbm1vZHVsZS5leHBvcnRzLm5vcm1hbGl6ZU9wdHMgPSBfbm9ybWFsaXplT3B0cztcbm1vZHVsZS5leHBvcnRzLm1lcmdlT3B0cyA9IF9tZXJnZU9wdHM7XG5cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgSW5wdXRTY2FubmVyID0gKF9fd2VicGFja19yZXF1aXJlX18oOCkuSW5wdXRTY2FubmVyKTtcbnZhciBCYXNlVG9rZW5pemVyID0gKF9fd2VicGFja19yZXF1aXJlX18oOSkuVG9rZW5pemVyKTtcbnZhciBCQVNFVE9LRU4gPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg5KS5UT0tFTik7XG52YXIgRGlyZWN0aXZlcyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKS5EaXJlY3RpdmVzKTtcbnZhciBhY29ybiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgUGF0dGVybiA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKS5QYXR0ZXJuKTtcbnZhciBUZW1wbGF0YWJsZVBhdHRlcm4gPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxNCkuVGVtcGxhdGFibGVQYXR0ZXJuKTtcblxuXG5mdW5jdGlvbiBpbl9hcnJheSh3aGF0LCBhcnIpIHtcbiAgcmV0dXJuIGFyci5pbmRleE9mKHdoYXQpICE9PSAtMTtcbn1cblxuXG52YXIgVE9LRU4gPSB7XG4gIFNUQVJUX0VYUFI6ICdUS19TVEFSVF9FWFBSJyxcbiAgRU5EX0VYUFI6ICdUS19FTkRfRVhQUicsXG4gIFNUQVJUX0JMT0NLOiAnVEtfU1RBUlRfQkxPQ0snLFxuICBFTkRfQkxPQ0s6ICdUS19FTkRfQkxPQ0snLFxuICBXT1JEOiAnVEtfV09SRCcsXG4gIFJFU0VSVkVEOiAnVEtfUkVTRVJWRUQnLFxuICBTRU1JQ09MT046ICdUS19TRU1JQ09MT04nLFxuICBTVFJJTkc6ICdUS19TVFJJTkcnLFxuICBFUVVBTFM6ICdUS19FUVVBTFMnLFxuICBPUEVSQVRPUjogJ1RLX09QRVJBVE9SJyxcbiAgQ09NTUE6ICdUS19DT01NQScsXG4gIEJMT0NLX0NPTU1FTlQ6ICdUS19CTE9DS19DT01NRU5UJyxcbiAgQ09NTUVOVDogJ1RLX0NPTU1FTlQnLFxuICBET1Q6ICdUS19ET1QnLFxuICBVTktOT1dOOiAnVEtfVU5LTk9XTicsXG4gIFNUQVJUOiBCQVNFVE9LRU4uU1RBUlQsXG4gIFJBVzogQkFTRVRPS0VOLlJBVyxcbiAgRU9GOiBCQVNFVE9LRU4uRU9GXG59O1xuXG5cbnZhciBkaXJlY3RpdmVzX2NvcmUgPSBuZXcgRGlyZWN0aXZlcygvXFwvXFwqLywgL1xcKlxcLy8pO1xuXG52YXIgbnVtYmVyX3BhdHRlcm4gPSAvMFt4WF1bMDEyMzQ1Njc4OWFiY2RlZkFCQ0RFRl9dKm4/fDBbb09dWzAxMjM0NTY3X10qbj98MFtiQl1bMDFfXSpuP3xcXGRbXFxkX10qbnwoPzpcXC5cXGRbXFxkX10qfFxcZFtcXGRfXSpcXC4/W1xcZF9dKikoPzpbZUVdWystXT9bXFxkX10rKT8vO1xuXG52YXIgZGlnaXQgPSAvWzAtOV0vO1xuXG4vLyBEb3QgXCIuXCIgbXVzdCBiZSBkaXN0aW5ndWlzaGVkIGZyb20gXCIuLi5cIiBhbmQgZGVjaW1hbFxudmFyIGRvdF9wYXR0ZXJuID0gL1teXFxkXFwuXS87XG5cbnZhciBwb3NpdGlvbmFibGVfb3BlcmF0b3JzID0gKFxuICBcIj4+PiA9PT0gIT09ICYmPSA/Pz0gfHw9IFwiICtcbiAgXCI8PCAmJiA+PSAqKiAhPSA9PSA8PSA+PiB8fCA/PyB8PiBcIiArXG4gIFwiPCAvIC0gKyA+IDogJiAlID8gXiB8ICpcIikuc3BsaXQoJyAnKTtcblxuLy8gSU1QT1JUQU5UOiB0aGlzIG11c3QgYmUgc29ydGVkIGxvbmdlc3QgdG8gc2hvcnRlc3Qgb3IgdG9rZW5pemluZyBtYW55IG5vdCB3b3JrLlxuLy8gQWxzbywgeW91IG11c3QgdXBkYXRlIHBvc3NpdGlvbmFibGUgb3BlcmF0b3JzIHNlcGFyYXRlbHkgZnJvbSBwdW5jdFxudmFyIHB1bmN0ID1cbiAgXCI+Pj49IFwiICtcbiAgXCIuLi4gPj49IDw8PSA9PT0gPj4+ICE9PSAqKj0gJiY9ID8/PSB8fD0gXCIgK1xuICBcIj0+IF49IDo6IC89IDw8IDw9ID09ICYmIC09ID49ID4+ICE9IC0tICs9ICoqIHx8ID8/ICsrICU9ICY9ICo9IHw9IHw+IFwiICtcbiAgXCI9ICEgPyA+IDwgOiAvIF4gLSArICogJiAlIH4gfFwiO1xuXG5wdW5jdCA9IHB1bmN0LnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXS9nLCBcIlxcXFwkJlwiKTtcbi8vID8uIGJ1dCBub3QgaWYgZm9sbG93ZWQgYnkgYSBudW1iZXIgXG5wdW5jdCA9ICdcXFxcP1xcXFwuKD8hXFxcXGQpICcgKyBwdW5jdDtcbnB1bmN0ID0gcHVuY3QucmVwbGFjZSgvIC9nLCAnfCcpO1xuXG52YXIgcHVuY3RfcGF0dGVybiA9IG5ldyBSZWdFeHAocHVuY3QpO1xuXG4vLyB3b3JkcyB3aGljaCBzaG91bGQgYWx3YXlzIHN0YXJ0IG9uIG5ldyBsaW5lLlxudmFyIGxpbmVfc3RhcnRlcnMgPSAnY29udGludWUsdHJ5LHRocm93LHJldHVybix2YXIsbGV0LGNvbnN0LGlmLHN3aXRjaCxjYXNlLGRlZmF1bHQsZm9yLHdoaWxlLGJyZWFrLGZ1bmN0aW9uLGltcG9ydCxleHBvcnQnLnNwbGl0KCcsJyk7XG52YXIgcmVzZXJ2ZWRfd29yZHMgPSBsaW5lX3N0YXJ0ZXJzLmNvbmNhdChbJ2RvJywgJ2luJywgJ29mJywgJ2Vsc2UnLCAnZ2V0JywgJ3NldCcsICduZXcnLCAnY2F0Y2gnLCAnZmluYWxseScsICd0eXBlb2YnLCAneWllbGQnLCAnYXN5bmMnLCAnYXdhaXQnLCAnZnJvbScsICdhcycsICdjbGFzcycsICdleHRlbmRzJ10pO1xudmFyIHJlc2VydmVkX3dvcmRfcGF0dGVybiA9IG5ldyBSZWdFeHAoJ14oPzonICsgcmVzZXJ2ZWRfd29yZHMuam9pbignfCcpICsgJykkJyk7XG5cbi8vIHZhciB0ZW1wbGF0ZV9wYXR0ZXJuID0gLyg/Oig/OjxcXD9waHB8PFxcPz0pW1xcc1xcU10qP1xcPz4pfCg/OjwlW1xcc1xcU10qPyU+KS9nO1xuXG52YXIgaW5faHRtbF9jb21tZW50O1xuXG52YXIgVG9rZW5pemVyID0gZnVuY3Rpb24oaW5wdXRfc3RyaW5nLCBvcHRpb25zKSB7XG4gIEJhc2VUb2tlbml6ZXIuY2FsbCh0aGlzLCBpbnB1dF9zdHJpbmcsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3BhdHRlcm5zLndoaXRlc3BhY2UgPSB0aGlzLl9wYXR0ZXJucy53aGl0ZXNwYWNlLm1hdGNoaW5nKFxuICAgIC9cXHUwMEEwXFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmLy5zb3VyY2UsXG4gICAgL1xcdTIwMjhcXHUyMDI5Ly5zb3VyY2UpO1xuXG4gIHZhciBwYXR0ZXJuX3JlYWRlciA9IG5ldyBQYXR0ZXJuKHRoaXMuX2lucHV0KTtcbiAgdmFyIHRlbXBsYXRhYmxlID0gbmV3IFRlbXBsYXRhYmxlUGF0dGVybih0aGlzLl9pbnB1dClcbiAgICAucmVhZF9vcHRpb25zKHRoaXMuX29wdGlvbnMpO1xuXG4gIHRoaXMuX19wYXR0ZXJucyA9IHtcbiAgICB0ZW1wbGF0ZTogdGVtcGxhdGFibGUsXG4gICAgaWRlbnRpZmllcjogdGVtcGxhdGFibGUuc3RhcnRpbmdfd2l0aChhY29ybi5pZGVudGlmaWVyKS5tYXRjaGluZyhhY29ybi5pZGVudGlmaWVyTWF0Y2gpLFxuICAgIG51bWJlcjogcGF0dGVybl9yZWFkZXIubWF0Y2hpbmcobnVtYmVyX3BhdHRlcm4pLFxuICAgIHB1bmN0OiBwYXR0ZXJuX3JlYWRlci5tYXRjaGluZyhwdW5jdF9wYXR0ZXJuKSxcbiAgICAvLyBjb21tZW50IGVuZHMganVzdCBiZWZvcmUgbmVhcmVzdCBsaW5lZmVlZCBvciBlbmQgb2YgZmlsZVxuICAgIGNvbW1lbnQ6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoL1xcL1xcLy8pLnVudGlsKC9bXFxuXFxyXFx1MjAyOFxcdTIwMjldLyksXG4gICAgLy8gIC8qIC4uLiAqLyBjb21tZW50IGVuZHMgd2l0aCBuZWFyZXN0ICovIG9yIGVuZCBvZiBmaWxlXG4gICAgYmxvY2tfY29tbWVudDogcGF0dGVybl9yZWFkZXIuc3RhcnRpbmdfd2l0aCgvXFwvXFwqLykudW50aWxfYWZ0ZXIoL1xcKlxcLy8pLFxuICAgIGh0bWxfY29tbWVudF9zdGFydDogcGF0dGVybl9yZWFkZXIubWF0Y2hpbmcoLzwhLS0vKSxcbiAgICBodG1sX2NvbW1lbnRfZW5kOiBwYXR0ZXJuX3JlYWRlci5tYXRjaGluZygvLS0+LyksXG4gICAgaW5jbHVkZTogcGF0dGVybl9yZWFkZXIuc3RhcnRpbmdfd2l0aCgvI2luY2x1ZGUvKS51bnRpbF9hZnRlcihhY29ybi5saW5lQnJlYWspLFxuICAgIHNoZWJhbmc6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoLyMhLykudW50aWxfYWZ0ZXIoYWNvcm4ubGluZUJyZWFrKSxcbiAgICB4bWw6IHBhdHRlcm5fcmVhZGVyLm1hdGNoaW5nKC9bXFxzXFxTXSo/PChcXC8/KShbLWEtekEtWjowLTlfLl0rfHtbXn1dKz99fCFcXFtDREFUQVxcW1teXFxdXSo/XFxdXFxdfCkoXFxzKntbXn1dKz99fFxccytbLWEtekEtWjowLTlfLl0rfFxccytbLWEtekEtWjowLTlfLl0rXFxzKj1cXHMqKCdbXiddKid8XCJbXlwiXSpcInx7KFtee31dfHtbXn1dKz99KSs/fSkpKlxccyooXFwvPylcXHMqPi8pLFxuICAgIHNpbmdsZV9xdW90ZTogdGVtcGxhdGFibGUudW50aWwoL1snXFxcXFxcblxcclxcdTIwMjhcXHUyMDI5XS8pLFxuICAgIGRvdWJsZV9xdW90ZTogdGVtcGxhdGFibGUudW50aWwoL1tcIlxcXFxcXG5cXHJcXHUyMDI4XFx1MjAyOV0vKSxcbiAgICB0ZW1wbGF0ZV90ZXh0OiB0ZW1wbGF0YWJsZS51bnRpbCgvW2BcXFxcJF0vKSxcbiAgICB0ZW1wbGF0ZV9leHByZXNzaW9uOiB0ZW1wbGF0YWJsZS51bnRpbCgvW2B9XFxcXF0vKVxuICB9O1xuXG59O1xuVG9rZW5pemVyLnByb3RvdHlwZSA9IG5ldyBCYXNlVG9rZW5pemVyKCk7XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2NvbW1lbnQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIHJldHVybiBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1FTlQgfHwgY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5CTE9DS19DT01NRU5UIHx8IGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uVU5LTk9XTjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX29wZW5pbmcgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIHJldHVybiBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0JMT0NLIHx8IGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2Nsb3NpbmcgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuLCBvcGVuX3Rva2VuKSB7XG4gIHJldHVybiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfQkxPQ0sgfHwgY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfRVhQUikgJiZcbiAgICAob3Blbl90b2tlbiAmJiAoXG4gICAgICAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnXScgJiYgb3Blbl90b2tlbi50ZXh0ID09PSAnWycpIHx8XG4gICAgICAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnKScgJiYgb3Blbl90b2tlbi50ZXh0ID09PSAnKCcpIHx8XG4gICAgICAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnfScgJiYgb3Blbl90b2tlbi50ZXh0ID09PSAneycpKSk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uKCkge1xuICBpbl9odG1sX2NvbW1lbnQgPSBmYWxzZTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2dldF9uZXh0X3Rva2VuID0gZnVuY3Rpb24ocHJldmlvdXNfdG9rZW4sIG9wZW5fdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICB2YXIgdG9rZW4gPSBudWxsO1xuICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICB2YXIgYyA9IHRoaXMuX2lucHV0LnBlZWsoKTtcblxuICBpZiAoYyA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRU9GLCAnJyk7XG4gIH1cblxuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfbm9uX2phdmFzY3JpcHQoYyk7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9zdHJpbmcoYyk7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9wYWlyKGMsIHRoaXMuX2lucHV0LnBlZWsoMSkpOyAvLyBJc3N1ZSAjMjA2MiBoYWNrIGZvciByZWNvcmQgdHlwZSAnI3snXG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF93b3JkKHByZXZpb3VzX3Rva2VuKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX3NpbmdsZXMoYyk7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9jb21tZW50KGMpO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfcmVnZXhwKGMsIHByZXZpb3VzX3Rva2VuKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX3htbChjLCBwcmV2aW91c190b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9wdW5jdHVhdGlvbigpO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5VTktOT1dOLCB0aGlzLl9pbnB1dC5uZXh0KCkpO1xuXG4gIHJldHVybiB0b2tlbjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfd29yZCA9IGZ1bmN0aW9uKHByZXZpb3VzX3Rva2VuKSB7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nO1xuICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLmlkZW50aWZpZXIucmVhZCgpO1xuICBpZiAocmVzdWx0aW5nX3N0cmluZyAhPT0gJycpIHtcbiAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZy5yZXBsYWNlKGFjb3JuLmFsbExpbmVCcmVha3MsICdcXG4nKTtcbiAgICBpZiAoIShwcmV2aW91c190b2tlbi50eXBlID09PSBUT0tFTi5ET1QgfHxcbiAgICAgICAgKHByZXZpb3VzX3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEICYmIChwcmV2aW91c190b2tlbi50ZXh0ID09PSAnc2V0JyB8fCBwcmV2aW91c190b2tlbi50ZXh0ID09PSAnZ2V0JykpKSAmJlxuICAgICAgcmVzZXJ2ZWRfd29yZF9wYXR0ZXJuLnRlc3QocmVzdWx0aW5nX3N0cmluZykpIHtcbiAgICAgIGlmICgocmVzdWx0aW5nX3N0cmluZyA9PT0gJ2luJyB8fCByZXN1bHRpbmdfc3RyaW5nID09PSAnb2YnKSAmJlxuICAgICAgICAocHJldmlvdXNfdG9rZW4udHlwZSA9PT0gVE9LRU4uV09SRCB8fCBwcmV2aW91c190b2tlbi50eXBlID09PSBUT0tFTi5TVFJJTkcpKSB7IC8vIGhhY2sgZm9yICdpbicgYW5kICdvZicgb3BlcmF0b3JzXG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uT1BFUkFUT1IsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5SRVNFUlZFRCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uV09SRCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gIH1cblxuICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLm51bWJlci5yZWFkKCk7XG4gIGlmIChyZXN1bHRpbmdfc3RyaW5nICE9PSAnJykge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uV09SRCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gIH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfc2luZ2xlcyA9IGZ1bmN0aW9uKGMpIHtcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgaWYgKGMgPT09ICcoJyB8fCBjID09PSAnWycpIHtcbiAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5TVEFSVF9FWFBSLCBjKTtcbiAgfSBlbHNlIGlmIChjID09PSAnKScgfHwgYyA9PT0gJ10nKSB7XG4gICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRU5EX0VYUFIsIGMpO1xuICB9IGVsc2UgaWYgKGMgPT09ICd7Jykge1xuICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlNUQVJUX0JMT0NLLCBjKTtcbiAgfSBlbHNlIGlmIChjID09PSAnfScpIHtcbiAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5FTkRfQkxPQ0ssIGMpO1xuICB9IGVsc2UgaWYgKGMgPT09ICc7Jykge1xuICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlNFTUlDT0xPTiwgYyk7XG4gIH0gZWxzZSBpZiAoYyA9PT0gJy4nICYmIGRvdF9wYXR0ZXJuLnRlc3QodGhpcy5faW5wdXQucGVlaygxKSkpIHtcbiAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5ET1QsIGMpO1xuICB9IGVsc2UgaWYgKGMgPT09ICcsJykge1xuICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkNPTU1BLCBjKTtcbiAgfVxuXG4gIGlmICh0b2tlbikge1xuICAgIHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgfVxuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX3BhaXIgPSBmdW5jdGlvbihjLCBkKSB7XG4gIHZhciB0b2tlbiA9IG51bGw7XG4gIGlmIChjID09PSAnIycgJiYgZCA9PT0gJ3snKSB7XG4gICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uU1RBUlRfQkxPQ0ssIGMgKyBkKTtcbiAgfVxuXG4gIGlmICh0b2tlbikge1xuICAgIHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gIH1cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9wdW5jdHVhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5wdW5jdC5yZWFkKCk7XG5cbiAgaWYgKHJlc3VsdGluZ19zdHJpbmcgIT09ICcnKSB7XG4gICAgaWYgKHJlc3VsdGluZ19zdHJpbmcgPT09ICc9Jykge1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5FUVVBTFMsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0aW5nX3N0cmluZyA9PT0gJz8uJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5ET1QsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLk9QRVJBVE9SLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB9XG4gIH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfbm9uX2phdmFzY3JpcHQgPSBmdW5jdGlvbihjKSB7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gJyc7XG5cbiAgaWYgKGMgPT09ICcjJykge1xuICAgIGlmICh0aGlzLl9pc19maXJzdF90b2tlbigpKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLnNoZWJhbmcucmVhZCgpO1xuXG4gICAgICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlVOS05PV04sIHJlc3VsdGluZ19zdHJpbmcudHJpbSgpICsgJ1xcbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGhhbmRsZXMgZXh0ZW5kc2NyaXB0ICNpbmNsdWRlc1xuICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuaW5jbHVkZS5yZWFkKCk7XG5cbiAgICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5VTktOT1dOLCByZXN1bHRpbmdfc3RyaW5nLnRyaW0oKSArICdcXG4nKTtcbiAgICB9XG5cbiAgICBjID0gdGhpcy5faW5wdXQubmV4dCgpO1xuXG4gICAgLy8gU3BpZGVybW9ua2V5LXNwZWNpZmljIHNoYXJwIHZhcmlhYmxlcyBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcy4gQ29uc2lkZXJlZCBvYnNvbGV0ZS5cbiAgICB2YXIgc2hhcnAgPSAnIyc7XG4gICAgaWYgKHRoaXMuX2lucHV0Lmhhc05leHQoKSAmJiB0aGlzLl9pbnB1dC50ZXN0Q2hhcihkaWdpdCkpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgYyA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgICAgc2hhcnAgKz0gYztcbiAgICAgIH0gd2hpbGUgKHRoaXMuX2lucHV0Lmhhc05leHQoKSAmJiBjICE9PSAnIycgJiYgYyAhPT0gJz0nKTtcbiAgICAgIGlmIChjID09PSAnIycpIHtcbiAgICAgICAgLy9cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faW5wdXQucGVlaygpID09PSAnWycgJiYgdGhpcy5faW5wdXQucGVlaygxKSA9PT0gJ10nKSB7XG4gICAgICAgIHNoYXJwICs9ICdbXSc7XG4gICAgICAgIHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgICAgdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgPT09ICd7JyAmJiB0aGlzLl9pbnB1dC5wZWVrKDEpID09PSAnfScpIHtcbiAgICAgICAgc2hhcnAgKz0gJ3t9JztcbiAgICAgICAgdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgICB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLldPUkQsIHNoYXJwKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbnB1dC5iYWNrKCk7XG5cbiAgfSBlbHNlIGlmIChjID09PSAnPCcgJiYgdGhpcy5faXNfZmlyc3RfdG9rZW4oKSkge1xuICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuaHRtbF9jb21tZW50X3N0YXJ0LnJlYWQoKTtcbiAgICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgICAgd2hpbGUgKHRoaXMuX2lucHV0Lmhhc05leHQoKSAmJiAhdGhpcy5faW5wdXQudGVzdENoYXIoYWNvcm4ubmV3bGluZSkpIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICB9XG4gICAgICBpbl9odG1sX2NvbW1lbnQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5DT01NRU5ULCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW5faHRtbF9jb21tZW50ICYmIGMgPT09ICctJykge1xuICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuaHRtbF9jb21tZW50X2VuZC5yZWFkKCk7XG4gICAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICAgIGluX2h0bWxfY29tbWVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5DT01NRU5ULCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfY29tbWVudCA9IGZ1bmN0aW9uKGMpIHtcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgaWYgKGMgPT09ICcvJykge1xuICAgIHZhciBjb21tZW50ID0gJyc7XG4gICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoMSkgPT09ICcqJykge1xuICAgICAgLy8gcGVlayBmb3IgY29tbWVudCAvKiAuLi4gKi9cbiAgICAgIGNvbW1lbnQgPSB0aGlzLl9fcGF0dGVybnMuYmxvY2tfY29tbWVudC5yZWFkKCk7XG4gICAgICB2YXIgZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXNfY29yZS5nZXRfZGlyZWN0aXZlcyhjb21tZW50KTtcbiAgICAgIGlmIChkaXJlY3RpdmVzICYmIGRpcmVjdGl2ZXMuaWdub3JlID09PSAnc3RhcnQnKSB7XG4gICAgICAgIGNvbW1lbnQgKz0gZGlyZWN0aXZlc19jb3JlLnJlYWRJZ25vcmVkKHRoaXMuX2lucHV0KTtcbiAgICAgIH1cbiAgICAgIGNvbW1lbnQgPSBjb21tZW50LnJlcGxhY2UoYWNvcm4uYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uQkxPQ0tfQ09NTUVOVCwgY29tbWVudCk7XG4gICAgICB0b2tlbi5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2lucHV0LnBlZWsoMSkgPT09ICcvJykge1xuICAgICAgLy8gcGVlayBmb3IgY29tbWVudCAvLyAuLi5cbiAgICAgIGNvbW1lbnQgPSB0aGlzLl9fcGF0dGVybnMuY29tbWVudC5yZWFkKCk7XG4gICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5DT01NRU5ULCBjb21tZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9zdHJpbmcgPSBmdW5jdGlvbihjKSB7XG4gIGlmIChjID09PSAnYCcgfHwgYyA9PT0gXCInXCIgfHwgYyA9PT0gJ1wiJykge1xuICAgIHZhciByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIHRoaXMuaGFzX2NoYXJfZXNjYXBlcyA9IGZhbHNlO1xuXG4gICAgaWYgKGMgPT09ICdgJykge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9yZWFkX3N0cmluZ19yZWN1cnNpdmUoJ2AnLCB0cnVlLCAnJHsnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9yZWFkX3N0cmluZ19yZWN1cnNpdmUoYyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzX2NoYXJfZXNjYXBlcyAmJiB0aGlzLl9vcHRpb25zLnVuZXNjYXBlX3N0cmluZ3MpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB1bmVzY2FwZV9zdHJpbmcocmVzdWx0aW5nX3N0cmluZyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gYykge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgfVxuXG4gICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcucmVwbGFjZShhY29ybi5hbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG5cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlNUUklORywgcmVzdWx0aW5nX3N0cmluZyk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2FsbG93X3JlZ2V4cF9vcl94bWwgPSBmdW5jdGlvbihwcmV2aW91c190b2tlbikge1xuICAvLyByZWdleCBhbmQgeG1sIGNhbiBvbmx5IGFwcGVhciBpbiBzcGVjaWZpYyBsb2NhdGlvbnMgZHVyaW5nIHBhcnNpbmdcbiAgcmV0dXJuIChwcmV2aW91c190b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCAmJiBpbl9hcnJheShwcmV2aW91c190b2tlbi50ZXh0LCBbJ3JldHVybicsICdjYXNlJywgJ3Rocm93JywgJ2Vsc2UnLCAnZG8nLCAndHlwZW9mJywgJ3lpZWxkJ10pKSB8fFxuICAgIChwcmV2aW91c190b2tlbi50eXBlID09PSBUT0tFTi5FTkRfRVhQUiAmJiBwcmV2aW91c190b2tlbi50ZXh0ID09PSAnKScgJiZcbiAgICAgIHByZXZpb3VzX3Rva2VuLm9wZW5lZC5wcmV2aW91cy50eXBlID09PSBUT0tFTi5SRVNFUlZFRCAmJiBpbl9hcnJheShwcmV2aW91c190b2tlbi5vcGVuZWQucHJldmlvdXMudGV4dCwgWydpZicsICd3aGlsZScsICdmb3InXSkpIHx8XG4gICAgKGluX2FycmF5KHByZXZpb3VzX3Rva2VuLnR5cGUsIFtUT0tFTi5DT01NRU5ULCBUT0tFTi5TVEFSVF9FWFBSLCBUT0tFTi5TVEFSVF9CTE9DSywgVE9LRU4uU1RBUlQsXG4gICAgICBUT0tFTi5FTkRfQkxPQ0ssIFRPS0VOLk9QRVJBVE9SLCBUT0tFTi5FUVVBTFMsIFRPS0VOLkVPRiwgVE9LRU4uU0VNSUNPTE9OLCBUT0tFTi5DT01NQVxuICAgIF0pKTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfcmVnZXhwID0gZnVuY3Rpb24oYywgcHJldmlvdXNfdG9rZW4pIHtcblxuICBpZiAoYyA9PT0gJy8nICYmIHRoaXMuX2FsbG93X3JlZ2V4cF9vcl94bWwocHJldmlvdXNfdG9rZW4pKSB7XG4gICAgLy8gaGFuZGxlIHJlZ2V4cFxuICAgIC8vXG4gICAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgdmFyIGVzYyA9IGZhbHNlO1xuXG4gICAgdmFyIGluX2NoYXJfY2xhc3MgPSBmYWxzZTtcbiAgICB3aGlsZSAodGhpcy5faW5wdXQuaGFzTmV4dCgpICYmXG4gICAgICAoKGVzYyB8fCBpbl9jaGFyX2NsYXNzIHx8IHRoaXMuX2lucHV0LnBlZWsoKSAhPT0gYykgJiZcbiAgICAgICAgIXRoaXMuX2lucHV0LnRlc3RDaGFyKGFjb3JuLm5ld2xpbmUpKSkge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9pbnB1dC5wZWVrKCk7XG4gICAgICBpZiAoIWVzYykge1xuICAgICAgICBlc2MgPSB0aGlzLl9pbnB1dC5wZWVrKCkgPT09ICdcXFxcJztcbiAgICAgICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJ1snKSB7XG4gICAgICAgICAgaW5fY2hhcl9jbGFzcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5faW5wdXQucGVlaygpID09PSAnXScpIHtcbiAgICAgICAgICBpbl9jaGFyX2NsYXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVzYyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgPT09IGMpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuXG4gICAgICAvLyByZWdleHBzIG1heSBoYXZlIG1vZGlmaWVycyAvcmVnZXhwL01PRCAsIHNvIGZldGNoIHRob3NlLCB0b29cbiAgICAgIC8vIE9ubHkgW2dpbV0gYXJlIHZhbGlkLCBidXQgaWYgdGhlIHVzZXIgcHV0cyBpbiBnYXJiYWdlLCBkbyB3aGF0IHdlIGNhbiB0byB0YWtlIGl0LlxuICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9pbnB1dC5yZWFkKGFjb3JuLmlkZW50aWZpZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlNUUklORywgcmVzdWx0aW5nX3N0cmluZyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX3htbCA9IGZ1bmN0aW9uKGMsIHByZXZpb3VzX3Rva2VuKSB7XG5cbiAgaWYgKHRoaXMuX29wdGlvbnMuZTR4ICYmIGMgPT09IFwiPFwiICYmIHRoaXMuX2FsbG93X3JlZ2V4cF9vcl94bWwocHJldmlvdXNfdG9rZW4pKSB7XG4gICAgdmFyIHhtbFN0ciA9ICcnO1xuICAgIHZhciBtYXRjaCA9IHRoaXMuX19wYXR0ZXJucy54bWwucmVhZF9tYXRjaCgpO1xuICAgIC8vIGhhbmRsZSBlNHggeG1sIGxpdGVyYWxzXG4gICAgLy9cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIC8vIFRyaW0gcm9vdCB0YWcgdG8gYXR0ZW1wdCB0b1xuICAgICAgdmFyIHJvb3RUYWcgPSBtYXRjaFsyXS5yZXBsYWNlKC9ee1xccysvLCAneycpLnJlcGxhY2UoL1xccyt9JC8sICd9Jyk7XG4gICAgICB2YXIgaXNDdXJseVJvb3QgPSByb290VGFnLmluZGV4T2YoJ3snKSA9PT0gMDtcbiAgICAgIHZhciBkZXB0aCA9IDA7XG4gICAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGlzRW5kVGFnID0gISFtYXRjaFsxXTtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSBtYXRjaFsyXTtcbiAgICAgICAgdmFyIGlzU2luZ2xldG9uVGFnID0gKCEhbWF0Y2hbbWF0Y2gubGVuZ3RoIC0gMV0pIHx8ICh0YWdOYW1lLnNsaWNlKDAsIDgpID09PSBcIiFbQ0RBVEFbXCIpO1xuICAgICAgICBpZiAoIWlzU2luZ2xldG9uVGFnICYmXG4gICAgICAgICAgKHRhZ05hbWUgPT09IHJvb3RUYWcgfHwgKGlzQ3VybHlSb290ICYmIHRhZ05hbWUucmVwbGFjZSgvXntcXHMrLywgJ3snKS5yZXBsYWNlKC9cXHMrfSQvLCAnfScpKSkpIHtcbiAgICAgICAgICBpZiAoaXNFbmRUYWcpIHtcbiAgICAgICAgICAgIC0tZGVwdGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsrZGVwdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHhtbFN0ciArPSBtYXRjaFswXTtcbiAgICAgICAgaWYgKGRlcHRoIDw9IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBtYXRjaCA9IHRoaXMuX19wYXR0ZXJucy54bWwucmVhZF9tYXRjaCgpO1xuICAgICAgfVxuICAgICAgLy8gaWYgd2UgZGlkbid0IGNsb3NlIGNvcnJlY3RseSwga2VlcCB1bmZvcm1hdHRlZC5cbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgeG1sU3RyICs9IHRoaXMuX2lucHV0Lm1hdGNoKC9bXFxzXFxTXSovZylbMF07XG4gICAgICB9XG4gICAgICB4bWxTdHIgPSB4bWxTdHIucmVwbGFjZShhY29ybi5hbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlNUUklORywgeG1sU3RyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHVuZXNjYXBlX3N0cmluZyhzKSB7XG4gIC8vIFlvdSB0aGluayB0aGF0IGEgcmVnZXggd291bGQgd29yayBmb3IgdGhpc1xuICAvLyByZXR1cm4gcy5yZXBsYWNlKC9cXFxceChbMC05YS1mXXsyfSkvZ2ksIGZ1bmN0aW9uKG1hdGNoLCB2YWwpIHtcbiAgLy8gICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCh2YWwsIDE2KSk7XG4gIC8vICAgICB9KVxuICAvLyBIb3dldmVyLCBkZWFsaW5nIHdpdGggJ1xceGZmJywgJ1xcXFx4ZmYnLCAnXFxcXFxceGZmJyBtYWtlcyB0aGlzIG1vcmUgZnVuLlxuICB2YXIgb3V0ID0gJycsXG4gICAgZXNjYXBlZCA9IDA7XG5cbiAgdmFyIGlucHV0X3NjYW4gPSBuZXcgSW5wdXRTY2FubmVyKHMpO1xuICB2YXIgbWF0Y2hlZCA9IG51bGw7XG5cbiAgd2hpbGUgKGlucHV0X3NjYW4uaGFzTmV4dCgpKSB7XG4gICAgLy8gS2VlcCBhbnkgd2hpdGVzcGFjZSwgbm9uLXNsYXNoIGNoYXJhY3RlcnNcbiAgICAvLyBhbHNvIGtlZXAgc2xhc2ggcGFpcnMuXG4gICAgbWF0Y2hlZCA9IGlucHV0X3NjYW4ubWF0Y2goLyhbXFxzXXxbXlxcXFxdfFxcXFxcXFxcKSsvZyk7XG5cbiAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgb3V0ICs9IG1hdGNoZWRbMF07XG4gICAgfVxuXG4gICAgaWYgKGlucHV0X3NjYW4ucGVlaygpID09PSAnXFxcXCcpIHtcbiAgICAgIGlucHV0X3NjYW4ubmV4dCgpO1xuICAgICAgaWYgKGlucHV0X3NjYW4ucGVlaygpID09PSAneCcpIHtcbiAgICAgICAgbWF0Y2hlZCA9IGlucHV0X3NjYW4ubWF0Y2goL3goWzAtOUEtRmEtZl17Mn0pL2cpO1xuICAgICAgfSBlbHNlIGlmIChpbnB1dF9zY2FuLnBlZWsoKSA9PT0gJ3UnKSB7XG4gICAgICAgIG1hdGNoZWQgPSBpbnB1dF9zY2FuLm1hdGNoKC91KFswLTlBLUZhLWZdezR9KS9nKTtcbiAgICAgICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICAgICAgbWF0Y2hlZCA9IGlucHV0X3NjYW4ubWF0Y2goL3VcXHsoWzAtOUEtRmEtZl0rKVxcfS9nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICdcXFxcJztcbiAgICAgICAgaWYgKGlucHV0X3NjYW4uaGFzTmV4dCgpKSB7XG4gICAgICAgICAgb3V0ICs9IGlucHV0X3NjYW4ubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSdzIHNvbWUgZXJyb3IgZGVjb2RpbmcsIHJldHVybiB0aGUgb3JpZ2luYWwgc3RyaW5nXG4gICAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9XG5cbiAgICAgIGVzY2FwZWQgPSBwYXJzZUludChtYXRjaGVkWzFdLCAxNik7XG5cbiAgICAgIGlmIChlc2NhcGVkID4gMHg3ZSAmJiBlc2NhcGVkIDw9IDB4ZmYgJiYgbWF0Y2hlZFswXS5pbmRleE9mKCd4JykgPT09IDApIHtcbiAgICAgICAgLy8gd2UgYmFpbCBvdXQgb24gXFx4N2YuLlxceGZmLFxuICAgICAgICAvLyBsZWF2aW5nIHdob2xlIHN0cmluZyBlc2NhcGVkLFxuICAgICAgICAvLyBhcyBpdCdzIHByb2JhYmx5IGNvbXBsZXRlbHkgYmluYXJ5XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfSBlbHNlIGlmIChlc2NhcGVkID49IDB4MDAgJiYgZXNjYXBlZCA8IDB4MjApIHtcbiAgICAgICAgLy8gbGVhdmUgMHgwMC4uLjB4MWYgZXNjYXBlZFxuICAgICAgICBvdXQgKz0gJ1xcXFwnICsgbWF0Y2hlZFswXTtcbiAgICAgIH0gZWxzZSBpZiAoZXNjYXBlZCA+IDB4MTBGRkZGKSB7XG4gICAgICAgIC8vIElmIHRoZSBlc2NhcGUgc2VxdWVuY2UgaXMgb3V0IG9mIGJvdW5kcywga2VlcCB0aGUgb3JpZ2luYWwgc2VxdWVuY2UgYW5kIGNvbnRpbnVlIGNvbnZlcnNpb25cbiAgICAgICAgb3V0ICs9ICdcXFxcJyArIG1hdGNoZWRbMF07XG4gICAgICB9IGVsc2UgaWYgKGVzY2FwZWQgPT09IDB4MjIgfHwgZXNjYXBlZCA9PT0gMHgyNyB8fCBlc2NhcGVkID09PSAweDVjKSB7XG4gICAgICAgIC8vIHNpbmdsZS1xdW90ZSwgYXBvc3Ryb3BoZSwgYmFja3NsYXNoIC0gZXNjYXBlIHRoZXNlXG4gICAgICAgIG91dCArPSAnXFxcXCcgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGVzY2FwZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXNjYXBlZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLy8gaGFuZGxlIHN0cmluZ1xuLy9cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfc3RyaW5nX3JlY3Vyc2l2ZSA9IGZ1bmN0aW9uKGRlbGltaXRlciwgYWxsb3dfdW5lc2NhcGVkX25ld2xpbmVzLCBzdGFydF9zdWIpIHtcbiAgdmFyIGN1cnJlbnRfY2hhcjtcbiAgdmFyIHBhdHRlcm47XG4gIGlmIChkZWxpbWl0ZXIgPT09ICdcXCcnKSB7XG4gICAgcGF0dGVybiA9IHRoaXMuX19wYXR0ZXJucy5zaW5nbGVfcXVvdGU7XG4gIH0gZWxzZSBpZiAoZGVsaW1pdGVyID09PSAnXCInKSB7XG4gICAgcGF0dGVybiA9IHRoaXMuX19wYXR0ZXJucy5kb3VibGVfcXVvdGU7XG4gIH0gZWxzZSBpZiAoZGVsaW1pdGVyID09PSAnYCcpIHtcbiAgICBwYXR0ZXJuID0gdGhpcy5fX3BhdHRlcm5zLnRlbXBsYXRlX3RleHQ7XG4gIH0gZWxzZSBpZiAoZGVsaW1pdGVyID09PSAnfScpIHtcbiAgICBwYXR0ZXJuID0gdGhpcy5fX3BhdHRlcm5zLnRlbXBsYXRlX2V4cHJlc3Npb247XG4gIH1cblxuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IHBhdHRlcm4ucmVhZCgpO1xuICB2YXIgbmV4dCA9ICcnO1xuICB3aGlsZSAodGhpcy5faW5wdXQuaGFzTmV4dCgpKSB7XG4gICAgbmV4dCA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICBpZiAobmV4dCA9PT0gZGVsaW1pdGVyIHx8XG4gICAgICAoIWFsbG93X3VuZXNjYXBlZF9uZXdsaW5lcyAmJiBhY29ybi5uZXdsaW5lLnRlc3QobmV4dCkpKSB7XG4gICAgICB0aGlzLl9pbnB1dC5iYWNrKCk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09ICdcXFxcJyAmJiB0aGlzLl9pbnB1dC5oYXNOZXh0KCkpIHtcbiAgICAgIGN1cnJlbnRfY2hhciA9IHRoaXMuX2lucHV0LnBlZWsoKTtcblxuICAgICAgaWYgKGN1cnJlbnRfY2hhciA9PT0gJ3gnIHx8IGN1cnJlbnRfY2hhciA9PT0gJ3UnKSB7XG4gICAgICAgIHRoaXMuaGFzX2NoYXJfZXNjYXBlcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnRfY2hhciA9PT0gJ1xccicgJiYgdGhpcy5faW5wdXQucGVlaygxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgfVxuICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgfSBlbHNlIGlmIChzdGFydF9zdWIpIHtcbiAgICAgIGlmIChzdGFydF9zdWIgPT09ICckeycgJiYgbmV4dCA9PT0gJyQnICYmIHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJ3snKSB7XG4gICAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRfc3ViID09PSBuZXh0KSB7XG4gICAgICAgIGlmIChkZWxpbWl0ZXIgPT09ICdgJykge1xuICAgICAgICAgIG5leHQgKz0gdGhpcy5fcmVhZF9zdHJpbmdfcmVjdXJzaXZlKCd9JywgYWxsb3dfdW5lc2NhcGVkX25ld2xpbmVzLCAnYCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgKz0gdGhpcy5fcmVhZF9zdHJpbmdfcmVjdXJzaXZlKCdgJywgYWxsb3dfdW5lc2NhcGVkX25ld2xpbmVzLCAnJHsnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5wdXQuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbmV4dCArPSBwYXR0ZXJuLnJlYWQoKTtcbiAgICByZXN1bHRpbmdfc3RyaW5nICs9IG5leHQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0aW5nX3N0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzLlRva2VuaXplciA9IFRva2VuaXplcjtcbm1vZHVsZS5leHBvcnRzLlRPS0VOID0gVE9LRU47XG5tb2R1bGUuZXhwb3J0cy5wb3NpdGlvbmFibGVfb3BlcmF0b3JzID0gcG9zaXRpb25hYmxlX29wZXJhdG9ycy5zbGljZSgpO1xubW9kdWxlLmV4cG9ydHMubGluZV9zdGFydGVycyA9IGxpbmVfc3RhcnRlcnMuc2xpY2UoKTtcblxuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgcmVnZXhwX2hhc19zdGlja3kgPSBSZWdFeHAucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdzdGlja3knKTtcblxuZnVuY3Rpb24gSW5wdXRTY2FubmVyKGlucHV0X3N0cmluZykge1xuICB0aGlzLl9faW5wdXQgPSBpbnB1dF9zdHJpbmcgfHwgJyc7XG4gIHRoaXMuX19pbnB1dF9sZW5ndGggPSB0aGlzLl9faW5wdXQubGVuZ3RoO1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xufVxuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gMDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fX3Bvc2l0aW9uID4gMCkge1xuICAgIHRoaXMuX19wb3NpdGlvbiAtPSAxO1xuICB9XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19wb3NpdGlvbiA8IHRoaXMuX19pbnB1dF9sZW5ndGg7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbCA9IG51bGw7XG4gIGlmICh0aGlzLmhhc05leHQoKSkge1xuICAgIHZhbCA9IHRoaXMuX19pbnB1dC5jaGFyQXQodGhpcy5fX3Bvc2l0aW9uKTtcbiAgICB0aGlzLl9fcG9zaXRpb24gKz0gMTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgdmFyIHZhbCA9IG51bGw7XG4gIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgaW5kZXggKz0gdGhpcy5fX3Bvc2l0aW9uO1xuICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX19pbnB1dF9sZW5ndGgpIHtcbiAgICB2YWwgPSB0aGlzLl9faW5wdXQuY2hhckF0KGluZGV4KTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuLy8gVGhpcyBpcyBhIEphdmFTY3JpcHQgb25seSBoZWxwZXIgZnVuY3Rpb24gKG5vdCBpbiBweXRob24pXG4vLyBKYXZhc2NyaXB0IGRvZXNuJ3QgaGF2ZSBhIG1hdGNoIG1ldGhvZFxuLy8gYW5kIG5vdCBhbGwgaW1wbGVtZW50YXRpb24gc3VwcG9ydCBcInN0aWNreVwiIGZsYWcuXG4vLyBJZiB0aGV5IGRvIG5vdCBzdXBwb3J0IHN0aWNreSB0aGVuIGJvdGggdGhpcy5tYXRjaCgpIGFuZCB0aGlzLnRlc3QoKSBtZXRob2Rcbi8vIG11c3QgZ2V0IHRoZSBtYXRjaCBhbmQgY2hlY2sgdGhlIGluZGV4IG9mIHRoZSBtYXRjaC5cbi8vIElmIHN0aWNreSBpcyBzdXBwb3J0ZWQgYW5kIHNldCwgdGhpcyBtZXRob2Qgd2lsbCB1c2UgaXQuXG4vLyBPdGhlcndpc2UgaXQgd2lsbCBjaGVjayB0aGF0IGdsb2JhbCBpcyBzZXQsIGFuZCBmYWxsIGJhY2sgdG8gdGhlIHNsb3dlciBtZXRob2QuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLl9fbWF0Y2ggPSBmdW5jdGlvbihwYXR0ZXJuLCBpbmRleCkge1xuICBwYXR0ZXJuLmxhc3RJbmRleCA9IGluZGV4O1xuICB2YXIgcGF0dGVybl9tYXRjaCA9IHBhdHRlcm4uZXhlYyh0aGlzLl9faW5wdXQpO1xuXG4gIGlmIChwYXR0ZXJuX21hdGNoICYmICEocmVnZXhwX2hhc19zdGlja3kgJiYgcGF0dGVybi5zdGlja3kpKSB7XG4gICAgaWYgKHBhdHRlcm5fbWF0Y2guaW5kZXggIT09IGluZGV4KSB7XG4gICAgICBwYXR0ZXJuX21hdGNoID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGF0dGVybl9tYXRjaDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKHBhdHRlcm4sIGluZGV4KSB7XG4gIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgaW5kZXggKz0gdGhpcy5fX3Bvc2l0aW9uO1xuXG4gIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fX2lucHV0X2xlbmd0aCkge1xuICAgIHJldHVybiAhIXRoaXMuX19tYXRjaChwYXR0ZXJuLCBpbmRleCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnRlc3RDaGFyID0gZnVuY3Rpb24ocGF0dGVybiwgaW5kZXgpIHtcbiAgLy8gdGVzdCBvbmUgY2hhcmFjdGVyIHJlZ2V4IG1hdGNoXG4gIHZhciB2YWwgPSB0aGlzLnBlZWsoaW5kZXgpO1xuICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgcGF0dGVybi50ZXN0KHZhbCk7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcGF0dGVybl9tYXRjaCA9IHRoaXMuX19tYXRjaChwYXR0ZXJuLCB0aGlzLl9fcG9zaXRpb24pO1xuICBpZiAocGF0dGVybl9tYXRjaCkge1xuICAgIHRoaXMuX19wb3NpdGlvbiArPSBwYXR0ZXJuX21hdGNoWzBdLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICBwYXR0ZXJuX21hdGNoID0gbnVsbDtcbiAgfVxuICByZXR1cm4gcGF0dGVybl9tYXRjaDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKHN0YXJ0aW5nX3BhdHRlcm4sIHVudGlsX3BhdHRlcm4sIHVudGlsX2FmdGVyKSB7XG4gIHZhciB2YWwgPSAnJztcbiAgdmFyIG1hdGNoO1xuICBpZiAoc3RhcnRpbmdfcGF0dGVybikge1xuICAgIG1hdGNoID0gdGhpcy5tYXRjaChzdGFydGluZ19wYXR0ZXJuKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhbCArPSBtYXRjaFswXTtcbiAgICB9XG4gIH1cbiAgaWYgKHVudGlsX3BhdHRlcm4gJiYgKG1hdGNoIHx8ICFzdGFydGluZ19wYXR0ZXJuKSkge1xuICAgIHZhbCArPSB0aGlzLnJlYWRVbnRpbCh1bnRpbF9wYXR0ZXJuLCB1bnRpbF9hZnRlcik7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVhZFVudGlsID0gZnVuY3Rpb24ocGF0dGVybiwgdW50aWxfYWZ0ZXIpIHtcbiAgdmFyIHZhbCA9ICcnO1xuICB2YXIgbWF0Y2hfaW5kZXggPSB0aGlzLl9fcG9zaXRpb247XG4gIHBhdHRlcm4ubGFzdEluZGV4ID0gdGhpcy5fX3Bvc2l0aW9uO1xuICB2YXIgcGF0dGVybl9tYXRjaCA9IHBhdHRlcm4uZXhlYyh0aGlzLl9faW5wdXQpO1xuICBpZiAocGF0dGVybl9tYXRjaCkge1xuICAgIG1hdGNoX2luZGV4ID0gcGF0dGVybl9tYXRjaC5pbmRleDtcbiAgICBpZiAodW50aWxfYWZ0ZXIpIHtcbiAgICAgIG1hdGNoX2luZGV4ICs9IHBhdHRlcm5fbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXRjaF9pbmRleCA9IHRoaXMuX19pbnB1dF9sZW5ndGg7XG4gIH1cblxuICB2YWwgPSB0aGlzLl9faW5wdXQuc3Vic3RyaW5nKHRoaXMuX19wb3NpdGlvbiwgbWF0Y2hfaW5kZXgpO1xuICB0aGlzLl9fcG9zaXRpb24gPSBtYXRjaF9pbmRleDtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVhZFVudGlsQWZ0ZXIgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHJldHVybiB0aGlzLnJlYWRVbnRpbChwYXR0ZXJuLCB0cnVlKTtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuZ2V0X3JlZ2V4cCA9IGZ1bmN0aW9uKHBhdHRlcm4sIG1hdGNoX2Zyb20pIHtcbiAgdmFyIHJlc3VsdCA9IG51bGw7XG4gIHZhciBmbGFncyA9ICdnJztcbiAgaWYgKG1hdGNoX2Zyb20gJiYgcmVnZXhwX2hhc19zdGlja3kpIHtcbiAgICBmbGFncyA9ICd5JztcbiAgfVxuICAvLyBzdHJpbmdzIGFyZSBjb252ZXJ0ZWQgdG8gcmVnZXhwXG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIiAmJiBwYXR0ZXJuICE9PSAnJykge1xuICAgIC8vIHJlc3VsdCA9IG5ldyBSZWdFeHAocGF0dGVybi5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKSwgZmxhZ3MpO1xuICAgIHJlc3VsdCA9IG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICB9IGVsc2UgaWYgKHBhdHRlcm4pIHtcbiAgICByZXN1bHQgPSBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCBmbGFncyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuZ2V0X2xpdGVyYWxfcmVnZXhwID0gZnVuY3Rpb24obGl0ZXJhbF9zdHJpbmcpIHtcbiAgcmV0dXJuIFJlZ0V4cChsaXRlcmFsX3N0cmluZy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKSk7XG59O1xuXG4vKiBjc3MgYmVhdXRpZmllciBsZWdhY3kgaGVscGVycyAqL1xuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5wZWVrVW50aWxBZnRlciA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5fX3Bvc2l0aW9uO1xuICB2YXIgdmFsID0gdGhpcy5yZWFkVW50aWxBZnRlcihwYXR0ZXJuKTtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gc3RhcnQ7XG4gIHJldHVybiB2YWw7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmxvb2tCYWNrID0gZnVuY3Rpb24odGVzdFZhbCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLl9fcG9zaXRpb24gLSAxO1xuICByZXR1cm4gc3RhcnQgPj0gdGVzdFZhbC5sZW5ndGggJiYgdGhpcy5fX2lucHV0LnN1YnN0cmluZyhzdGFydCAtIHRlc3RWYWwubGVuZ3RoLCBzdGFydClcbiAgICAudG9Mb3dlckNhc2UoKSA9PT0gdGVzdFZhbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLklucHV0U2Nhbm5lciA9IElucHV0U2Nhbm5lcjtcblxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBJbnB1dFNjYW5uZXIgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg4KS5JbnB1dFNjYW5uZXIpO1xudmFyIFRva2VuID0gKF9fd2VicGFja19yZXF1aXJlX18oMykuVG9rZW4pO1xudmFyIFRva2VuU3RyZWFtID0gKF9fd2VicGFja19yZXF1aXJlX18oMTApLlRva2VuU3RyZWFtKTtcbnZhciBXaGl0ZXNwYWNlUGF0dGVybiA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDExKS5XaGl0ZXNwYWNlUGF0dGVybik7XG5cbnZhciBUT0tFTiA9IHtcbiAgU1RBUlQ6ICdUS19TVEFSVCcsXG4gIFJBVzogJ1RLX1JBVycsXG4gIEVPRjogJ1RLX0VPRidcbn07XG5cbnZhciBUb2tlbml6ZXIgPSBmdW5jdGlvbihpbnB1dF9zdHJpbmcsIG9wdGlvbnMpIHtcbiAgdGhpcy5faW5wdXQgPSBuZXcgSW5wdXRTY2FubmVyKGlucHV0X3N0cmluZyk7XG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLl9fdG9rZW5zID0gbnVsbDtcblxuICB0aGlzLl9wYXR0ZXJucyA9IHt9O1xuICB0aGlzLl9wYXR0ZXJucy53aGl0ZXNwYWNlID0gbmV3IFdoaXRlc3BhY2VQYXR0ZXJuKHRoaXMuX2lucHV0KTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5faW5wdXQucmVzdGFydCgpO1xuICB0aGlzLl9fdG9rZW5zID0gbmV3IFRva2VuU3RyZWFtKCk7XG5cbiAgdGhpcy5fcmVzZXQoKTtcblxuICB2YXIgY3VycmVudDtcbiAgdmFyIHByZXZpb3VzID0gbmV3IFRva2VuKFRPS0VOLlNUQVJULCAnJyk7XG4gIHZhciBvcGVuX3Rva2VuID0gbnVsbDtcbiAgdmFyIG9wZW5fc3RhY2sgPSBbXTtcbiAgdmFyIGNvbW1lbnRzID0gbmV3IFRva2VuU3RyZWFtKCk7XG5cbiAgd2hpbGUgKHByZXZpb3VzLnR5cGUgIT09IFRPS0VOLkVPRikge1xuICAgIGN1cnJlbnQgPSB0aGlzLl9nZXRfbmV4dF90b2tlbihwcmV2aW91cywgb3Blbl90b2tlbik7XG4gICAgd2hpbGUgKHRoaXMuX2lzX2NvbW1lbnQoY3VycmVudCkpIHtcbiAgICAgIGNvbW1lbnRzLmFkZChjdXJyZW50KTtcbiAgICAgIGN1cnJlbnQgPSB0aGlzLl9nZXRfbmV4dF90b2tlbihwcmV2aW91cywgb3Blbl90b2tlbik7XG4gICAgfVxuXG4gICAgaWYgKCFjb21tZW50cy5pc0VtcHR5KCkpIHtcbiAgICAgIGN1cnJlbnQuY29tbWVudHNfYmVmb3JlID0gY29tbWVudHM7XG4gICAgICBjb21tZW50cyA9IG5ldyBUb2tlblN0cmVhbSgpO1xuICAgIH1cblxuICAgIGN1cnJlbnQucGFyZW50ID0gb3Blbl90b2tlbjtcblxuICAgIGlmICh0aGlzLl9pc19vcGVuaW5nKGN1cnJlbnQpKSB7XG4gICAgICBvcGVuX3N0YWNrLnB1c2gob3Blbl90b2tlbik7XG4gICAgICBvcGVuX3Rva2VuID0gY3VycmVudDtcbiAgICB9IGVsc2UgaWYgKG9wZW5fdG9rZW4gJiYgdGhpcy5faXNfY2xvc2luZyhjdXJyZW50LCBvcGVuX3Rva2VuKSkge1xuICAgICAgY3VycmVudC5vcGVuZWQgPSBvcGVuX3Rva2VuO1xuICAgICAgb3Blbl90b2tlbi5jbG9zZWQgPSBjdXJyZW50O1xuICAgICAgb3Blbl90b2tlbiA9IG9wZW5fc3RhY2sucG9wKCk7XG4gICAgICBjdXJyZW50LnBhcmVudCA9IG9wZW5fdG9rZW47XG4gICAgfVxuXG4gICAgY3VycmVudC5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgIHByZXZpb3VzLm5leHQgPSBjdXJyZW50O1xuXG4gICAgdGhpcy5fX3Rva2Vucy5hZGQoY3VycmVudCk7XG4gICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX190b2tlbnM7XG59O1xuXG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2ZpcnN0X3Rva2VuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fdG9rZW5zLmlzRW1wdHkoKTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24oKSB7fTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0X25leHRfdG9rZW4gPSBmdW5jdGlvbihwcmV2aW91c190b2tlbiwgb3Blbl90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQucmVhZCgvLisvZyk7XG4gIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5SQVcsIHJlc3VsdGluZ19zdHJpbmcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRU9GLCAnJyk7XG4gIH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2NvbW1lbnQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfb3BlbmluZyA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19jbG9zaW5nID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgb3Blbl90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHJldHVybiBmYWxzZTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2NyZWF0ZV90b2tlbiA9IGZ1bmN0aW9uKHR5cGUsIHRleHQpIHtcbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKHR5cGUsIHRleHQsXG4gICAgdGhpcy5fcGF0dGVybnMud2hpdGVzcGFjZS5uZXdsaW5lX2NvdW50LFxuICAgIHRoaXMuX3BhdHRlcm5zLndoaXRlc3BhY2Uud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkV2hpdGVzcGFjZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcGF0dGVybnMud2hpdGVzcGFjZS5yZWFkKCk7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMuVG9rZW5pemVyID0gVG9rZW5pemVyO1xubW9kdWxlLmV4cG9ydHMuVE9LRU4gPSBUT0tFTjtcblxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gVG9rZW5TdHJlYW0ocGFyZW50X3Rva2VuKSB7XG4gIC8vIHByaXZhdGVcbiAgdGhpcy5fX3Rva2VucyA9IFtdO1xuICB0aGlzLl9fdG9rZW5zX2xlbmd0aCA9IHRoaXMuX190b2tlbnMubGVuZ3RoO1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xuICB0aGlzLl9fcGFyZW50X3Rva2VuID0gcGFyZW50X3Rva2VuO1xufVxuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX190b2tlbnNfbGVuZ3RoID09PSAwO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19wb3NpdGlvbiA8IHRoaXMuX190b2tlbnNfbGVuZ3RoO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbCA9IG51bGw7XG4gIGlmICh0aGlzLmhhc05leHQoKSkge1xuICAgIHZhbCA9IHRoaXMuX190b2tlbnNbdGhpcy5fX3Bvc2l0aW9uXTtcbiAgICB0aGlzLl9fcG9zaXRpb24gKz0gMTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbihpbmRleCkge1xuICB2YXIgdmFsID0gbnVsbDtcbiAgaW5kZXggPSBpbmRleCB8fCAwO1xuICBpbmRleCArPSB0aGlzLl9fcG9zaXRpb247XG4gIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fX3Rva2Vuc19sZW5ndGgpIHtcbiAgICB2YWwgPSB0aGlzLl9fdG9rZW5zW2luZGV4XTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gIGlmICh0aGlzLl9fcGFyZW50X3Rva2VuKSB7XG4gICAgdG9rZW4ucGFyZW50ID0gdGhpcy5fX3BhcmVudF90b2tlbjtcbiAgfVxuICB0aGlzLl9fdG9rZW5zLnB1c2godG9rZW4pO1xuICB0aGlzLl9fdG9rZW5zX2xlbmd0aCArPSAxO1xufTtcblxubW9kdWxlLmV4cG9ydHMuVG9rZW5TdHJlYW0gPSBUb2tlblN0cmVhbTtcblxuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgUGF0dGVybiA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKS5QYXR0ZXJuKTtcblxuZnVuY3Rpb24gV2hpdGVzcGFjZVBhdHRlcm4oaW5wdXRfc2Nhbm5lciwgcGFyZW50KSB7XG4gIFBhdHRlcm4uY2FsbCh0aGlzLCBpbnB1dF9zY2FubmVyLCBwYXJlbnQpO1xuICBpZiAocGFyZW50KSB7XG4gICAgdGhpcy5fbGluZV9yZWdleHAgPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fbGluZV9yZWdleHApO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX19zZXRfd2hpdGVzcGFjZV9wYXR0ZXJucygnJywgJycpO1xuICB9XG5cbiAgdGhpcy5uZXdsaW5lX2NvdW50ID0gMDtcbiAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9ICcnO1xufVxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlID0gbmV3IFBhdHRlcm4oKTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLl9fc2V0X3doaXRlc3BhY2VfcGF0dGVybnMgPSBmdW5jdGlvbih3aGl0ZXNwYWNlX2NoYXJzLCBuZXdsaW5lX2NoYXJzKSB7XG4gIHdoaXRlc3BhY2VfY2hhcnMgKz0gJ1xcXFx0ICc7XG4gIG5ld2xpbmVfY2hhcnMgKz0gJ1xcXFxuXFxcXHInO1xuXG4gIHRoaXMuX21hdGNoX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKFxuICAgICdbJyArIHdoaXRlc3BhY2VfY2hhcnMgKyBuZXdsaW5lX2NoYXJzICsgJ10rJywgdHJ1ZSk7XG4gIHRoaXMuX25ld2xpbmVfcmVnZXhwID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChcbiAgICAnXFxcXHJcXFxcbnxbJyArIG5ld2xpbmVfY2hhcnMgKyAnXScpO1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5uZXdsaW5lX2NvdW50ID0gMDtcbiAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9ICcnO1xuXG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQucmVhZCh0aGlzLl9tYXRjaF9wYXR0ZXJuKTtcbiAgaWYgKHJlc3VsdGluZ19zdHJpbmcgPT09ICcgJykge1xuICAgIHRoaXMud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4gPSAnICc7XG4gIH0gZWxzZSBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgIHZhciBtYXRjaGVzID0gdGhpcy5fX3NwbGl0KHRoaXMuX25ld2xpbmVfcmVnZXhwLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB0aGlzLm5ld2xpbmVfY291bnQgPSBtYXRjaGVzLmxlbmd0aCAtIDE7XG4gICAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9IG1hdGNoZXNbdGhpcy5uZXdsaW5lX2NvdW50XTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRpbmdfc3RyaW5nO1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLm1hdGNoaW5nID0gZnVuY3Rpb24od2hpdGVzcGFjZV9jaGFycywgbmV3bGluZV9jaGFycykge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fX3NldF93aGl0ZXNwYWNlX3BhdHRlcm5zKHdoaXRlc3BhY2VfY2hhcnMsIG5ld2xpbmVfY2hhcnMpO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBXaGl0ZXNwYWNlUGF0dGVybih0aGlzLl9pbnB1dCwgdGhpcyk7XG59O1xuXG5XaGl0ZXNwYWNlUGF0dGVybi5wcm90b3R5cGUuX19zcGxpdCA9IGZ1bmN0aW9uKHJlZ2V4cCwgaW5wdXRfc3RyaW5nKSB7XG4gIHJlZ2V4cC5sYXN0SW5kZXggPSAwO1xuICB2YXIgc3RhcnRfaW5kZXggPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBuZXh0X21hdGNoID0gcmVnZXhwLmV4ZWMoaW5wdXRfc3RyaW5nKTtcbiAgd2hpbGUgKG5leHRfbWF0Y2gpIHtcbiAgICByZXN1bHQucHVzaChpbnB1dF9zdHJpbmcuc3Vic3RyaW5nKHN0YXJ0X2luZGV4LCBuZXh0X21hdGNoLmluZGV4KSk7XG4gICAgc3RhcnRfaW5kZXggPSBuZXh0X21hdGNoLmluZGV4ICsgbmV4dF9tYXRjaFswXS5sZW5ndGg7XG4gICAgbmV4dF9tYXRjaCA9IHJlZ2V4cC5leGVjKGlucHV0X3N0cmluZyk7XG4gIH1cblxuICBpZiAoc3RhcnRfaW5kZXggPCBpbnB1dF9zdHJpbmcubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnB1c2goaW5wdXRfc3RyaW5nLnN1YnN0cmluZyhzdGFydF9pbmRleCwgaW5wdXRfc3RyaW5nLmxlbmd0aCkpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMuV2hpdGVzcGFjZVBhdHRlcm4gPSBXaGl0ZXNwYWNlUGF0dGVybjtcblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gUGF0dGVybihpbnB1dF9zY2FubmVyLCBwYXJlbnQpIHtcbiAgdGhpcy5faW5wdXQgPSBpbnB1dF9zY2FubmVyO1xuICB0aGlzLl9zdGFydGluZ19wYXR0ZXJuID0gbnVsbDtcbiAgdGhpcy5fbWF0Y2hfcGF0dGVybiA9IG51bGw7XG4gIHRoaXMuX3VudGlsX3BhdHRlcm4gPSBudWxsO1xuICB0aGlzLl91bnRpbF9hZnRlciA9IGZhbHNlO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICB0aGlzLl9zdGFydGluZ19wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXJlbnQuX3N0YXJ0aW5nX3BhdHRlcm4sIHRydWUpO1xuICAgIHRoaXMuX21hdGNoX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fbWF0Y2hfcGF0dGVybiwgdHJ1ZSk7XG4gICAgdGhpcy5fdW50aWxfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGFyZW50Ll91bnRpbF9wYXR0ZXJuKTtcbiAgICB0aGlzLl91bnRpbF9hZnRlciA9IHBhcmVudC5fdW50aWxfYWZ0ZXI7XG4gIH1cbn1cblxuUGF0dGVybi5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5faW5wdXQucmVhZCh0aGlzLl9zdGFydGluZ19wYXR0ZXJuKTtcbiAgaWYgKCF0aGlzLl9zdGFydGluZ19wYXR0ZXJuIHx8IHJlc3VsdCkge1xuICAgIHJlc3VsdCArPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX21hdGNoX3BhdHRlcm4sIHRoaXMuX3VudGlsX3BhdHRlcm4sIHRoaXMuX3VudGlsX2FmdGVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUucmVhZF9tYXRjaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faW5wdXQubWF0Y2godGhpcy5fbWF0Y2hfcGF0dGVybik7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS51bnRpbF9hZnRlciA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZSgpO1xuICByZXN1bHQuX3VudGlsX2FmdGVyID0gdHJ1ZTtcbiAgcmVzdWx0Ll91bnRpbF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXR0ZXJuKTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLnVudGlsID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fdW50aWxfYWZ0ZXIgPSBmYWxzZTtcbiAgcmVzdWx0Ll91bnRpbF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXR0ZXJuKTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLnN0YXJ0aW5nX3dpdGggPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9zdGFydGluZ19wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXR0ZXJuLCB0cnVlKTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLm1hdGNoaW5nID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fbWF0Y2hfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGF0dGVybiwgdHJ1ZSk7XG4gIHJlc3VsdC5fdXBkYXRlKCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgUGF0dGVybih0aGlzLl9pbnB1dCwgdGhpcyk7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oKSB7fTtcblxubW9kdWxlLmV4cG9ydHMuUGF0dGVybiA9IFBhdHRlcm47XG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIERpcmVjdGl2ZXMoc3RhcnRfYmxvY2tfcGF0dGVybiwgZW5kX2Jsb2NrX3BhdHRlcm4pIHtcbiAgc3RhcnRfYmxvY2tfcGF0dGVybiA9IHR5cGVvZiBzdGFydF9ibG9ja19wYXR0ZXJuID09PSAnc3RyaW5nJyA/IHN0YXJ0X2Jsb2NrX3BhdHRlcm4gOiBzdGFydF9ibG9ja19wYXR0ZXJuLnNvdXJjZTtcbiAgZW5kX2Jsb2NrX3BhdHRlcm4gPSB0eXBlb2YgZW5kX2Jsb2NrX3BhdHRlcm4gPT09ICdzdHJpbmcnID8gZW5kX2Jsb2NrX3BhdHRlcm4gOiBlbmRfYmxvY2tfcGF0dGVybi5zb3VyY2U7XG4gIHRoaXMuX19kaXJlY3RpdmVzX2Jsb2NrX3BhdHRlcm4gPSBuZXcgUmVnRXhwKHN0YXJ0X2Jsb2NrX3BhdHRlcm4gKyAvIGJlYXV0aWZ5KCBcXHcrWzpdXFx3KykrIC8uc291cmNlICsgZW5kX2Jsb2NrX3BhdHRlcm4sICdnJyk7XG4gIHRoaXMuX19kaXJlY3RpdmVfcGF0dGVybiA9IC8gKFxcdyspWzpdKFxcdyspL2c7XG5cbiAgdGhpcy5fX2RpcmVjdGl2ZXNfZW5kX2lnbm9yZV9wYXR0ZXJuID0gbmV3IFJlZ0V4cChzdGFydF9ibG9ja19wYXR0ZXJuICsgL1xcc2JlYXV0aWZ5XFxzaWdub3JlOmVuZFxccy8uc291cmNlICsgZW5kX2Jsb2NrX3BhdHRlcm4sICdnJyk7XG59XG5cbkRpcmVjdGl2ZXMucHJvdG90eXBlLmdldF9kaXJlY3RpdmVzID0gZnVuY3Rpb24odGV4dCkge1xuICBpZiAoIXRleHQubWF0Y2godGhpcy5fX2RpcmVjdGl2ZXNfYmxvY2tfcGF0dGVybikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBkaXJlY3RpdmVzID0ge307XG4gIHRoaXMuX19kaXJlY3RpdmVfcGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICB2YXIgZGlyZWN0aXZlX21hdGNoID0gdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuLmV4ZWModGV4dCk7XG5cbiAgd2hpbGUgKGRpcmVjdGl2ZV9tYXRjaCkge1xuICAgIGRpcmVjdGl2ZXNbZGlyZWN0aXZlX21hdGNoWzFdXSA9IGRpcmVjdGl2ZV9tYXRjaFsyXTtcbiAgICBkaXJlY3RpdmVfbWF0Y2ggPSB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4uZXhlYyh0ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBkaXJlY3RpdmVzO1xufTtcblxuRGlyZWN0aXZlcy5wcm90b3R5cGUucmVhZElnbm9yZWQgPSBmdW5jdGlvbihpbnB1dCkge1xuICByZXR1cm4gaW5wdXQucmVhZFVudGlsQWZ0ZXIodGhpcy5fX2RpcmVjdGl2ZXNfZW5kX2lnbm9yZV9wYXR0ZXJuKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMuRGlyZWN0aXZlcyA9IERpcmVjdGl2ZXM7XG5cblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIFBhdHRlcm4gPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxMikuUGF0dGVybik7XG5cblxudmFyIHRlbXBsYXRlX25hbWVzID0ge1xuICBkamFuZ286IGZhbHNlLFxuICBlcmI6IGZhbHNlLFxuICBoYW5kbGViYXJzOiBmYWxzZSxcbiAgcGhwOiBmYWxzZSxcbiAgc21hcnR5OiBmYWxzZSxcbiAgYW5ndWxhcjogZmFsc2Vcbn07XG5cbi8vIFRoaXMgbGV0cyB0ZW1wbGF0ZXMgYXBwZWFyIGFueXdoZXJlIHdlIHdvdWxkIGRvIGEgcmVhZFVudGlsXG4vLyBUaGUgY29zdCBpcyBoaWdoZXIgYnV0IGl0IGlzIHBheSB0byBwbGF5LlxuZnVuY3Rpb24gVGVtcGxhdGFibGVQYXR0ZXJuKGlucHV0X3NjYW5uZXIsIHBhcmVudCkge1xuICBQYXR0ZXJuLmNhbGwodGhpcywgaW5wdXRfc2Nhbm5lciwgcGFyZW50KTtcbiAgdGhpcy5fX3RlbXBsYXRlX3BhdHRlcm4gPSBudWxsO1xuICB0aGlzLl9kaXNhYmxlZCA9IE9iamVjdC5hc3NpZ24oe30sIHRlbXBsYXRlX25hbWVzKTtcbiAgdGhpcy5fZXhjbHVkZWQgPSBPYmplY3QuYXNzaWduKHt9LCB0ZW1wbGF0ZV9uYW1lcyk7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHRoaXMuX190ZW1wbGF0ZV9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXJlbnQuX190ZW1wbGF0ZV9wYXR0ZXJuKTtcbiAgICB0aGlzLl9leGNsdWRlZCA9IE9iamVjdC5hc3NpZ24odGhpcy5fZXhjbHVkZWQsIHBhcmVudC5fZXhjbHVkZWQpO1xuICAgIHRoaXMuX2Rpc2FibGVkID0gT2JqZWN0LmFzc2lnbih0aGlzLl9kaXNhYmxlZCwgcGFyZW50Ll9kaXNhYmxlZCk7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBuZXcgUGF0dGVybihpbnB1dF9zY2FubmVyKTtcbiAgdGhpcy5fX3BhdHRlcm5zID0ge1xuICAgIGhhbmRsZWJhcnNfY29tbWVudDogcGF0dGVybi5zdGFydGluZ193aXRoKC97eyEtLS8pLnVudGlsX2FmdGVyKC8tLX19LyksXG4gICAgaGFuZGxlYmFyc191bmVzY2FwZWQ6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgve3t7LykudW50aWxfYWZ0ZXIoL319fS8pLFxuICAgIGhhbmRsZWJhcnM6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgve3svKS51bnRpbF9hZnRlcigvfX0vKSxcbiAgICBwaHA6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgvPFxcPyg/Ols9IF18cGhwKS8pLnVudGlsX2FmdGVyKC9cXD8+LyksXG4gICAgZXJiOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoLzwlW14lXS8pLnVudGlsX2FmdGVyKC9bXiVdJT4vKSxcbiAgICAvLyBkamFuZ28gY29mbGljdHMgd2l0aCBoYW5kbGViYXJzIGEgYml0LlxuICAgIGRqYW5nbzogcGF0dGVybi5zdGFydGluZ193aXRoKC97JS8pLnVudGlsX2FmdGVyKC8lfS8pLFxuICAgIGRqYW5nb192YWx1ZTogcGF0dGVybi5zdGFydGluZ193aXRoKC97ey8pLnVudGlsX2FmdGVyKC99fS8pLFxuICAgIGRqYW5nb19jb21tZW50OiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3sjLykudW50aWxfYWZ0ZXIoLyN9LyksXG4gICAgc21hcnR5OiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3soPz1bXn17XFxzXFxuXSkvKS51bnRpbF9hZnRlcigvW15cXHNcXG5dfS8pLFxuICAgIHNtYXJ0eV9jb21tZW50OiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3tcXCovKS51bnRpbF9hZnRlcigvXFwqfS8pLFxuICAgIHNtYXJ0eV9saXRlcmFsOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3tsaXRlcmFsfS8pLnVudGlsX2FmdGVyKC97XFwvbGl0ZXJhbH0vKVxuICB9O1xufVxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZSA9IG5ldyBQYXR0ZXJuKCk7XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRlbXBsYXRhYmxlUGF0dGVybih0aGlzLl9pbnB1dCwgdGhpcyk7XG59O1xuXG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fX3NldF90ZW1wbGF0ZWRfcGF0dGVybigpO1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24obGFuZ3VhZ2UpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZSgpO1xuICByZXN1bHQuX2Rpc2FibGVkW2xhbmd1YWdlXSA9IHRydWU7XG4gIHJlc3VsdC5fdXBkYXRlKCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlLnJlYWRfb3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZSgpO1xuICBmb3IgKHZhciBsYW5ndWFnZSBpbiB0ZW1wbGF0ZV9uYW1lcykge1xuICAgIHJlc3VsdC5fZGlzYWJsZWRbbGFuZ3VhZ2VdID0gb3B0aW9ucy50ZW1wbGF0aW5nLmluZGV4T2YobGFuZ3VhZ2UpID09PSAtMTtcbiAgfVxuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5leGNsdWRlID0gZnVuY3Rpb24obGFuZ3VhZ2UpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZSgpO1xuICByZXN1bHQuX2V4Y2x1ZGVkW2xhbmd1YWdlXSA9IHRydWU7XG4gIHJlc3VsdC5fdXBkYXRlKCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhpcy5fbWF0Y2hfcGF0dGVybikge1xuICAgIHJlc3VsdCA9IHRoaXMuX2lucHV0LnJlYWQodGhpcy5fc3RhcnRpbmdfcGF0dGVybik7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gdGhpcy5faW5wdXQucmVhZCh0aGlzLl9zdGFydGluZ19wYXR0ZXJuLCB0aGlzLl9fdGVtcGxhdGVfcGF0dGVybik7XG4gIH1cbiAgdmFyIG5leHQgPSB0aGlzLl9yZWFkX3RlbXBsYXRlKCk7XG4gIHdoaWxlIChuZXh0KSB7XG4gICAgaWYgKHRoaXMuX21hdGNoX3BhdHRlcm4pIHtcbiAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQucmVhZCh0aGlzLl9tYXRjaF9wYXR0ZXJuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5yZWFkVW50aWwodGhpcy5fX3RlbXBsYXRlX3BhdHRlcm4pO1xuICAgIH1cbiAgICByZXN1bHQgKz0gbmV4dDtcbiAgICBuZXh0ID0gdGhpcy5fcmVhZF90ZW1wbGF0ZSgpO1xuICB9XG5cbiAgaWYgKHRoaXMuX3VudGlsX2FmdGVyKSB7XG4gICAgcmVzdWx0ICs9IHRoaXMuX2lucHV0LnJlYWRVbnRpbEFmdGVyKHRoaXMuX3VudGlsX3BhdHRlcm4pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlLl9fc2V0X3RlbXBsYXRlZF9wYXR0ZXJuID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdO1xuXG4gIGlmICghdGhpcy5fZGlzYWJsZWQucGhwKSB7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMucGhwLl9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gIH1cbiAgaWYgKCF0aGlzLl9kaXNhYmxlZC5oYW5kbGViYXJzKSB7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuaGFuZGxlYmFycy5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICB9XG4gIGlmICghdGhpcy5fZGlzYWJsZWQuZXJiKSB7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuZXJiLl9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gIH1cbiAgaWYgKCF0aGlzLl9kaXNhYmxlZC5kamFuZ28pIHtcbiAgICBpdGVtcy5wdXNoKHRoaXMuX19wYXR0ZXJucy5kamFuZ28uX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgICAvLyBUaGUgc3RhcnRpbmcgcGF0dGVybiBmb3IgZGphbmdvIGlzIG1vcmUgY29tcGxleCBiZWNhdXNlIGl0IGhhcyBkaWZmZXJlbnRcbiAgICAvLyBwYXR0ZXJucyBmb3IgdmFsdWUsIGNvbW1lbnQsIGFuZCBvdGhlciBzZWN0aW9uc1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLmRqYW5nb192YWx1ZS5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLmRqYW5nb19jb21tZW50Ll9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gIH1cbiAgaWYgKCF0aGlzLl9kaXNhYmxlZC5zbWFydHkpIHtcbiAgICBpdGVtcy5wdXNoKHRoaXMuX19wYXR0ZXJucy5zbWFydHkuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuXG4gIGlmICh0aGlzLl91bnRpbF9wYXR0ZXJuKSB7XG4gICAgaXRlbXMucHVzaCh0aGlzLl91bnRpbF9wYXR0ZXJuLnNvdXJjZSk7XG4gIH1cbiAgdGhpcy5fX3RlbXBsYXRlX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKCcoPzonICsgaXRlbXMuam9pbignfCcpICsgJyknKTtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuX3JlYWRfdGVtcGxhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSAnJztcbiAgdmFyIGMgPSB0aGlzLl9pbnB1dC5wZWVrKCk7XG4gIGlmIChjID09PSAnPCcpIHtcbiAgICB2YXIgcGVlazEgPSB0aGlzLl9pbnB1dC5wZWVrKDEpO1xuICAgIC8vaWYgd2UncmUgaW4gYSBjb21tZW50LCBkbyBzb21ldGhpbmcgc3BlY2lhbFxuICAgIC8vIFdlIHRyZWF0IGFsbCBjb21tZW50cyBhcyBsaXRlcmFscywgZXZlbiBtb3JlIHRoYW4gcHJlZm9ybWF0dGVkIHRhZ3NcbiAgICAvLyB3ZSBqdXN0IGxvb2sgZm9yIHRoZSBhcHByb3ByaWF0ZSBjbG9zZSB0YWdcbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVkLnBocCAmJiAhdGhpcy5fZXhjbHVkZWQucGhwICYmIHBlZWsxID09PSAnPycpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5waHAucmVhZCgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVkLmVyYiAmJiAhdGhpcy5fZXhjbHVkZWQuZXJiICYmIHBlZWsxID09PSAnJScpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5lcmIucmVhZCgpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjID09PSAneycpIHtcbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVkLmhhbmRsZWJhcnMgJiYgIXRoaXMuX2V4Y2x1ZGVkLmhhbmRsZWJhcnMpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzX2NvbW1lbnQucmVhZCgpO1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnNfdW5lc2NhcGVkLnJlYWQoKTtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgIHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzLnJlYWQoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kaXNhYmxlZC5kamFuZ28pIHtcbiAgICAgIC8vIGRqYW5nbyBjb2ZsaWN0cyB3aXRoIGhhbmRsZWJhcnMgYSBiaXQuXG4gICAgICBpZiAoIXRoaXMuX2V4Y2x1ZGVkLmRqYW5nbyAmJiAhdGhpcy5fZXhjbHVkZWQuaGFuZGxlYmFycykge1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICAgIHRoaXMuX19wYXR0ZXJucy5kamFuZ29fdmFsdWUucmVhZCgpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9leGNsdWRlZC5kamFuZ28pIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgICB0aGlzLl9fcGF0dGVybnMuZGphbmdvX2NvbW1lbnQucmVhZCgpO1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICAgIHRoaXMuX19wYXR0ZXJucy5kamFuZ28ucmVhZCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVkLnNtYXJ0eSkge1xuICAgICAgLy8gc21hcnR5IGNhbm5vdCBiZSBlbmFibGVkIHdpdGggZGphbmdvIG9yIGhhbmRsZWJhcnMgZW5hYmxlZFxuICAgICAgaWYgKHRoaXMuX2Rpc2FibGVkLmRqYW5nbyAmJiB0aGlzLl9kaXNhYmxlZC5oYW5kbGViYXJzKSB7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgICAgdGhpcy5fX3BhdHRlcm5zLnNtYXJ0eV9jb21tZW50LnJlYWQoKTtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgICB0aGlzLl9fcGF0dGVybnMuc21hcnR5X2xpdGVyYWwucmVhZCgpO1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICAgIHRoaXMuX19wYXR0ZXJucy5zbWFydHkucmVhZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0aW5nX3N0cmluZztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMuVGVtcGxhdGFibGVQYXR0ZXJuID0gVGVtcGxhdGFibGVQYXR0ZXJuO1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBcdF0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gXHRsZWdhY3lfYmVhdXRpZnlfanMgPSBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIH0pKClcbjtcbnZhciBqc19iZWF1dGlmeSA9IGxlZ2FjeV9iZWF1dGlmeV9qcztcbi8qIEZvb3RlciAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIEFNRCAoIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTUQjZGVmaW5lYW1kLXByb3BlcnR5LSApXG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHsganNfYmVhdXRpZnk6IGpzX2JlYXV0aWZ5IH07XG4gICAgfSk7XG59IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIENvbW1vbkpTLiBKdXN0IHB1dCB0aGlzIGZpbGUgc29tZXdoZXJlIG9uIHlvdXIgcmVxdWlyZS5wYXRoc1xuICAgIC8vIGFuZCB5b3Ugd2lsbCBiZSBhYmxlIHRvIGB2YXIganNfYmVhdXRpZnkgPSByZXF1aXJlKFwiYmVhdXRpZnlcIikuanNfYmVhdXRpZnlgLlxuICAgIGV4cG9ydHMuanNfYmVhdXRpZnkgPSBqc19iZWF1dGlmeTtcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIElmIHdlJ3JlIHJ1bm5pbmcgYSB3ZWIgcGFnZSBhbmQgZG9uJ3QgaGF2ZSBlaXRoZXIgb2YgdGhlIGFib3ZlLCBhZGQgb3VyIG9uZSBnbG9iYWxcbiAgICB3aW5kb3cuanNfYmVhdXRpZnkgPSBqc19iZWF1dGlmeTtcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIElmIHdlIGRvbid0IGV2ZW4gaGF2ZSB3aW5kb3csIHRyeSBnbG9iYWwuXG4gICAgZ2xvYmFsLmpzX2JlYXV0aWZ5ID0ganNfYmVhdXRpZnk7XG59XG5cbn0oKSk7XG5cbiJdLCJuYW1lcyI6WyJsZWdhY3lfYmVhdXRpZnlfanMiLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwibW9kdWxlIiwiX191bnVzZWRfd2VicGFja19leHBvcnRzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIkJlYXV0aWZpZXIiLCJPcHRpb25zIiwianNfYmVhdXRpZnkiLCJqc19zb3VyY2VfdGV4dCIsIm9wdGlvbnMiLCJiZWF1dGlmaWVyIiwiYmVhdXRpZnkiLCJleHBvcnRzIiwiZGVmYXVsdE9wdGlvbnMiLCJPdXRwdXQiLCJUb2tlbiIsImFjb3JuIiwiVG9rZW5pemVyIiwibGluZV9zdGFydGVycyIsInBvc2l0aW9uYWJsZV9vcGVyYXRvcnMiLCJUT0tFTiIsImluX2FycmF5Iiwid2hhdCIsImFyciIsImluZGV4T2YiLCJsdHJpbSIsInMiLCJyZXBsYWNlIiwiZ2VuZXJhdGVNYXBGcm9tU3RyaW5ncyIsImxpc3QiLCJyZXN1bHQiLCJ4IiwibGVuZ3RoIiwicmVzZXJ2ZWRfd29yZCIsInRva2VuIiwid29yZCIsInR5cGUiLCJSRVNFUlZFRCIsInRleHQiLCJyZXNlcnZlZF9hcnJheSIsIndvcmRzIiwic3BlY2lhbF93b3JkcyIsInZhbGlkUG9zaXRpb25WYWx1ZXMiLCJPUEVSQVRPUl9QT1NJVElPTiIsIk9QRVJBVE9SX1BPU0lUSU9OX0JFRk9SRV9PUl9QUkVTRVJWRSIsImJlZm9yZV9uZXdsaW5lIiwicHJlc2VydmVfbmV3bGluZSIsIk1PREUiLCJCbG9ja1N0YXRlbWVudCIsIlN0YXRlbWVudCIsIk9iamVjdExpdGVyYWwiLCJBcnJheUxpdGVyYWwiLCJGb3JJbml0aWFsaXplciIsIkNvbmRpdGlvbmFsIiwiRXhwcmVzc2lvbiIsInJlbW92ZV9yZWR1bmRhbnRfaW5kZW50YXRpb24iLCJvdXRwdXQiLCJmcmFtZSIsIm11bHRpbGluZV9mcmFtZSIsIm1vZGUiLCJyZW1vdmVfaW5kZW50Iiwic3RhcnRfbGluZV9pbmRleCIsInNwbGl0X2xpbmVicmVha3MiLCJhbGxMaW5lQnJlYWtzIiwib3V0IiwiaWR4IiwicHVzaCIsInN1YnN0cmluZyIsImlzX2FycmF5IiwiaXNfZXhwcmVzc2lvbiIsImFsbF9saW5lc19zdGFydF93aXRoIiwibGluZXMiLCJjIiwiaSIsImxpbmUiLCJ0cmltIiwiY2hhckF0IiwiZWFjaF9saW5lX21hdGNoZXNfaW5kZW50IiwiaW5kZW50IiwibGVuIiwic291cmNlX3RleHQiLCJfc291cmNlX3RleHQiLCJfb3V0cHV0IiwiX3Rva2VucyIsIl9sYXN0X2xhc3RfdGV4dCIsIl9mbGFncyIsIl9wcmV2aW91c19mbGFncyIsIl9mbGFnX3N0b3JlIiwiX29wdGlvbnMiLCJwcm90b3R5cGUiLCJjcmVhdGVfZmxhZ3MiLCJmbGFnc19iYXNlIiwibmV4dF9pbmRlbnRfbGV2ZWwiLCJpbmRlbnRhdGlvbl9sZXZlbCIsImp1c3RfYWRkZWRfbmV3bGluZSIsImxpbmVfaW5kZW50X2xldmVsIiwibmV4dF9mbGFncyIsInBhcmVudCIsImxhc3RfdG9rZW4iLCJTVEFSVF9CTE9DSyIsImxhc3Rfd29yZCIsImRlY2xhcmF0aW9uX3N0YXRlbWVudCIsImRlY2xhcmF0aW9uX2Fzc2lnbm1lbnQiLCJpbmxpbmVfZnJhbWUiLCJpZl9ibG9jayIsImVsc2VfYmxvY2siLCJjbGFzc19zdGFydF9ibG9jayIsImRvX2Jsb2NrIiwiZG9fd2hpbGUiLCJpbXBvcnRfYmxvY2siLCJpbl9jYXNlX3N0YXRlbWVudCIsImluX2Nhc2UiLCJjYXNlX2JvZHkiLCJjYXNlX2Jsb2NrIiwiYWxpZ25tZW50IiwiZ2V0X2xpbmVfbnVtYmVyIiwidGVybmFyeV9kZXB0aCIsIl9yZXNldCIsImJhc2VJbmRlbnRTdHJpbmciLCJtYXRjaCIsInJhdyIsInRlc3Rfb3V0cHV0X3JhdyIsInNldF9tb2RlIiwidG9rZW5pemVyIiwidG9rZW5pemUiLCJkaXNhYmxlZCIsInN3ZWV0X2NvZGUiLCJlb2wiLCJsaW5lQnJlYWsiLCJ0ZXN0IiwiY3VycmVudF90b2tlbiIsIm5leHQiLCJoYW5kbGVfdG9rZW4iLCJnZXRfY29kZSIsInByZXNlcnZlX3N0YXRlbWVudF9mbGFncyIsIlNUQVJUX0VYUFIiLCJoYW5kbGVfc3RhcnRfZXhwciIsIkVORF9FWFBSIiwiaGFuZGxlX2VuZF9leHByIiwiaGFuZGxlX3N0YXJ0X2Jsb2NrIiwiRU5EX0JMT0NLIiwiaGFuZGxlX2VuZF9ibG9jayIsIldPUkQiLCJoYW5kbGVfd29yZCIsIlNFTUlDT0xPTiIsImhhbmRsZV9zZW1pY29sb24iLCJTVFJJTkciLCJoYW5kbGVfc3RyaW5nIiwiRVFVQUxTIiwiaGFuZGxlX2VxdWFscyIsIk9QRVJBVE9SIiwiaGFuZGxlX29wZXJhdG9yIiwiQ09NTUEiLCJoYW5kbGVfY29tbWEiLCJCTE9DS19DT01NRU5UIiwiaGFuZGxlX2Jsb2NrX2NvbW1lbnQiLCJDT01NRU5UIiwiaGFuZGxlX2NvbW1lbnQiLCJET1QiLCJoYW5kbGVfZG90IiwiRU9GIiwiaGFuZGxlX2VvZiIsIlVOS05PV04iLCJoYW5kbGVfdW5rbm93biIsImhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyIsIm5ld2xpbmVzIiwia2VlcF93aGl0ZXNwYWNlIiwia2VlcF9hcnJheV9pbmRlbnRhdGlvbiIsImNvbW1lbnRzX2JlZm9yZSIsImNvbW1lbnRfdG9rZW4iLCJwcmludF9uZXdsaW5lIiwibWF4X3ByZXNlcnZlX25ld2xpbmVzIiwicHJlc2VydmVfbmV3bGluZXMiLCJqIiwibmV3bGluZV9yZXN0cmljdGVkX3Rva2VucyIsImFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUiLCJmb3JjZV9saW5ld3JhcCIsInVuZGVmaW5lZCIsInNob3VsZFByZXNlcnZlT3JGb3JjZSIsIm9wZXJhdG9yTG9naWNBcHBsaWVzIiwic2hvdWxkUHJpbnRPcGVyYXRvck5ld2xpbmUiLCJvcGVyYXRvcl9wb3NpdGlvbiIsIndyYXBfbGluZV9sZW5ndGgiLCJzZXRfd3JhcF9wb2ludCIsImZvcmNlX25ld2xpbmUiLCJuZXh0X3Rva2VuIiwicGVlayIsInJlc3RvcmVfbW9kZSIsImFkZF9uZXdfbGluZSIsInByaW50X3Rva2VuX2xpbmVfaW5kZW50YXRpb24iLCJjdXJyZW50X2xpbmUiLCJzZXRfaW5kZW50Iiwid2hpdGVzcGFjZV9iZWZvcmUiLCJzcGFjZV9iZWZvcmVfdG9rZW4iLCJwcmludF90b2tlbiIsImFkZF9yYXdfdG9rZW4iLCJjb21tYV9maXJzdCIsInByZXZpb3VzIiwicHJldmlvdXNfbGluZSIsImxhc3QiLCJwb3BwZWQiLCJwb3AiLCJpc19lbXB0eSIsImFkZF90b2tlbiIsIm5vbl9icmVha2luZ19zcGFjZSIsInByZXZpb3VzX3Rva2VuX3dyYXBwZWQiLCJkZWluZGVudCIsInN0YXJ0X29mX29iamVjdF9wcm9wZXJ0eSIsInN0YXJ0X29mX3N0YXRlbWVudCIsInN0YXJ0IiwibmV4dF9tb2RlIiwic3BhY2VfaW5fcGFyZW4iLCJzcGFjZV9iZWZvcmVfY29uZGl0aW9uYWwiLCJwZWVrX2JhY2tfdHdvIiwic3BhY2VfYWZ0ZXJfbmFtZWRfZnVuY3Rpb24iLCJwZWVrX2JhY2tfdGhyZWUiLCJzcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uIiwic3BhY2VfaW5fZW1wdHlfcGFyZW4iLCJzZWNvbmRfdG9rZW4iLCJlbXB0eV9icmFjZXMiLCJlbXB0eV9hbm9ueW1vdXNfZnVuY3Rpb24iLCJicmFjZV9wcmVzZXJ2ZV9pbmxpbmUiLCJpbmRleCIsImNoZWNrX3Rva2VuIiwib3BlbmVkIiwiYnJhY2Vfc3R5bGUiLCJqc2xpbnRfaGFwcHkiLCJqdXN0X2FkZGVkX2JsYW5rbGluZSIsInByZWZpeCIsInN0YXJ0c1dpdGgiLCJpc0dlbmVyYXRvckFzdGVyaXNrIiwiaXNVbmFyeSIsInNwYWNlX2JlZm9yZSIsInNwYWNlX2FmdGVyIiwiaW5fdGVybmFyeSIsImlzQ29sb24iLCJpc1Rlcm5hcnlDb2xvbiIsImlzT3RoZXJDb2xvbiIsImFmdGVyX25ld2xpbmUiLCJuZXdfbGluZV9uZWVkZWQiLCJkaXJlY3RpdmVzIiwicHJlc2VydmUiLCJuZXdsaW5lIiwicHJpbnRfYmxvY2tfY29tbW1lbnQiLCJqYXZhZG9jIiwic3Rhcmxlc3MiLCJsYXN0SW5kZW50IiwibGFzdEluZGVudExlbmd0aCIsInNsaWNlIiwiYnJlYWtfY2hhaW5lZF9tZXRob2RzIiwidW5pbmRlbnRfY2hhaW5lZF9tZXRob2RzIiwiT3V0cHV0TGluZSIsIl9fcGFyZW50IiwiX19jaGFyYWN0ZXJfY291bnQiLCJfX2luZGVudF9jb3VudCIsIl9fYWxpZ25tZW50X2NvdW50IiwiX193cmFwX3BvaW50X2luZGV4IiwiX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudCIsIl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQiLCJfX3dyYXBfcG9pbnRfYWxpZ25tZW50X2NvdW50IiwiX19pdGVtcyIsImNsb25lX2VtcHR5IiwiaXRlbSIsImhhc19tYXRjaCIsInBhdHRlcm4iLCJsYXN0Q2hlY2tlZE91dHB1dCIsImdldF9pbmRlbnRfc2l6ZSIsIl9zZXRfd3JhcF9wb2ludCIsIm5leHRfbGluZSIsIl9zaG91bGRfd3JhcCIsIl9hbGxvd193cmFwIiwic3BsaWNlIiwibGFzdF9uZXdsaW5lX2luZGV4IiwibGFzdEluZGV4T2YiLCJfcmVtb3ZlX2luZGVudCIsImluZGVudF9zaXplIiwiX3JlbW92ZV93cmFwX2luZGVudCIsInRvU3RyaW5nIiwiaW5kZW50X2VtcHR5X2xpbmVzIiwiZ2V0X2luZGVudF9zdHJpbmciLCJqb2luIiwiSW5kZW50U3RyaW5nQ2FjaGUiLCJfX2NhY2hlIiwiX19pbmRlbnRfc2l6ZSIsIl9faW5kZW50X3N0cmluZyIsImluZGVudF9jaGFyIiwiaW5kZW50X3dpdGhfdGFicyIsIkFycmF5IiwiaW5kZW50X2xldmVsIiwiX19iYXNlX3N0cmluZyIsIl9fYmFzZV9zdHJpbmdfbGVuZ3RoIiwiY29sdW1uIiwiX19lbnN1cmVfY2FjaGUiLCJfX2FkZF9jb2x1bW4iLCJNYXRoIiwiZmxvb3IiLCJfX2luZGVudF9jYWNoZSIsIl9lbmRfd2l0aF9uZXdsaW5lIiwiZW5kX3dpdGhfbmV3bGluZSIsIl9fbGluZXMiLCJfX2FkZF9vdXRwdXRsaW5lIiwibGFzdF9pdGVtIiwicHJpbnRhYmxlX3Rva2VuIiwiX19hZGRfc3BhY2VfYmVmb3JlX3Rva2VuIiwib3V0cHV0X2xlbmd0aCIsImVhdF9uZXdsaW5lcyIsImVuc3VyZV9lbXB0eV9saW5lX2Fib3ZlIiwic3RhcnRzX3dpdGgiLCJlbmRzX3dpdGgiLCJwb3RlbnRpYWxFbXB0eUxpbmUiLCJjbG9zZWQiLCJfX3VudXNlZF93ZWJwYWNrX21vZHVsZSIsImJhc2VBU0NJSWlkZW50aWZpZXJTdGFydENoYXJzIiwiYmFzZUFTQ0lJaWRlbnRpZmllckNoYXJzIiwibm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyIsIm5vbkFTQ0lJaWRlbnRpZmllckNoYXJzIiwidW5pY29kZUVzY2FwZU9yQ29kZVBvaW50IiwiaWRlbnRpZmllclN0YXJ0IiwiaWRlbnRpZmllckNoYXJzIiwiaWRlbnRpZmllciIsIlJlZ0V4cCIsImlkZW50aWZpZXJNYXRjaCIsIm5vbkFTQ0lJd2hpdGVzcGFjZSIsInNvdXJjZSIsIkJhc2VPcHRpb25zIiwiY2FsbCIsInJhd19icmFjZV9zdHlsZSIsInJhd19vcHRpb25zIiwiYnJhY2VzX29uX293bl9saW5lIiwiYnJhY2Vfc3R5bGVfc3BsaXQiLCJfZ2V0X3NlbGVjdGlvbl9saXN0IiwiYnMiLCJfZ2V0X2Jvb2xlYW4iLCJ1bmVzY2FwZV9zdHJpbmdzIiwiZTR4IiwiX2dldF9zZWxlY3Rpb24iLCJtZXJnZV9jaGlsZF9maWVsZCIsIl9tZXJnZU9wdHMiLCJfZ2V0X2NoYXJhY3RlcnMiLCJfZ2V0X251bWJlciIsInRlbXBsYXRpbmciLCJfZ2V0X2FycmF5IiwibmFtZSIsImRlZmF1bHRfdmFsdWUiLCJvcHRpb25fdmFsdWUiLCJjb25jYXQiLCJzcGxpdCIsInBhcnNlSW50IiwiaXNOYU4iLCJzZWxlY3Rpb25fbGlzdCIsIkVycm9yIiwiX2lzX3ZhbGlkX3NlbGVjdGlvbiIsInNvbWUiLCJhbGxPcHRpb25zIiwiY2hpbGRGaWVsZE5hbWUiLCJmaW5hbE9wdHMiLCJfbm9ybWFsaXplT3B0cyIsImNvbnZlcnRlZE9wdHMiLCJrZXkiLCJuZXdLZXkiLCJub3JtYWxpemVPcHRzIiwibWVyZ2VPcHRzIiwiSW5wdXRTY2FubmVyIiwiQmFzZVRva2VuaXplciIsIkJBU0VUT0tFTiIsIkRpcmVjdGl2ZXMiLCJQYXR0ZXJuIiwiVGVtcGxhdGFibGVQYXR0ZXJuIiwiU1RBUlQiLCJSQVciLCJkaXJlY3RpdmVzX2NvcmUiLCJudW1iZXJfcGF0dGVybiIsImRpZ2l0IiwiZG90X3BhdHRlcm4iLCJwdW5jdCIsInB1bmN0X3BhdHRlcm4iLCJyZXNlcnZlZF93b3JkcyIsInJlc2VydmVkX3dvcmRfcGF0dGVybiIsImluX2h0bWxfY29tbWVudCIsImlucHV0X3N0cmluZyIsIl9wYXR0ZXJucyIsIndoaXRlc3BhY2UiLCJtYXRjaGluZyIsInBhdHRlcm5fcmVhZGVyIiwiX2lucHV0IiwidGVtcGxhdGFibGUiLCJyZWFkX29wdGlvbnMiLCJfX3BhdHRlcm5zIiwidGVtcGxhdGUiLCJzdGFydGluZ193aXRoIiwibnVtYmVyIiwiY29tbWVudCIsInVudGlsIiwiYmxvY2tfY29tbWVudCIsInVudGlsX2FmdGVyIiwiaHRtbF9jb21tZW50X3N0YXJ0IiwiaHRtbF9jb21tZW50X2VuZCIsImluY2x1ZGUiLCJzaGViYW5nIiwieG1sIiwic2luZ2xlX3F1b3RlIiwiZG91YmxlX3F1b3RlIiwidGVtcGxhdGVfdGV4dCIsInRlbXBsYXRlX2V4cHJlc3Npb24iLCJfaXNfY29tbWVudCIsIl9pc19vcGVuaW5nIiwiX2lzX2Nsb3NpbmciLCJvcGVuX3Rva2VuIiwiX2dldF9uZXh0X3Rva2VuIiwicHJldmlvdXNfdG9rZW4iLCJfcmVhZFdoaXRlc3BhY2UiLCJfY3JlYXRlX3Rva2VuIiwiX3JlYWRfbm9uX2phdmFzY3JpcHQiLCJfcmVhZF9zdHJpbmciLCJfcmVhZF9wYWlyIiwiX3JlYWRfd29yZCIsIl9yZWFkX3NpbmdsZXMiLCJfcmVhZF9jb21tZW50IiwiX3JlYWRfcmVnZXhwIiwiX3JlYWRfeG1sIiwiX3JlYWRfcHVuY3R1YXRpb24iLCJyZXN1bHRpbmdfc3RyaW5nIiwicmVhZCIsImQiLCJfaXNfZmlyc3RfdG9rZW4iLCJzaGFycCIsImhhc05leHQiLCJ0ZXN0Q2hhciIsImJhY2siLCJnZXRfZGlyZWN0aXZlcyIsImlnbm9yZSIsInJlYWRJZ25vcmVkIiwiaGFzX2NoYXJfZXNjYXBlcyIsIl9yZWFkX3N0cmluZ19yZWN1cnNpdmUiLCJ1bmVzY2FwZV9zdHJpbmciLCJfYWxsb3dfcmVnZXhwX29yX3htbCIsImVzYyIsImluX2NoYXJfY2xhc3MiLCJ4bWxTdHIiLCJyZWFkX21hdGNoIiwicm9vdFRhZyIsImlzQ3VybHlSb290IiwiZGVwdGgiLCJpc0VuZFRhZyIsInRhZ05hbWUiLCJpc1NpbmdsZXRvblRhZyIsImVzY2FwZWQiLCJpbnB1dF9zY2FuIiwibWF0Y2hlZCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImRlbGltaXRlciIsImFsbG93X3VuZXNjYXBlZF9uZXdsaW5lcyIsInN0YXJ0X3N1YiIsImN1cnJlbnRfY2hhciIsInJlZ2V4cF9oYXNfc3RpY2t5IiwiaGFzT3duUHJvcGVydHkiLCJfX2lucHV0IiwiX19pbnB1dF9sZW5ndGgiLCJfX3Bvc2l0aW9uIiwicmVzdGFydCIsInZhbCIsIl9fbWF0Y2giLCJsYXN0SW5kZXgiLCJwYXR0ZXJuX21hdGNoIiwiZXhlYyIsInN0aWNreSIsInN0YXJ0aW5nX3BhdHRlcm4iLCJ1bnRpbF9wYXR0ZXJuIiwicmVhZFVudGlsIiwibWF0Y2hfaW5kZXgiLCJyZWFkVW50aWxBZnRlciIsImdldF9yZWdleHAiLCJtYXRjaF9mcm9tIiwiZmxhZ3MiLCJnZXRfbGl0ZXJhbF9yZWdleHAiLCJsaXRlcmFsX3N0cmluZyIsInBlZWtVbnRpbEFmdGVyIiwibG9va0JhY2siLCJ0ZXN0VmFsIiwidG9Mb3dlckNhc2UiLCJUb2tlblN0cmVhbSIsIldoaXRlc3BhY2VQYXR0ZXJuIiwiX190b2tlbnMiLCJjdXJyZW50Iiwib3Blbl9zdGFjayIsImNvbW1lbnRzIiwiYWRkIiwiaXNFbXB0eSIsIm5ld2xpbmVfY291bnQiLCJ3aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiIsInBhcmVudF90b2tlbiIsIl9fdG9rZW5zX2xlbmd0aCIsIl9fcGFyZW50X3Rva2VuIiwiaW5wdXRfc2Nhbm5lciIsIl9saW5lX3JlZ2V4cCIsIl9fc2V0X3doaXRlc3BhY2VfcGF0dGVybnMiLCJ3aGl0ZXNwYWNlX2NoYXJzIiwibmV3bGluZV9jaGFycyIsIl9tYXRjaF9wYXR0ZXJuIiwiX25ld2xpbmVfcmVnZXhwIiwibWF0Y2hlcyIsIl9fc3BsaXQiLCJfY3JlYXRlIiwiX3VwZGF0ZSIsInJlZ2V4cCIsInN0YXJ0X2luZGV4IiwibmV4dF9tYXRjaCIsIl9zdGFydGluZ19wYXR0ZXJuIiwiX3VudGlsX3BhdHRlcm4iLCJfdW50aWxfYWZ0ZXIiLCJzdGFydF9ibG9ja19wYXR0ZXJuIiwiZW5kX2Jsb2NrX3BhdHRlcm4iLCJfX2RpcmVjdGl2ZXNfYmxvY2tfcGF0dGVybiIsIl9fZGlyZWN0aXZlX3BhdHRlcm4iLCJfX2RpcmVjdGl2ZXNfZW5kX2lnbm9yZV9wYXR0ZXJuIiwiZGlyZWN0aXZlX21hdGNoIiwiaW5wdXQiLCJ0ZW1wbGF0ZV9uYW1lcyIsImRqYW5nbyIsImVyYiIsImhhbmRsZWJhcnMiLCJwaHAiLCJzbWFydHkiLCJhbmd1bGFyIiwiX190ZW1wbGF0ZV9wYXR0ZXJuIiwiX2Rpc2FibGVkIiwiT2JqZWN0IiwiYXNzaWduIiwiX2V4Y2x1ZGVkIiwiaGFuZGxlYmFyc19jb21tZW50IiwiaGFuZGxlYmFyc191bmVzY2FwZWQiLCJkamFuZ29fdmFsdWUiLCJkamFuZ29fY29tbWVudCIsInNtYXJ0eV9jb21tZW50Iiwic21hcnR5X2xpdGVyYWwiLCJfX3NldF90ZW1wbGF0ZWRfcGF0dGVybiIsImRpc2FibGUiLCJsYW5ndWFnZSIsImV4Y2x1ZGUiLCJfcmVhZF90ZW1wbGF0ZSIsIml0ZW1zIiwicGVlazEiLCJfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18iLCJtb2R1bGVJZCIsImNhY2hlZE1vZHVsZSIsIl9fd2VicGFja19leHBvcnRzX18iLCJkZWZpbmUiLCJhbWQiLCJ3aW5kb3ciLCJnbG9iYWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/js-beautify/js/lib/beautify.js\n");

/***/ })

};
;